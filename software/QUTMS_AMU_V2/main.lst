   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.AMU_eeprom_read,"ax",@progbits
  11               	.global	AMU_eeprom_read
  13               	AMU_eeprom_read:
  14               	.LFB6:
  15               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * QUT_AMU_1.c
   3:main.c        ****  *
   4:main.c        ****  *  Created on: 25 Apr 2015
   5:main.c        ****  *      Author: julius
   6:main.c        ****  */
   7:main.c        **** 
   8:main.c        **** #include "main.h"
   9:main.c        **** 
  10:main.c        **** uint16_t AMU_eeprom_read(uint16_t address)
  11:main.c        **** {
  16               		.loc 1 11 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	.LVL0:
  23               	.L2:
  12:main.c        **** 	while(!eeprom_is_ready());
  24               		.loc 1 12 27 discriminator 1 view .LVU1
  25               		.loc 1 12 7 is_stmt 0 discriminator 1 view .LVU2
  26 0000 F999      		sbic 0x1f,1
  27 0002 00C0      		rjmp .L2
  13:main.c        **** 	return eeprom_read_word((const uint16_t *)address);
  28               		.loc 1 13 2 is_stmt 1 view .LVU3
  29               		.loc 1 13 9 is_stmt 0 view .LVU4
  30 0004 0C94 0000 		jmp eeprom_read_word
  31               	.LVL1:
  32               		.loc 1 13 9 view .LVU5
  33               		.cfi_endproc
  34               	.LFE6:
  36               		.section	.text.AMU_eeprom_write,"ax",@progbits
  37               	.global	AMU_eeprom_write
  39               	AMU_eeprom_write:
  40               	.LFB7:
  14:main.c        **** }
  15:main.c        **** 
  16:main.c        **** void AMU_eeprom_write(uint16_t address, uint16_t value)
  17:main.c        **** {
  41               		.loc 1 17 1 is_stmt 1 view -0
  42               		.cfi_startproc
  43               	/* prologue: function */
  44               	/* frame size = 0 */
  45               	/* stack size = 0 */
  46               	.L__stack_usage = 0
  47               	.LVL2:
  48               	.L5:
  18:main.c        **** 	while(!eeprom_is_ready());
  49               		.loc 1 18 27 discriminator 1 view .LVU7
  50               		.loc 1 18 7 is_stmt 0 discriminator 1 view .LVU8
  51 0000 F999      		sbic 0x1f,1
  52 0002 00C0      		rjmp .L5
  19:main.c        **** 	eeprom_write_word((uint16_t *)address, value);
  53               		.loc 1 19 2 is_stmt 1 view .LVU9
  54 0004 0C94 0000 		jmp eeprom_write_word
  55               	.LVL3:
  56               		.loc 1 19 2 is_stmt 0 view .LVU10
  57               		.cfi_endproc
  58               	.LFE7:
  60               		.section	.text.Parameters_init,"ax",@progbits
  61               	.global	Parameters_init
  63               	Parameters_init:
  64               	.LFB8:
  20:main.c        **** }
  21:main.c        **** 
  22:main.c        **** void Parameters_init()
  23:main.c        **** {
  65               		.loc 1 23 1 is_stmt 1 view -0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  24:main.c        **** 	deviceID  = AMU_eeprom_read(EEPROM_DEVICE_ID);
  71               		.loc 1 24 2 view .LVU12
  72               		.loc 1 24 14 is_stmt 0 view .LVU13
  73 0000 90E0      		ldi r25,0
  74 0002 80E0      		ldi r24,0
  75 0004 0E94 0000 		call AMU_eeprom_read
  76               	.LVL4:
  77               		.loc 1 24 12 view .LVU14
  78 0008 9093 0000 		sts deviceID+1,r25
  79 000c 8093 0000 		sts deviceID,r24
  25:main.c        **** 	fw_version = AMU_eeprom_read(EEPROM_FW_VERSION);
  80               		.loc 1 25 2 is_stmt 1 view .LVU15
  81               		.loc 1 25 15 is_stmt 0 view .LVU16
  82 0010 82E0      		ldi r24,lo8(2)
  83 0012 90E0      		ldi r25,0
  84 0014 0E94 0000 		call AMU_eeprom_read
  85               	.LVL5:
  86               		.loc 1 25 13 view .LVU17
  87 0018 9093 0000 		sts fw_version+1,r25
  88 001c 8093 0000 		sts fw_version,r24
  89               	/* epilogue start */
  26:main.c        **** }
  90               		.loc 1 26 1 view .LVU18
  91 0020 0895      		ret
  92               		.cfi_endproc
  93               	.LFE8:
  95               		.section	.text.PCINT_init,"ax",@progbits
  96               	.global	PCINT_init
  98               	PCINT_init:
  99               	.LFB9:
  27:main.c        **** 
  28:main.c        **** void PCINT_init() //Needed for detecting interrupts from the MCP2515
  29:main.c        **** {
 100               		.loc 1 29 1 is_stmt 1 view -0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  30:main.c        **** 	PCICR = (1<<PCIE0);			//enable from pin 26 to pin 16
 106               		.loc 1 30 2 view .LVU20
 107               		.loc 1 30 8 is_stmt 0 view .LVU21
 108 0000 81E0      		ldi r24,lo8(1)
 109 0002 8093 6800 		sts 104,r24
  31:main.c        **** 	MCP2515_reg_write(MCP2515_CANINTF, 0b00000000);
 110               		.loc 1 31 2 is_stmt 1 view .LVU22
 111 0006 60E0      		ldi r22,0
 112 0008 8CE2      		ldi r24,lo8(44)
 113 000a 0E94 0000 		call MCP2515_reg_write
 114               	.LVL6:
  32:main.c        **** 	PCMSK0 = (1<<PCINT4)|(1<<PCINT3);
 115               		.loc 1 32 2 view .LVU23
 116               		.loc 1 32 9 is_stmt 0 view .LVU24
 117 000e 88E1      		ldi r24,lo8(24)
 118 0010 8093 6A00 		sts 106,r24
 119               	/* epilogue start */
  33:main.c        **** 	
  34:main.c        **** }
 120               		.loc 1 34 1 view .LVU25
 121 0014 0895      		ret
 122               		.cfi_endproc
 123               	.LFE9:
 125               		.section	.text.init_cmuData,"ax",@progbits
 126               	.global	init_cmuData
 128               	init_cmuData:
 129               	.LVL7:
 130               	.LFB10:
  35:main.c        **** 
  36:main.c        **** /**
  37:main.c        ****  * Function: init_cmuData
  38:main.c        ****  * Will fill in the blank cmu struct array with zeros
  39:main.c        ****  */
  40:main.c        **** void init_cmuData(CMU * cmu)
  41:main.c        **** {
 131               		.loc 1 41 1 is_stmt 1 view -0
 132               		.cfi_startproc
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
  42:main.c        **** 	for(uint8_t count = 0; count < CMU_COUNT; count++)
 137               		.loc 1 42 2 view .LVU27
 138               	.LBB75:
 139               		.loc 1 42 6 view .LVU28
 140               		.loc 1 42 6 is_stmt 0 view .LVU29
 141 0000 9C01      		movw r18,r24
 142 0002 2E5E      		subi r18,-18
 143 0004 3F4F      		sbci r19,-1
 144 0006 AC01      		movw r20,r24
 145 0008 4A59      		subi r20,-102
 146 000a 5F4F      		sbci r21,-1
 147               	.LVL8:
 148               	.L11:
  43:main.c        **** 	{
  44:main.c        **** 		cmu->CMU_num = 0;
 149               		.loc 1 44 3 is_stmt 1 view .LVU30
 150               		.loc 1 44 16 is_stmt 0 view .LVU31
 151 000c FC01      		movw r30,r24
 152 000e 1082      		st Z,__zero_reg__
  45:main.c        **** 		cmu->CMU_ID = 0;
 153               		.loc 1 45 3 is_stmt 1 view .LVU32
 154               		.loc 1 45 15 is_stmt 0 view .LVU33
 155 0010 1182      		std Z+1,__zero_reg__
  46:main.c        **** 		for(uint8_t count2 = 0; count2 < CMU_CELL_COUNT; count2++)
 156               		.loc 1 46 3 is_stmt 1 view .LVU34
 157               	.LBB76:
 158               		.loc 1 46 7 view .LVU35
 159               	.LVL9:
 160               		.loc 1 46 7 is_stmt 0 view .LVU36
 161 0012 3296      		adiw r30,2
 162               	.LVL10:
 163               	.L10:
  47:main.c        **** 		{
  48:main.c        **** 			cmu->temperatures[count2]=0;
 164               		.loc 1 48 4 is_stmt 1 discriminator 3 view .LVU37
 165               		.loc 1 48 29 is_stmt 0 discriminator 3 view .LVU38
 166 0014 118A      		std Z+17,__zero_reg__
 167 0016 108A      		std Z+16,__zero_reg__
  49:main.c        **** 			cmu->voltages[count2]=0;
 168               		.loc 1 49 4 is_stmt 1 discriminator 3 view .LVU39
 169               		.loc 1 49 25 is_stmt 0 discriminator 3 view .LVU40
 170 0018 1192      		st Z+,__zero_reg__
 171 001a 1192      		st Z+,__zero_reg__
  46:main.c        **** 		for(uint8_t count2 = 0; count2 < CMU_CELL_COUNT; count2++)
 172               		.loc 1 46 3 discriminator 3 view .LVU41
 173 001c E217      		cp r30,r18
 174 001e F307      		cpc r31,r19
 175 0020 01F4      		brne .L10
 176               	.LBE76:
  50:main.c        **** 		}
  51:main.c        **** 		cmu++;
 177               		.loc 1 51 3 is_stmt 1 discriminator 2 view .LVU42
 178               		.loc 1 51 6 is_stmt 0 discriminator 2 view .LVU43
 179 0022 8296      		adiw r24,34
 180               	.LVL11:
 181               		.loc 1 51 6 discriminator 2 view .LVU44
 182 0024 9F01      		movw r18,r30
 183 0026 2E5D      		subi r18,-34
 184 0028 3F4F      		sbci r19,-1
  42:main.c        **** 	{
 185               		.loc 1 42 2 discriminator 2 view .LVU45
 186 002a 8417      		cp r24,r20
 187 002c 9507      		cpc r25,r21
 188 002e 01F4      		brne .L11
 189               	/* epilogue start */
 190               	.LBE75:
  52:main.c        **** 	}
  53:main.c        **** }
 191               		.loc 1 53 1 view .LVU46
 192 0030 0895      		ret
 193               		.cfi_endproc
 194               	.LFE10:
 196               		.section	.text.IO_init,"ax",@progbits
 197               	.global	IO_init
 199               	IO_init:
 200               	.LFB11:
  54:main.c        **** 
  55:main.c        **** void IO_init()
  56:main.c        **** {
 201               		.loc 1 56 1 is_stmt 1 view -0
 202               		.cfi_startproc
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 205               	/* stack size = 0 */
 206               	.L__stack_usage = 0
  57:main.c        **** 	DDRB  = 0b11000110;
 207               		.loc 1 57 2 view .LVU48
 208               		.loc 1 57 8 is_stmt 0 view .LVU49
 209 0000 86EC      		ldi r24,lo8(-58)
 210 0002 84B9      		out 0x4,r24
  58:main.c        **** 	DDRD  = 0b10001011;
 211               		.loc 1 58 2 is_stmt 1 view .LVU50
 212               		.loc 1 58 8 is_stmt 0 view .LVU51
 213 0004 8BE8      		ldi r24,lo8(-117)
 214 0006 8AB9      		out 0xa,r24
  59:main.c        **** 	DDRC  = 0b10100111;
 215               		.loc 1 59 2 is_stmt 1 view .LVU52
 216               		.loc 1 59 8 is_stmt 0 view .LVU53
 217 0008 87EA      		ldi r24,lo8(-89)
 218 000a 87B9      		out 0x7,r24
  60:main.c        **** 	PORTB = 0b00000000;
 219               		.loc 1 60 2 is_stmt 1 view .LVU54
 220               		.loc 1 60 8 is_stmt 0 view .LVU55
 221 000c 15B8      		out 0x5,__zero_reg__
  61:main.c        **** 
  62:main.c        **** 	PORTD |= (1<<PIND1)|(1<<PIND7)|(1<<PIND3);		//the SS pin needs to be configured as an output, othe
 222               		.loc 1 62 2 is_stmt 1 view .LVU56
 223               		.loc 1 62 8 is_stmt 0 view .LVU57
 224 000e 8BB1      		in r24,0xb
 225 0010 8A68      		ori r24,lo8(-118)
 226 0012 8BB9      		out 0xb,r24
  63:main.c        **** 	PORTC |= 1<<PINC7;					//set CS high
 227               		.loc 1 63 2 is_stmt 1 view .LVU58
 228               		.loc 1 63 8 is_stmt 0 view .LVU59
 229 0014 479A      		sbi 0x8,7
  64:main.c        **** 	PORTC |= (1<<MCP2515_PIN_RESET);	//set reset to high
 230               		.loc 1 64 2 is_stmt 1 view .LVU60
 231               		.loc 1 64 8 is_stmt 0 view .LVU61
 232 0016 459A      		sbi 0x8,5
  65:main.c        **** 	PORTB &= ~(1<<PINB7);		//make sure it's set up for input.
 233               		.loc 1 65 2 is_stmt 1 view .LVU62
 234               		.loc 1 65 8 is_stmt 0 view .LVU63
 235 0018 2F98      		cbi 0x5,7
  66:main.c        **** 	ALARM_PORT |= (1<<ALARM_PIN);
 236               		.loc 1 66 2 is_stmt 1 view .LVU64
 237               		.loc 1 66 13 is_stmt 0 view .LVU65
 238 001a 409A      		sbi 0x8,0
 239               	/* epilogue start */
  67:main.c        **** }
 240               		.loc 1 67 1 view .LVU66
 241 001c 0895      		ret
 242               		.cfi_endproc
 243               	.LFE11:
 245               		.section	.text.timer_init,"ax",@progbits
 246               	.global	timer_init
 248               	timer_init:
 249               	.LFB12:
  68:main.c        **** 
  69:main.c        **** void timer_init()
  70:main.c        **** {
 250               		.loc 1 70 1 is_stmt 1 view -0
 251               		.cfi_startproc
 252               	/* prologue: function */
 253               	/* frame size = 0 */
 254               	/* stack size = 0 */
 255               	.L__stack_usage = 0
  71:main.c        **** 	TCCR0A = 0x00;							//normal mode.
 256               		.loc 1 71 2 view .LVU68
 257               		.loc 1 71 9 is_stmt 0 view .LVU69
 258 0000 14BC      		out 0x24,__zero_reg__
  72:main.c        **** 	TCCR0B = (1<<CS02)|(0<<CS01)|(1<<CS00);	//prescale clock by 1024
 259               		.loc 1 72 2 is_stmt 1 view .LVU70
 260               		.loc 1 72 9 is_stmt 0 view .LVU71
 261 0002 85E0      		ldi r24,lo8(5)
 262 0004 85BD      		out 0x25,r24
  73:main.c        **** 	TIMSK0 = (1<<TOIE0);					//allow interrupts
 263               		.loc 1 73 2 is_stmt 1 view .LVU72
 264               		.loc 1 73 9 is_stmt 0 view .LVU73
 265 0006 81E0      		ldi r24,lo8(1)
 266 0008 8093 6E00 		sts 110,r24
 267               	/* epilogue start */
  74:main.c        **** }
 268               		.loc 1 74 1 view .LVU74
 269 000c 0895      		ret
 270               		.cfi_endproc
 271               	.LFE12:
 273               		.section	.text.ADC_init,"ax",@progbits
 274               	.global	ADC_init
 276               	ADC_init:
 277               	.LFB13:
  75:main.c        **** 
  76:main.c        **** void ADC_init()
  77:main.c        **** {
 278               		.loc 1 77 1 is_stmt 1 view -0
 279               		.cfi_startproc
 280               	/* prologue: function */
 281               	/* frame size = 0 */
 282               	/* stack size = 0 */
 283               	.L__stack_usage = 0
  78:main.c        **** 	ADMUX=(1<<REFS0)|(1<<AREFEN);                      // For Aref=AVcc with external capacitor;
 284               		.loc 1 78 2 view .LVU76
 285               		.loc 1 78 7 is_stmt 0 view .LVU77
 286 0000 ECE7      		ldi r30,lo8(124)
 287 0002 F0E0      		ldi r31,0
 288 0004 80E6      		ldi r24,lo8(96)
 289 0006 8083      		st Z,r24
  79:main.c        **** 	ADMUX &= ~(1<<ADLAR);								//make sure adlar is not set.
 290               		.loc 1 79 2 is_stmt 1 view .LVU78
 291               		.loc 1 79 8 is_stmt 0 view .LVU79
 292 0008 8081      		ld r24,Z
 293 000a 8F7D      		andi r24,lo8(-33)
 294 000c 8083      		st Z,r24
  80:main.c        **** 	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Prescaler div factor = 128, 125kHz --> lowest
 295               		.loc 1 80 2 is_stmt 1 view .LVU80
 296               		.loc 1 80 8 is_stmt 0 view .LVU81
 297 000e 87E8      		ldi r24,lo8(-121)
 298 0010 8093 7A00 		sts 122,r24
 299               	/* epilogue start */
  81:main.c        **** }
 300               		.loc 1 81 1 view .LVU82
 301 0014 0895      		ret
 302               		.cfi_endproc
 303               	.LFE13:
 305               		.section	.text.ADC_read,"ax",@progbits
 306               	.global	ADC_read
 308               	ADC_read:
 309               	.LVL12:
 310               	.LFB14:
  82:main.c        **** 
  83:main.c        **** uint16_t ADC_read(uint8_t channel)
  84:main.c        **** {
 311               		.loc 1 84 1 is_stmt 1 view -0
 312               		.cfi_startproc
 313               	/* prologue: function */
 314               	/* frame size = 0 */
 315               	/* stack size = 0 */
 316               	.L__stack_usage = 0
  85:main.c        **** 	channel = (ADMUX & 0xe0)|(channel & 0x1F); //ADMUX | 0b11100000 and channel | 0b00011111 --> this 
 317               		.loc 1 85 2 view .LVU84
 318               		.loc 1 85 13 is_stmt 0 view .LVU85
 319 0000 9091 7C00 		lds r25,124
 320               		.loc 1 85 19 view .LVU86
 321 0004 907E      		andi r25,lo8(-32)
 322               		.loc 1 85 36 view .LVU87
 323 0006 8F71      		andi r24,lo8(31)
 324               	.LVL13:
 325               		.loc 1 85 26 view .LVU88
 326 0008 982B      		or r25,r24
 327               	.LVL14:
  86:main.c        **** 	ADMUX = channel;
 328               		.loc 1 86 2 is_stmt 1 view .LVU89
 329               		.loc 1 86 8 is_stmt 0 view .LVU90
 330 000a 9093 7C00 		sts 124,r25
  87:main.c        **** 	ADCSRA |= (1<<ADSC);							//ADSC (single conversion bit) is set to 1 to start the conversion proc
 331               		.loc 1 87 2 is_stmt 1 view .LVU91
 332               		.loc 1 87 9 is_stmt 0 view .LVU92
 333 000e 8091 7A00 		lds r24,122
 334 0012 8064      		ori r24,lo8(64)
 335 0014 8093 7A00 		sts 122,r24
  88:main.c        **** 	while(!(ADCSRA & (1<<ADIF)));				//run a loop while the conversion is taking place.
 336               		.loc 1 88 2 is_stmt 1 view .LVU93
 337               	.L18:
 338               		.loc 1 88 30 discriminator 1 view .LVU94
 339               		.loc 1 88 10 is_stmt 0 discriminator 1 view .LVU95
 340 0018 8091 7A00 		lds r24,122
 341               		.loc 1 88 7 discriminator 1 view .LVU96
 342 001c 84FF      		sbrs r24,4
 343 001e 00C0      		rjmp .L18
  89:main.c        **** 	uint16_t result = 0;
 344               		.loc 1 89 2 is_stmt 1 view .LVU97
 345               	.LVL15:
  90:main.c        **** 	result = ADCL;								//read ADCL first, ADCH after --> order is important! --> also not sure if t
 346               		.loc 1 90 2 view .LVU98
 347               		.loc 1 90 11 is_stmt 0 view .LVU99
 348 0020 2091 7800 		lds r18,120
 349               	.LVL16:
  91:main.c        **** 	result |= ((3 & ADCH) << 8);
 350               		.loc 1 91 2 is_stmt 1 view .LVU100
 351               		.loc 1 91 18 is_stmt 0 view .LVU101
 352 0024 8091 7900 		lds r24,121
 353               	.LVL17:
  92:main.c        **** 	ADCSRA|=(1<<ADIF);							//once read and done, clear the 'complete' status by writing 1 to the ADI
 354               		.loc 1 92 2 is_stmt 1 view .LVU102
 355               		.loc 1 92 8 is_stmt 0 view .LVU103
 356 0028 9091 7A00 		lds r25,122
 357               	.LVL18:
 358               		.loc 1 92 8 view .LVU104
 359 002c 9061      		ori r25,lo8(16)
 360 002e 9093 7A00 		sts 122,r25
  93:main.c        **** 	return result;								//pass the 10 bit ADC number to requesting function.
 361               		.loc 1 93 2 is_stmt 1 view .LVU105
  91:main.c        **** 	result |= ((3 & ADCH) << 8);
 362               		.loc 1 91 16 is_stmt 0 view .LVU106
 363 0032 90E0      		ldi r25,0
  91:main.c        **** 	result |= ((3 & ADCH) << 8);
 364               		.loc 1 91 24 view .LVU107
 365 0034 982F      		mov r25,r24
 366 0036 8827      		clr r24
 367               	.LVL19:
  91:main.c        **** 	result |= ((3 & ADCH) << 8);
 368               		.loc 1 91 24 view .LVU108
 369 0038 8827      		clr r24
 370 003a 9370      		andi r25,3
  94:main.c        **** }
 371               		.loc 1 94 1 view .LVU109
 372 003c 822B      		or r24,r18
 373               	/* epilogue start */
 374 003e 0895      		ret
 375               		.cfi_endproc
 376               	.LFE14:
 378               		.section	.text.CMU_send_read_receipt,"ax",@progbits
 379               	.global	CMU_send_read_receipt
 381               	CMU_send_read_receipt:
 382               	.LVL20:
 383               	.LFB15:
  95:main.c        **** 
  96:main.c        **** uint8_t CMU_send_read_receipt(CMU * cmu)
  97:main.c        **** {
 384               		.loc 1 97 1 is_stmt 1 view -0
 385               		.cfi_startproc
 386               		.loc 1 97 1 is_stmt 0 view .LVU111
 387 0000 0F93      		push r16
 388               	.LCFI0:
 389               		.cfi_def_cfa_offset 3
 390               		.cfi_offset 16, -2
 391 0002 1F93      		push r17
 392               	.LCFI1:
 393               		.cfi_def_cfa_offset 4
 394               		.cfi_offset 17, -3
 395 0004 CF93      		push r28
 396               	.LCFI2:
 397               		.cfi_def_cfa_offset 5
 398               		.cfi_offset 28, -4
 399 0006 DF93      		push r29
 400               	.LCFI3:
 401               		.cfi_def_cfa_offset 6
 402               		.cfi_offset 29, -5
 403 0008 0F92      		push __tmp_reg__
 404               	.LCFI4:
 405               		.cfi_def_cfa_offset 7
 406 000a CDB7      		in r28,__SP_L__
 407 000c DEB7      		in r29,__SP_H__
 408               	.LCFI5:
 409               		.cfi_def_cfa_register 28
 410               	/* prologue: function */
 411               	/* frame size = 1 */
 412               	/* stack size = 5 */
 413               	.L__stack_usage = 5
 414 000e 8C01      		movw r16,r24
  98:main.c        **** 	uint8_t data = 0x00; //data to send,(zeros)
 415               		.loc 1 98 2 is_stmt 1 view .LVU112
 416               		.loc 1 98 10 is_stmt 0 view .LVU113
 417 0010 1982      		std Y+1,__zero_reg__
  99:main.c        **** 	uint8_t mob = MCP2515_findFreeTxBuffer(); //obtain a free transmit buffer.
 418               		.loc 1 99 2 is_stmt 1 view .LVU114
 419               		.loc 1 99 16 is_stmt 0 view .LVU115
 420 0012 0E94 0000 		call MCP2515_findFreeTxBuffer
 421               	.LVL21:
 100:main.c        ****     //send a CAN packet from a free buffer, with recipient of our CMU ID, type: audit request (to n
 101:main.c        **** 	MCP2515_TX(mob, 0, &data, ((uint32_t)1<<27)|((uint32_t)DEVICE_ID<<18)|((uint32_t)cmu->CMU_ID<<8)|R
 422               		.loc 1 101 2 is_stmt 1 view .LVU116
 423               		.loc 1 101 73 is_stmt 0 view .LVU117
 424 0016 F801      		movw r30,r16
 425 0018 0181      		ldd r16,Z+1
 426               	.LVL22:
 427               		.loc 1 101 73 view .LVU118
 428 001a 10E0      		ldi r17,0
 429 001c 30E0      		ldi r19,0
 430 001e 20E0      		ldi r18,0
 431               		.loc 1 101 94 view .LVU119
 432 0020 322F      		mov r19,r18
 433 0022 212F      		mov r18,r17
 434 0024 102F      		mov r17,r16
 435 0026 0027      		clr r16
 436               		.loc 1 101 2 view .LVU120
 437 0028 0261      		ori r16,18
 438 002a 2460      		ori r18,4
 439 002c 3860      		ori r19,8
 440 002e AE01      		movw r20,r28
 441 0030 4F5F      		subi r20,-1
 442 0032 5F4F      		sbci r21,-1
 443 0034 60E0      		ldi r22,0
 444 0036 0E94 0000 		call MCP2515_TX
 445               	.LVL23:
 102:main.c        **** 	return 1; //return successful
 446               		.loc 1 102 2 is_stmt 1 view .LVU121
 103:main.c        **** }
 447               		.loc 1 103 1 is_stmt 0 view .LVU122
 448 003a 81E0      		ldi r24,lo8(1)
 449               	/* epilogue start */
 450 003c 0F90      		pop __tmp_reg__
 451 003e DF91      		pop r29
 452 0040 CF91      		pop r28
 453 0042 1F91      		pop r17
 454 0044 0F91      		pop r16
 455 0046 0895      		ret
 456               		.cfi_endproc
 457               	.LFE15:
 459               		.section	.text.CMU_Register.part.0,"ax",@progbits
 461               	CMU_Register.part.0:
 462               	.LVL24:
 463               	.LFB41:
 104:main.c        **** 
 105:main.c        **** uint16_t CoulombCount_init(){
 106:main.c        **** 	return AMU_eeprom_read(EEPROM_COULOMB_COUNT);
 107:main.c        **** }
 108:main.c        **** 
 109:main.c        **** uint16_t CoulombCount_instRead(){
 110:main.c        **** 	return ADC_read(ADC_HALL_EFFECT);
 111:main.c        **** }
 112:main.c        **** 
 113:main.c        **** uint16_t CoulombCount_updateAndRead(uint16_t coulombCount){
 114:main.c        **** 	
 115:main.c        **** 	/* Representative of how much time the last reading was taken. */
 116:main.c        **** 	static uint16_t ticks;									
 117:main.c        **** 	uint16_t ticks_diff = globalTicks - ticks;
 118:main.c        **** 
 119:main.c        **** 	/* Take a new reading of the instantaneous current, integrate, and add it to the coulomb count tot
 120:main.c        **** 	coulombCount += CoulombCount_instRead()*TIME_CONSTANT;
 121:main.c        **** 
 122:main.c        **** 	/* Start the timer again, which is to be read the next time current is updated */
 123:main.c        **** 	ticks = globalTicks;
 124:main.c        **** 	AMU_eeprom_write(EEPROM_COULOMB_COUNT, coulombCount);
 125:main.c        **** 	return coulombCount;
 126:main.c        **** }
 127:main.c        **** 
 128:main.c        **** /* Rough voltage to SoC representative array, voltage is in millivolts */
 129:main.c        **** uint32_t voltage2SoC_Translation[100] = {100800,99744,99216,98688,98160,97920,97680,97440,97200,969
 130:main.c        **** 										  96672,96384,96096,95808,95520,95376,95232,95088,94944,94800,
 131:main.c        **** 										  94560,94320,94080,93840,93600,93432,93264,93096,92928,92760,
 132:main.c        **** 										  92592,92424,92256,92088,91920,91824,91728,91632,91536,91440,
 133:main.c        **** 										  91296,91152,91008,90864,90720,90672,90624,90576,90528,90480,
 134:main.c        **** 										  90384,90288,90192,90096,90000,89976,89952,89928,89904,89880,
 135:main.c        **** 										  89832,89784,89736,89688,89640,89568,89496,89424,89352,89280,
 136:main.c        **** 										  89232,89184,89136,89088,89040,88848,88656,88464,88272,88080,
 137:main.c        **** 										  87936,87792,87648,87504,87360,87168,86976,86784,86592,86400,
 138:main.c        **** 										  85680,84960,84240,83520,82800,80640,78480,76320,74160,72000};
 139:main.c        **** 
 140:main.c        **** uint8_t SoC_voltageTranslation(uint32_t voltage){
 141:main.c        **** 	uint8_t i = 0;
 142:main.c        **** 	
 143:main.c        **** 	/* Return the index once the value has been approximated. Index is analogous to percent DoD */
 144:main.c        **** 	while(voltage > voltage2SoC_Translation[i]){
 145:main.c        **** 		i++;
 146:main.c        **** 	}
 147:main.c        **** 	return 100-i;
 148:main.c        **** }
 149:main.c        **** 
 150:main.c        **** uint8_t SoC_calculation(uint32_t voltage, uint16_t coulombCount, uint16_t coulombsFull){
 151:main.c        **** 
 152:main.c        **** 	if(voltage < 86500 && voltage > 96000){
 153:main.c        **** 		uint8_t SoC = 0;
 154:main.c        **** 		
 155:main.c        **** 		/* Take the average between voltage translation and coulomb counting deterministic methods. */
 156:main.c        **** 		SoC = ((coulombsFull - coulombCount)/coulombsFull)*100;
 157:main.c        **** 		SoC = (SoC + SoC_voltageTranslation(voltage))/2;
 158:main.c        **** 		return SoC;
 159:main.c        **** 	}
 160:main.c        **** 	else{
 161:main.c        **** 		/* Return the coulomb count as the SoC. */
 162:main.c        **** 		return ((coulombsFull - coulombCount)/coulombsFull)*100;
 163:main.c        **** 	}
 164:main.c        **** }
 165:main.c        **** 
 166:main.c        **** void CMU_process_inbound_message(uint8_t rx_buf_address,CMU * cmu)
 167:main.c        **** {
 168:main.c        **** 	//potential for optimisation here
 169:main.c        ****     //combine 5 LSBs of SIDH(bits 26..21) and 3 MSBs of SIDL(bits 20..18) which is the CMU ID in th
 170:main.c        **** 	uint16_t CMU_ID = ( ((MCP2515_reg_read(rx_buf_address+1) & 0x3F)<<3)|
 171:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 172:main.c        ****     //message type is held in the 5 LSBs of EID0	
 173:main.c        **** 	uint8_t message_type = (MCP2515_reg_read(rx_buf_address+4) & 0x1F);
 174:main.c        **** 
 175:main.c        **** 	switch(message_type)
 176:main.c        **** 	{
 177:main.c        ****         // If we get a audit response message, we need to register this CMU
 178:main.c        **** 		case AUDIT_RESPONSE:
 179:main.c        **** 			// flash_LED(5,YELLOW_LED,10);
 180:main.c        **** 			switch(CMU_Register(cmu, CMU_ID))
 181:main.c        **** 			{
 182:main.c        **** 				case 0:
 183:main.c        **** 					break;	// No issues with registering.
 184:main.c        **** 				case 1:
 185:main.c        **** 					error_state(ERROR_DUPLICATE_CMU_ID);
 186:main.c        **** 					break;
 187:main.c        **** 				case 2:
 188:main.c        **** 					error_state(ERROR_NUMEROUS_CMU);
 189:main.c        **** 					break;
 190:main.c        **** 				default:
 191:main.c        **** 					break;
 192:main.c        **** 			}
 193:main.c        **** 			break;
 194:main.c        **** 		case TEMP1_ID:
 195:main.c        **** 			if(!CMU_Store_Data(cmu, CMU_ID, TEMP1_ID, rx_buf_address))
 196:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 197:main.c        **** 			break;
 198:main.c        **** 		case TEMP2_ID:
 199:main.c        **** 			if(!CMU_Store_Data(cmu, CMU_ID, message_type, rx_buf_address))
 200:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 201:main.c        **** 			break;
 202:main.c        **** 		case VOLT1_ID:
 203:main.c        **** 			if(!CMU_Store_Data(cmu, CMU_ID, message_type, rx_buf_address))
 204:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 205:main.c        **** 			break;
 206:main.c        **** 		case VOLT2_ID:
 207:main.c        **** 			if(!CMU_Store_Data(cmu, CMU_ID, message_type, rx_buf_address))
 208:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 209:main.c        **** 			break;
 210:main.c        **** 		default:
 211:main.c        **** 			break;
 212:main.c        **** 	} // This next section could be better off with the bit modify function.
 213:main.c        **** }
 214:main.c        **** 
 215:main.c        **** uint8_t CMU_send_audit_request()
 216:main.c        **** {
 217:main.c        **** 	//uint8_t data = 0x00;
 218:main.c        **** 	uint8_t free_buffer = MCP2515_findFreeTxBuffer(); //obtain a free transmit buffer.
 219:main.c        **** 
 220:main.c        **** 	if(free_buffer)
 221:main.c        **** 	{
 222:main.c        **** 		//flash_LED(1, YELLOW_LED, 50);
 223:main.c        ****         // Send a CAN packet from a free buffer, with recipient of our CMU ID, type audit request (
 224:main.c        **** 		// MCP2515_tx(AMU,free_buffer,DEVICE_ID,0x00,AUDIT_REQUEST,0,&data);		
 225:main.c        **** 		// MCP2515_TX(MCP2515_findFreeTxBuffer(), 0, &status, ((uint32_t)1<<27)|((uint32_t)DEVICE_ID<<18)
 226:main.c        **** 		return 1; //return successful
 227:main.c        **** 	}
 228:main.c        **** 	else
 229:main.c        **** 	{
 230:main.c        **** 		return 0; //return error, there were no free buffers.
 231:main.c        **** 	}
 232:main.c        **** }
 233:main.c        **** 
 234:main.c        **** void CMU_PollandProcess_RxBuffers(CMU * cmu)
 235:main.c        **** {
 236:main.c        **** 	
 237:main.c        **** 	//potential for optimisation here, using FILHIT bits.
 238:main.c        **** 	uint8_t status = (MCP2515_receive_status() & 3);		//poll to see if we have a message waiting.
 239:main.c        **** 	switch(status)
 240:main.c        **** 	{
 241:main.c        **** 		case 0:					//no message waiting (/VERY/ unlikely, as interrupt has said we have one.)
 242:main.c        **** 			break;
 243:main.c        **** 		case 1:					//rxb0 only has a message. (also /VERY/ unlikely)
 244:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB0, cmu);
 245:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);				//e.g if status is 0b00000001, it will only
 246:main.c        **** 			break;
 247:main.c        **** 		case 2:					//rxb1 only has a message
 248:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB1, cmu);
 249:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);
 250:main.c        **** 			break;
 251:main.c        **** 		case 3:					//both rxb0 and rxb1 have a message
 252:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB1, cmu);
 253:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB0, cmu);
 254:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);
 255:main.c        **** 			break;
 256:main.c        **** 		default:				//shouldn't occur, but treat as no messages waiting
 257:main.c        **** 			break;
 258:main.c        **** 	}
 259:main.c        **** 	
 260:main.c        **** }
 261:main.c        **** 
 262:main.c        **** uint8_t CMU_Check_Registration_Status(CMU * cmu)
 263:main.c        **** {
 264:main.c        **** 	uint8_t count;
 265:main.c        **** 	for(count = 0; count < CMU_COUNT; count++)							//look through all recorded CMUs, looking for emp
 266:main.c        **** 	{
 267:main.c        **** 
 268:main.c        **** 		if(cmu->CMU_ID == 0)break;										//if we find an empty CMU ID, finish the search.
 269:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 270:main.c        **** 	}
 271:main.c        **** 	if(count==CMU_COUNT)return 1;										//all required CMUs have completed initial registration.
 272:main.c        **** 	else if(CMURegistrationCount > CMU_COUNT)return 255;				//if there have been many device registrat
 273:main.c        **** 	else return 0;														//not all CMUs have registered.
 274:main.c        **** }
 275:main.c        **** void CMU_Wake()
 276:main.c        **** {
 277:main.c        **** 	CMURxPacketCount= 0;
 278:main.c        **** 	PORTC &= ~(1<<PINC1);
 279:main.c        **** 
 280:main.c        **** 	_delay_ms(1);
 281:main.c        **** 	PORTC |= (1<<PINC1);
 282:main.c        **** }
 283:main.c        **** void CMU_Wake_set()
 284:main.c        **** {
 285:main.c        **** 	CMURxPacketCount= 0;
 286:main.c        **** 	PORTC &= ~(1<<PINC1);
 287:main.c        **** }
 288:main.c        **** void CMU_Wake_reset()
 289:main.c        **** {
 290:main.c        **** 
 291:main.c        **** 	PORTC |= (1<<PINC1);
 292:main.c        **** }
 293:main.c        **** 
 294:main.c        **** 
 295:main.c        **** uint8_t CMU_Register(CMU * cmu, uint16_t CMU_ID)
 464               		.loc 1 295 9 is_stmt 1 view -0
 465               		.cfi_startproc
 466               		.loc 1 295 9 is_stmt 0 view .LVU124
 467 0000 1F93      		push r17
 468               	.LCFI6:
 469               		.cfi_def_cfa_offset 3
 470               		.cfi_offset 17, -2
 471 0002 CF93      		push r28
 472               	.LCFI7:
 473               		.cfi_def_cfa_offset 4
 474               		.cfi_offset 28, -3
 475 0004 DF93      		push r29
 476               	.LCFI8:
 477               		.cfi_def_cfa_offset 5
 478               		.cfi_offset 29, -4
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 3 */
 482               	.L__stack_usage = 3
 483 0006 EC01      		movw r28,r24
 484 0008 8C5B      		subi r24,-68
 485 000a 9F4F      		sbci r25,-1
 486               	.LVL25:
 487               	.L23:
 488               	.LBB77:
 296:main.c        **** {
 297:main.c        **** 	for(uint8_t count = 0; count < CMU_COUNT; count++)			//parsing through our cmu array, looking for 
 298:main.c        **** 	{
 299:main.c        **** 
 300:main.c        **** 		if(cmu->CMU_ID == 0)			//if the cmu element of the array has not been allocated, or if the cmu is
 489               		.loc 1 300 3 is_stmt 1 view .LVU125
 490               		.loc 1 300 9 is_stmt 0 view .LVU126
 491 000c 1981      		ldd r17,Y+1
 492               		.loc 1 300 5 view .LVU127
 493 000e 1111      		cpse r17,__zero_reg__
 494 0010 00C0      		rjmp .L33
 301:main.c        **** 		{
 302:main.c        **** 			if(!CMUAllRegistered)CMUAudit++;		//while it is in it's registration phase, increment the regist
 495               		.loc 1 302 4 is_stmt 1 view .LVU128
 496               		.loc 1 302 6 is_stmt 0 view .LVU129
 497 0012 8091 0000 		lds r24,CMUAllRegistered
 498 0016 8111      		cpse r24,__zero_reg__
 499 0018 00C0      		rjmp .L24
 500               		.loc 1 302 25 is_stmt 1 view .LVU130
 501               		.loc 1 302 33 is_stmt 0 view .LVU131
 502 001a 8091 0000 		lds r24,CMUAudit
 503 001e 8F5F      		subi r24,lo8(-(1))
 504 0020 8093 0000 		sts CMUAudit,r24
 505               	.L24:
 303:main.c        **** 			cmu->CMU_ID = CMU_ID;								//assign this element to the CMU that sent the reg request.
 506               		.loc 1 303 4 is_stmt 1 view .LVU132
 507               		.loc 1 303 16 is_stmt 0 view .LVU133
 508 0024 6983      		std Y+1,r22
 304:main.c        **** 
 305:main.c        **** 			while (!CMU_send_read_receipt(cmu));			//keep trying to send, until a tx buffer is free.
 509               		.loc 1 305 4 is_stmt 1 view .LVU134
 510               	.LVL26:
 511               	.L25:
 512               		.loc 1 305 39 view .LVU135
 513               		.loc 1 305 12 is_stmt 0 view .LVU136
 514 0026 CE01      		movw r24,r28
 515 0028 0E94 0000 		call CMU_send_read_receipt
 516               	.LVL27:
 517               		.loc 1 305 10 view .LVU137
 518 002c 8823      		tst r24
 519 002e 01F0      		breq .L25
 520               	.LVL28:
 521               	.L22:
 522               		.loc 1 305 10 view .LVU138
 523               	.LBE77:
 306:main.c        **** 			break;
 307:main.c        **** 		}
 308:main.c        **** 		else if(cmu->CMU_ID == CMU_ID)		//if this function encounters its own ID, it means there is a dup
 309:main.c        **** 		{
 310:main.c        **** 			return 1;			//return error.
 311:main.c        **** 		}
 312:main.c        **** 		cmu++;
 313:main.c        **** 		if(count == (CMU_COUNT-1))		//otherwise if all of the elements have already been allocated, we ha
 314:main.c        **** 		{
 315:main.c        **** 			return 2;		//return error
 316:main.c        **** 		}
 317:main.c        **** 	}
 318:main.c        **** 	return 0;
 319:main.c        **** 	
 320:main.c        **** }
 524               		.loc 1 320 1 view .LVU139
 525 0030 812F      		mov r24,r17
 526               	/* epilogue start */
 527 0032 DF91      		pop r29
 528 0034 CF91      		pop r28
 529 0036 1F91      		pop r17
 530 0038 0895      		ret
 531               	.LVL29:
 532               	.L33:
 533               	.LBB78:
 308:main.c        **** 		{
 534               		.loc 1 308 8 is_stmt 1 view .LVU140
 308:main.c        **** 		{
 535               		.loc 1 308 10 is_stmt 0 view .LVU141
 536 003a 1617      		cp r17,r22
 537 003c 1706      		cpc __zero_reg__,r23
 538 003e 01F0      		breq .L29
 312:main.c        **** 		if(count == (CMU_COUNT-1))		//otherwise if all of the elements have already been allocated, we ha
 539               		.loc 1 312 3 is_stmt 1 view .LVU142
 540               	.LVL30:
 313:main.c        **** 		{
 541               		.loc 1 313 3 view .LVU143
 313:main.c        **** 		{
 542               		.loc 1 313 5 is_stmt 0 view .LVU144
 543 0040 C817      		cp r28,r24
 544 0042 D907      		cpc r29,r25
 545 0044 01F0      		breq .L30
 312:main.c        **** 		if(count == (CMU_COUNT-1))		//otherwise if all of the elements have already been allocated, we ha
 546               		.loc 1 312 6 view .LVU145
 547 0046 A296      		adiw r28,34
 548               	.LVL31:
 312:main.c        **** 		if(count == (CMU_COUNT-1))		//otherwise if all of the elements have already been allocated, we ha
 549               		.loc 1 312 6 view .LVU146
 550 0048 00C0      		rjmp .L23
 551               	.L29:
 310:main.c        **** 		}
 552               		.loc 1 310 11 view .LVU147
 553 004a 11E0      		ldi r17,lo8(1)
 554 004c 00C0      		rjmp .L22
 555               	.LVL32:
 556               	.L30:
 315:main.c        **** 		}
 557               		.loc 1 315 11 view .LVU148
 558 004e 12E0      		ldi r17,lo8(2)
 559 0050 00C0      		rjmp .L22
 560               	.LBE78:
 561               		.cfi_endproc
 562               	.LFE41:
 564               		.section	.text.CoulombCount_init,"ax",@progbits
 565               	.global	CoulombCount_init
 567               	CoulombCount_init:
 568               	.LFB16:
 105:main.c        **** 	return AMU_eeprom_read(EEPROM_COULOMB_COUNT);
 569               		.loc 1 105 29 is_stmt 1 view -0
 570               		.cfi_startproc
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 106:main.c        **** }
 575               		.loc 1 106 2 view .LVU150
 106:main.c        **** }
 576               		.loc 1 106 9 is_stmt 0 view .LVU151
 577 0000 84E0      		ldi r24,lo8(4)
 578 0002 90E0      		ldi r25,0
 579 0004 0C94 0000 		jmp AMU_eeprom_read
 580               	.LVL33:
 581               		.cfi_endproc
 582               	.LFE16:
 584               		.section	.text.CoulombCount_instRead,"ax",@progbits
 585               	.global	CoulombCount_instRead
 587               	CoulombCount_instRead:
 588               	.LFB17:
 109:main.c        **** 	return ADC_read(ADC_HALL_EFFECT);
 589               		.loc 1 109 33 is_stmt 1 view -0
 590               		.cfi_startproc
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 593               	/* stack size = 0 */
 594               	.L__stack_usage = 0
 110:main.c        **** }
 595               		.loc 1 110 2 view .LVU153
 110:main.c        **** }
 596               		.loc 1 110 9 is_stmt 0 view .LVU154
 597 0000 80E0      		ldi r24,0
 598 0002 0C94 0000 		jmp ADC_read
 599               	.LVL34:
 600               		.cfi_endproc
 601               	.LFE17:
 603               		.section	.text.CoulombCount_updateAndRead,"ax",@progbits
 604               	.global	CoulombCount_updateAndRead
 606               	CoulombCount_updateAndRead:
 607               	.LVL35:
 608               	.LFB18:
 113:main.c        **** 	
 609               		.loc 1 113 59 is_stmt 1 view -0
 610               		.cfi_startproc
 113:main.c        **** 	
 611               		.loc 1 113 59 is_stmt 0 view .LVU156
 612 0000 CF93      		push r28
 613               	.LCFI9:
 614               		.cfi_def_cfa_offset 3
 615               		.cfi_offset 28, -2
 616 0002 DF93      		push r29
 617               	.LCFI10:
 618               		.cfi_def_cfa_offset 4
 619               		.cfi_offset 29, -3
 620               	/* prologue: function */
 621               	/* frame size = 0 */
 622               	/* stack size = 2 */
 623               	.L__stack_usage = 2
 624 0004 EC01      		movw r28,r24
 116:main.c        **** 	uint16_t ticks_diff = globalTicks - ticks;
 625               		.loc 1 116 2 is_stmt 1 view .LVU157
 117:main.c        **** 
 626               		.loc 1 117 2 view .LVU158
 117:main.c        **** 
 627               		.loc 1 117 36 is_stmt 0 view .LVU159
 628 0006 8091 0000 		lds r24,globalTicks
 629 000a 9091 0000 		lds r25,globalTicks+1
 630               	.LVL36:
 120:main.c        **** 
 631               		.loc 1 120 2 is_stmt 1 view .LVU160
 120:main.c        **** 
 632               		.loc 1 120 18 is_stmt 0 view .LVU161
 633 000e 0E94 0000 		call CoulombCount_instRead
 634               	.LVL37:
 120:main.c        **** 
 635               		.loc 1 120 41 view .LVU162
 636 0012 880F      		lsl r24
 637 0014 991F      		rol r25
 120:main.c        **** 
 638               		.loc 1 120 15 view .LVU163
 639 0016 C80F      		add r28,r24
 640 0018 D91F      		adc r29,r25
 641               	.LVL38:
 120:main.c        **** 
 642               		.loc 1 120 55 is_stmt 1 view .LVU164
 123:main.c        **** 	AMU_eeprom_write(EEPROM_COULOMB_COUNT, coulombCount);
 643               		.loc 1 123 2 view .LVU165
 123:main.c        **** 	AMU_eeprom_write(EEPROM_COULOMB_COUNT, coulombCount);
 644               		.loc 1 123 8 is_stmt 0 view .LVU166
 645 001a 8091 0000 		lds r24,globalTicks
 646 001e 9091 0000 		lds r25,globalTicks+1
 124:main.c        **** 	return coulombCount;
 647               		.loc 1 124 2 is_stmt 1 view .LVU167
 648 0022 BE01      		movw r22,r28
 649 0024 84E0      		ldi r24,lo8(4)
 650 0026 90E0      		ldi r25,0
 651 0028 0E94 0000 		call AMU_eeprom_write
 652               	.LVL39:
 125:main.c        **** }
 653               		.loc 1 125 2 view .LVU168
 126:main.c        **** 
 654               		.loc 1 126 1 is_stmt 0 view .LVU169
 655 002c CE01      		movw r24,r28
 656               	/* epilogue start */
 657 002e DF91      		pop r29
 658 0030 CF91      		pop r28
 659               	.LVL40:
 126:main.c        **** 
 660               		.loc 1 126 1 view .LVU170
 661 0032 0895      		ret
 662               		.cfi_endproc
 663               	.LFE18:
 665               		.section	.text.SoC_voltageTranslation,"ax",@progbits
 666               	.global	SoC_voltageTranslation
 668               	SoC_voltageTranslation:
 669               	.LVL41:
 670               	.LFB19:
 140:main.c        **** 	uint8_t i = 0;
 671               		.loc 1 140 49 is_stmt 1 view -0
 672               		.cfi_startproc
 140:main.c        **** 	uint8_t i = 0;
 673               		.loc 1 140 49 is_stmt 0 view .LVU172
 674 0000 0F93      		push r16
 675               	.LCFI11:
 676               		.cfi_def_cfa_offset 3
 677               		.cfi_offset 16, -2
 678 0002 1F93      		push r17
 679               	.LCFI12:
 680               		.cfi_def_cfa_offset 4
 681               		.cfi_offset 17, -3
 682               	/* prologue: function */
 683               	/* frame size = 0 */
 684               	/* stack size = 2 */
 685               	.L__stack_usage = 2
 141:main.c        **** 	
 686               		.loc 1 141 2 is_stmt 1 view .LVU173
 687               	.LVL42:
 144:main.c        **** 		i++;
 688               		.loc 1 144 2 view .LVU174
 141:main.c        **** 	
 689               		.loc 1 141 10 is_stmt 0 view .LVU175
 690 0004 40E0      		ldi r20,0
 691               	.LVL43:
 692               	.L38:
 144:main.c        **** 		i++;
 693               		.loc 1 144 41 view .LVU176
 694 0006 24E0      		ldi r18,lo8(4)
 695 0008 429F      		mul r20,r18
 696 000a F001      		movw r30,r0
 697 000c 1124      		clr __zero_reg__
 698 000e E050      		subi r30,lo8(-(voltage2SoC_Translation))
 699 0010 F040      		sbci r31,hi8(-(voltage2SoC_Translation))
 144:main.c        **** 		i++;
 700               		.loc 1 144 7 view .LVU177
 701 0012 0081      		ld r16,Z
 702 0014 1181      		ldd r17,Z+1
 703 0016 2281      		ldd r18,Z+2
 704 0018 3381      		ldd r19,Z+3
 705 001a 0617      		cp r16,r22
 706 001c 1707      		cpc r17,r23
 707 001e 2807      		cpc r18,r24
 708 0020 3907      		cpc r19,r25
 709 0022 00F0      		brlo .L39
 147:main.c        **** }
 710               		.loc 1 147 2 is_stmt 1 view .LVU178
 148:main.c        **** 
 711               		.loc 1 148 1 is_stmt 0 view .LVU179
 712 0024 84E6      		ldi r24,lo8(100)
 713 0026 841B      		sub r24,r20
 714               	/* epilogue start */
 715 0028 1F91      		pop r17
 716 002a 0F91      		pop r16
 717 002c 0895      		ret
 718               	.L39:
 145:main.c        **** 	}
 719               		.loc 1 145 3 is_stmt 1 view .LVU180
 145:main.c        **** 	}
 720               		.loc 1 145 4 is_stmt 0 view .LVU181
 721 002e 4F5F      		subi r20,lo8(-(1))
 722               	.LVL44:
 145:main.c        **** 	}
 723               		.loc 1 145 4 view .LVU182
 724 0030 00C0      		rjmp .L38
 725               		.cfi_endproc
 726               	.LFE19:
 728               		.section	.text.SoC_calculation,"ax",@progbits
 729               	.global	SoC_calculation
 731               	SoC_calculation:
 732               	.LVL45:
 733               	.LFB20:
 150:main.c        **** 
 734               		.loc 1 150 88 is_stmt 1 view -0
 735               		.cfi_startproc
 736               	/* prologue: function */
 737               	/* frame size = 0 */
 738               	/* stack size = 0 */
 739               	.L__stack_usage = 0
 152:main.c        **** 		uint8_t SoC = 0;
 740               		.loc 1 152 2 view .LVU184
 162:main.c        **** 	}
 741               		.loc 1 162 3 view .LVU185
 162:main.c        **** 	}
 742               		.loc 1 162 25 is_stmt 0 view .LVU186
 743 0000 C901      		movw r24,r18
 744 0002 841B      		sub r24,r20
 745 0004 950B      		sbc r25,r21
 162:main.c        **** 	}
 746               		.loc 1 162 40 view .LVU187
 747 0006 B901      		movw r22,r18
 748               	.LVL46:
 162:main.c        **** 	}
 749               		.loc 1 162 40 view .LVU188
 750 0008 0E94 0000 		call __udivmodhi4
 164:main.c        **** 
 751               		.loc 1 164 1 view .LVU189
 752 000c 84E6      		ldi r24,lo8(100)
 753 000e 869F      		mul r24,r22
 754 0010 802D      		mov r24,r0
 755 0012 1124      		clr r1
 756               	/* epilogue start */
 757 0014 0895      		ret
 758               		.cfi_endproc
 759               	.LFE20:
 761               		.section	.text.CMU_send_audit_request,"ax",@progbits
 762               	.global	CMU_send_audit_request
 764               	CMU_send_audit_request:
 765               	.LFB22:
 216:main.c        **** 	//uint8_t data = 0x00;
 766               		.loc 1 216 1 is_stmt 1 view -0
 767               		.cfi_startproc
 768               	/* prologue: function */
 769               	/* frame size = 0 */
 770               	/* stack size = 0 */
 771               	.L__stack_usage = 0
 218:main.c        **** 
 772               		.loc 1 218 2 view .LVU191
 218:main.c        **** 
 773               		.loc 1 218 24 is_stmt 0 view .LVU192
 774 0000 0E94 0000 		call MCP2515_findFreeTxBuffer
 775               	.LVL47:
 220:main.c        **** 	{
 776               		.loc 1 220 2 is_stmt 1 view .LVU193
 220:main.c        **** 	{
 777               		.loc 1 220 4 is_stmt 0 view .LVU194
 778 0004 91E0      		ldi r25,lo8(1)
 779 0006 8111      		cpse r24,__zero_reg__
 780 0008 00C0      		rjmp .L42
 781 000a 90E0      		ldi r25,0
 782               	.L42:
 232:main.c        **** 
 783               		.loc 1 232 1 view .LVU195
 784 000c 892F      		mov r24,r25
 785               	.LVL48:
 786               	/* epilogue start */
 232:main.c        **** 
 787               		.loc 1 232 1 view .LVU196
 788 000e 0895      		ret
 789               		.cfi_endproc
 790               	.LFE22:
 792               		.section	.text.CMU_Check_Registration_Status,"ax",@progbits
 793               	.global	CMU_Check_Registration_Status
 795               	CMU_Check_Registration_Status:
 796               	.LVL49:
 797               	.LFB24:
 263:main.c        **** 	uint8_t count;
 798               		.loc 1 263 1 is_stmt 1 view -0
 799               		.cfi_startproc
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 0 */
 803               	.L__stack_usage = 0
 264:main.c        **** 	for(count = 0; count < CMU_COUNT; count++)							//look through all recorded CMUs, looking for emp
 804               		.loc 1 264 2 view .LVU198
 265:main.c        **** 	{
 805               		.loc 1 265 2 view .LVU199
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 806               		.loc 1 268 3 view .LVU200
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 807               		.loc 1 268 5 is_stmt 0 view .LVU201
 808 0000 FC01      		movw r30,r24
 809 0002 2181      		ldd r18,Z+1
 810 0004 2223      		tst r18
 811 0006 01F0      		breq .L44
 269:main.c        **** 	}
 812               		.loc 1 269 3 is_stmt 1 view .LVU202
 813               	.LVL50:
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 814               		.loc 1 268 3 view .LVU203
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 815               		.loc 1 268 5 is_stmt 0 view .LVU204
 816 0008 23A1      		ldd r18,Z+35
 817 000a 2223      		tst r18
 818 000c 01F0      		breq .L44
 269:main.c        **** 	}
 819               		.loc 1 269 3 is_stmt 1 view .LVU205
 820               	.LVL51:
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 821               		.loc 1 268 3 view .LVU206
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 822               		.loc 1 268 9 is_stmt 0 view .LVU207
 823 000e 8C5B      		subi r24,-68
 824 0010 9F4F      		sbci r25,-1
 825               	.LVL52:
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 826               		.loc 1 268 5 view .LVU208
 827 0012 FC01      		movw r30,r24
 828               	.LVL53:
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 829               		.loc 1 268 5 view .LVU209
 830 0014 8181      		ldd r24,Z+1
 831               	.LVL54:
 268:main.c        **** 		cmu++;															//increment the element of the array we are looking at.
 832               		.loc 1 268 5 view .LVU210
 833 0016 8823      		tst r24
 834 0018 01F0      		breq .L44
 271:main.c        **** 	else if(CMURegistrationCount > CMU_COUNT)return 255;				//if there have been many device registrat
 835               		.loc 1 271 29 view .LVU211
 836 001a 81E0      		ldi r24,lo8(1)
 837 001c 0895      		ret
 838               	.LVL55:
 839               	.L44:
 271:main.c        **** 	else if(CMURegistrationCount > CMU_COUNT)return 255;				//if there have been many device registrat
 840               		.loc 1 271 2 is_stmt 1 view .LVU212
 272:main.c        **** 	else return 0;														//not all CMUs have registered.
 841               		.loc 1 272 7 view .LVU213
 272:main.c        **** 	else return 0;														//not all CMUs have registered.
 842               		.loc 1 272 9 is_stmt 0 view .LVU214
 843 001e 81E0      		ldi r24,lo8(1)
 844 0020 9091 0000 		lds r25,CMURegistrationCount
 845 0024 9430      		cpi r25,lo8(4)
 846 0026 00F4      		brsh .L45
 847 0028 80E0      		ldi r24,0
 848               	.L45:
 849 002a 8195      		neg r24
 850               	/* epilogue start */
 274:main.c        **** void CMU_Wake()
 851               		.loc 1 274 1 view .LVU215
 852 002c 0895      		ret
 853               		.cfi_endproc
 854               	.LFE24:
 856               		.section	.text.CMU_Wake,"ax",@progbits
 857               	.global	CMU_Wake
 859               	CMU_Wake:
 860               	.LFB25:
 276:main.c        **** 	CMURxPacketCount= 0;
 861               		.loc 1 276 1 is_stmt 1 view -0
 862               		.cfi_startproc
 863               	/* prologue: function */
 864               	/* frame size = 0 */
 865               	/* stack size = 0 */
 866               	.L__stack_usage = 0
 277:main.c        **** 	PORTC &= ~(1<<PINC1);
 867               		.loc 1 277 2 view .LVU217
 277:main.c        **** 	PORTC &= ~(1<<PINC1);
 868               		.loc 1 277 18 is_stmt 0 view .LVU218
 869 0000 1092 0000 		sts CMURxPacketCount,__zero_reg__
 278:main.c        **** 
 870               		.loc 1 278 2 is_stmt 1 view .LVU219
 278:main.c        **** 
 871               		.loc 1 278 8 is_stmt 0 view .LVU220
 872 0004 4198      		cbi 0x8,1
 280:main.c        **** 	PORTC |= (1<<PINC1);
 873               		.loc 1 280 2 is_stmt 1 view .LVU221
 874               	.LVL56:
 875               	.LBB79:
 876               	.LBI79:
 877               		.file 2 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 878               		.loc 2 166 1 view .LVU222
 879               	.LBB80:
 167:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
 880               		.loc 2 168 2 view .LVU223
 169:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 881               		.loc 2 172 2 view .LVU224
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 882               		.loc 2 173 2 view .LVU225
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 883               		.loc 2 174 2 view .LVU226
 175:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 884               		.loc 2 184 3 view .LVU227
 185:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 885               		.loc 2 187 2 view .LVU228
 886 0006 8FE9      		ldi r24,lo8(3999)
 887 0008 9FE0      		ldi r25,hi8(3999)
 888 000a 0197      	1:	sbiw r24,1
 889 000c 01F4      		brne 1b
 890 000e 00C0      		rjmp .
 891 0010 0000      		nop
 892               	.LVL57:
 893               		.loc 2 187 2 is_stmt 0 view .LVU229
 894               	.LBE80:
 895               	.LBE79:
 281:main.c        **** }
 896               		.loc 1 281 2 is_stmt 1 view .LVU230
 281:main.c        **** }
 897               		.loc 1 281 8 is_stmt 0 view .LVU231
 898 0012 419A      		sbi 0x8,1
 899               	/* epilogue start */
 282:main.c        **** void CMU_Wake_set()
 900               		.loc 1 282 1 view .LVU232
 901 0014 0895      		ret
 902               		.cfi_endproc
 903               	.LFE25:
 905               		.section	.text.CMU_Wake_set,"ax",@progbits
 906               	.global	CMU_Wake_set
 908               	CMU_Wake_set:
 909               	.LFB26:
 284:main.c        **** 	CMURxPacketCount= 0;
 910               		.loc 1 284 1 is_stmt 1 view -0
 911               		.cfi_startproc
 912               	/* prologue: function */
 913               	/* frame size = 0 */
 914               	/* stack size = 0 */
 915               	.L__stack_usage = 0
 285:main.c        **** 	PORTC &= ~(1<<PINC1);
 916               		.loc 1 285 2 view .LVU234
 285:main.c        **** 	PORTC &= ~(1<<PINC1);
 917               		.loc 1 285 18 is_stmt 0 view .LVU235
 918 0000 1092 0000 		sts CMURxPacketCount,__zero_reg__
 286:main.c        **** }
 919               		.loc 1 286 2 is_stmt 1 view .LVU236
 286:main.c        **** }
 920               		.loc 1 286 8 is_stmt 0 view .LVU237
 921 0004 4198      		cbi 0x8,1
 922               	/* epilogue start */
 287:main.c        **** void CMU_Wake_reset()
 923               		.loc 1 287 1 view .LVU238
 924 0006 0895      		ret
 925               		.cfi_endproc
 926               	.LFE26:
 928               		.section	.text.CMU_Wake_reset,"ax",@progbits
 929               	.global	CMU_Wake_reset
 931               	CMU_Wake_reset:
 932               	.LFB27:
 289:main.c        **** 
 933               		.loc 1 289 1 is_stmt 1 view -0
 934               		.cfi_startproc
 935               	/* prologue: function */
 936               	/* frame size = 0 */
 937               	/* stack size = 0 */
 938               	.L__stack_usage = 0
 291:main.c        **** }
 939               		.loc 1 291 2 view .LVU240
 291:main.c        **** }
 940               		.loc 1 291 8 is_stmt 0 view .LVU241
 941 0000 419A      		sbi 0x8,1
 942               	/* epilogue start */
 292:main.c        **** 
 943               		.loc 1 292 1 view .LVU242
 944 0002 0895      		ret
 945               		.cfi_endproc
 946               	.LFE27:
 948               		.section	.text.CMU_Register,"ax",@progbits
 949               	.global	CMU_Register
 951               	CMU_Register:
 952               	.LVL58:
 953               	.LFB28:
 296:main.c        **** 	for(uint8_t count = 0; count < CMU_COUNT; count++)			//parsing through our cmu array, looking for 
 954               		.loc 1 296 1 is_stmt 1 view -0
 955               		.cfi_startproc
 956               	/* prologue: function */
 957               	/* frame size = 0 */
 958               	/* stack size = 0 */
 959               	.L__stack_usage = 0
 297:main.c        **** 	{
 960               		.loc 1 297 2 view .LVU244
 297:main.c        **** 	{
 961               		.loc 1 297 6 view .LVU245
 297:main.c        **** 	{
 962               		.loc 1 297 6 is_stmt 0 view .LVU246
 963 0000 0C94 0000 		jmp CMU_Register.part.0
 964               	.LVL59:
 297:main.c        **** 	{
 965               		.loc 1 297 6 view .LVU247
 966               		.cfi_endproc
 967               	.LFE28:
 969               		.section	.text.CMU_Store_Data,"ax",@progbits
 970               	.global	CMU_Store_Data
 972               	CMU_Store_Data:
 973               	.LVL60:
 974               	.LFB29:
 321:main.c        **** 
 322:main.c        **** uint8_t CMU_Store_Data(CMU * cmu, uint8_t CMU_ID, uint8_t message_type2, uint8_t address)
 323:main.c        **** {
 975               		.loc 1 323 1 is_stmt 1 view -0
 976               		.cfi_startproc
 977               		.loc 1 323 1 is_stmt 0 view .LVU249
 978 0000 CF92      		push r12
 979               	.LCFI13:
 980               		.cfi_def_cfa_offset 3
 981               		.cfi_offset 12, -2
 982 0002 DF92      		push r13
 983               	.LCFI14:
 984               		.cfi_def_cfa_offset 4
 985               		.cfi_offset 13, -3
 986 0004 EF92      		push r14
 987               	.LCFI15:
 988               		.cfi_def_cfa_offset 5
 989               		.cfi_offset 14, -4
 990 0006 FF92      		push r15
 991               	.LCFI16:
 992               		.cfi_def_cfa_offset 6
 993               		.cfi_offset 15, -5
 994 0008 0F93      		push r16
 995               	.LCFI17:
 996               		.cfi_def_cfa_offset 7
 997               		.cfi_offset 16, -6
 998 000a 1F93      		push r17
 999               	.LCFI18:
 1000               		.cfi_def_cfa_offset 8
 1001               		.cfi_offset 17, -7
 1002 000c CF93      		push r28
 1003               	.LCFI19:
 1004               		.cfi_def_cfa_offset 9
 1005               		.cfi_offset 28, -8
 1006 000e DF93      		push r29
 1007               	.LCFI20:
 1008               		.cfi_def_cfa_offset 10
 1009               		.cfi_offset 29, -9
 1010 0010 CDB7      		in r28,__SP_L__
 1011 0012 DEB7      		in r29,__SP_H__
 1012               	.LCFI21:
 1013               		.cfi_def_cfa_register 28
 1014 0014 2897      		sbiw r28,8
 1015               	.LCFI22:
 1016               		.cfi_def_cfa_offset 18
 1017 0016 0FB6      		in __tmp_reg__,__SREG__
 1018 0018 F894      		cli
 1019 001a DEBF      		out __SP_H__,r29
 1020 001c 0FBE      		out __SREG__,__tmp_reg__
 1021 001e CDBF      		out __SP_L__,r28
 1022               	/* prologue: function */
 1023               	/* frame size = 8 */
 1024               	/* stack size = 16 */
 1025               	.L__stack_usage = 16
 1026 0020 8C01      		movw r16,r24
 1027 0022 E62E      		mov r14,r22
 1028 0024 F42E      		mov r15,r20
 324:main.c        **** 	uint8_t found = 0;
 1029               		.loc 1 324 2 is_stmt 1 view .LVU250
 1030               	.LVL61:
 325:main.c        **** 	uint8_t data[8];											//make a bucket for our data.
 1031               		.loc 1 325 2 view .LVU251
 326:main.c        **** 	CMU * cmu2 = cmu;
 1032               		.loc 1 326 2 view .LVU252
 327:main.c        **** 	cmu2++;
 1033               		.loc 1 327 2 view .LVU253
 328:main.c        **** 	
 329:main.c        **** 	//this function takes a pointer of a suitably sized array for the first address of the data we wil
 330:main.c        **** 	MCP2515_RxBufferRead(data, address+6);						//collect our data, using the rx read buffer instructi
 1034               		.loc 1 330 2 view .LVU254
 1035 0026 66E0      		ldi r22,lo8(6)
 1036               	.LVL62:
 1037               		.loc 1 330 2 is_stmt 0 view .LVU255
 1038 0028 620F      		add r22,r18
 1039 002a CE01      		movw r24,r28
 1040               	.LVL63:
 1041               		.loc 1 330 2 view .LVU256
 1042 002c 0196      		adiw r24,1
 1043 002e 0E94 0000 		call MCP2515_RxBufferRead
 1044               	.LVL64:
 331:main.c        **** 	//interrupt for given RX buffer will now be cleared, by previous function.
 332:main.c        **** 
 333:main.c        **** 	for(uint8_t counter = 0; counter < CMU_COUNT; counter++)	//move through the cells, looking for a m
 1045               		.loc 1 333 2 is_stmt 1 view .LVU257
 1046               	.LBB81:
 1047               		.loc 1 333 6 view .LVU258
 334:main.c        **** 	{
 335:main.c        **** 		//_delay_ms(2);
 336:main.c        **** 
 337:main.c        **** 		
 338:main.c        **** 		if(cmu->CMU_ID == CMU_ID)				//if cmu is the one we are looking for,
 339:main.c        **** 		{
 340:main.c        **** 			found = 1;
 341:main.c        **** 			switch(message_type2)				//depending on the message type
 342:main.c        **** 			{
 343:main.c        **** 				case TEMP1_ID:							//if it was the first TEMPERATURE packet,
 344:main.c        **** 					
 345:main.c        **** 					cmu->temperatures[0]=data[0]<<8;	//data 0 will hold the 8 MSBs of temp cell 0
 346:main.c        **** 					cmu->temperatures[0]|=data[1];		//data 1 will hold the 8 LSBs of temp cell 0
 347:main.c        **** 					cmu->temperatures[1]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 1
 348:main.c        **** 					cmu->temperatures[1]|=data[3];		//and so on...
 349:main.c        **** 					cmu->temperatures[2]=data[4]<<8;
 350:main.c        **** 					cmu->temperatures[2]|=data[5];
 351:main.c        **** 					cmu->temperatures[3]=data[6]<<8;
 352:main.c        **** 					cmu->temperatures[3]|=data[7];
 353:main.c        **** 					CMU_data_count++;
 354:main.c        **** 					
 355:main.c        **** 					break;
 356:main.c        **** 				case VOLT1_ID:							//if it was the first VOLTAGE packet,
 357:main.c        **** 					
 358:main.c        **** 					cmu->voltages[0]=data[0]<<8;		//data 0 will hold the 8 MSBs of voltages cell 0
 359:main.c        **** 					cmu->voltages[0]|=data[1];			//data 1 will hold the 8 LSBs of voltages cell 0
 360:main.c        **** 					cmu->voltages[1]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 361:main.c        **** 					cmu->voltages[1]|=data[3];			//and so on...
 362:main.c        **** 					cmu->voltages[2]=data[4]<<8;
 363:main.c        **** 					cmu->voltages[2]|=data[5];
 364:main.c        **** 					cmu->voltages[3]=data[6]<<8;
 365:main.c        **** 					cmu->voltages[3]|=data[7];
 366:main.c        **** 					
 367:main.c        **** 					CMU_data_count++;
 368:main.c        **** 					break;
 369:main.c        **** 				case TEMP2_ID:							//if it was the second TEMPERATURE packet,
 370:main.c        **** 				
 371:main.c        **** 					cmu->temperatures[4]=data[0]<<8;	//data 0 will hold the 8 MSBs of temp cell 4
 1048               		.loc 1 371 31 is_stmt 0 view .LVU259
 1049 0032 8981      		ldd r24,Y+1
 372:main.c        **** 					cmu->temperatures[4]|=data[1];		//data 1 will hold the 8 LSBs of temp cell 4
 1050               		.loc 1 372 32 view .LVU260
 1051 0034 2A81      		ldd r18,Y+2
 1052               		.loc 1 372 26 view .LVU261
 1053 0036 382F      		mov r19,r24
 373:main.c        **** 					cmu->temperatures[5]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 5
 1054               		.loc 1 373 31 view .LVU262
 1055 0038 8B81      		ldd r24,Y+3
 374:main.c        **** 					cmu->temperatures[5]|=data[3];		//and so on...
 1056               		.loc 1 374 32 view .LVU263
 1057 003a 4C81      		ldd r20,Y+4
 1058               		.loc 1 374 26 view .LVU264
 1059 003c 582F      		mov r21,r24
 375:main.c        **** 					cmu->temperatures[6]=data[4]<<8;
 1060               		.loc 1 375 31 view .LVU265
 1061 003e 8D81      		ldd r24,Y+5
 376:main.c        **** 					cmu->temperatures[6]|=data[5];
 1062               		.loc 1 376 32 view .LVU266
 1063 0040 6E81      		ldd r22,Y+6
 1064               		.loc 1 376 26 view .LVU267
 1065 0042 782F      		mov r23,r24
 377:main.c        **** 					cmu->temperatures[7]=data[6]<<8;
 1066               		.loc 1 377 31 view .LVU268
 1067 0044 8F81      		ldd r24,Y+7
 378:main.c        **** 					cmu->temperatures[7]|=data[7];
 1068               		.loc 1 378 32 view .LVU269
 1069 0046 E885      		ldd r30,Y+8
 1070               		.loc 1 378 26 view .LVU270
 1071 0048 F82F      		mov r31,r24
 1072 004a 6801      		movw r12,r16
 1073 004c 86E6      		ldi r24,102
 1074 004e C80E      		add r12,r24
 1075 0050 D11C      		adc r13,__zero_reg__
 1076               	.LBE81:
 324:main.c        **** 	uint8_t data[8];											//make a bucket for our data.
 1077               		.loc 1 324 10 view .LVU271
 1078 0052 80E0      		ldi r24,0
 1079               	.LVL65:
 1080               	.L67:
 1081               	.LBB82:
 338:main.c        **** 		{
 1082               		.loc 1 338 3 is_stmt 1 view .LVU272
 338:main.c        **** 		{
 1083               		.loc 1 338 5 is_stmt 0 view .LVU273
 1084 0054 D801      		movw r26,r16
 1085 0056 1196      		adiw r26,1
 1086 0058 9C91      		ld r25,X
 1087 005a 9E11      		cpse r25,r14
 1088 005c 00C0      		rjmp .L61
 340:main.c        **** 			switch(message_type2)				//depending on the message type
 1089               		.loc 1 340 4 is_stmt 1 view .LVU274
 1090               	.LVL66:
 341:main.c        **** 			{
 1091               		.loc 1 341 4 view .LVU275
 1092 005e B2E0      		ldi r27,lo8(2)
 1093 0060 FB16      		cp r15,r27
 1094 0062 01F4      		brne .+2
 1095 0064 00C0      		rjmp .L62
 1096 0066 BF15      		cp r27,r15
 1097 0068 00F0      		brlo .L63
 1098 006a 81E0      		ldi r24,lo8(1)
 1099 006c F816      		cp r15,r24
 1100 006e 01F0      		breq .L64
 1101               	.LVL67:
 1102               	.L61:
 379:main.c        **** 					
 380:main.c        **** 					CMU_data_count++;
 381:main.c        **** 					//LED_on(YELLOW_LED);
 382:main.c        **** 					break;
 383:main.c        **** 				case VOLT2_ID:							//if it was the second VOLTAGE packet,
 384:main.c        **** 					cmu->voltages[4]=data[0]<<8;		//data 0 will hold the 8 MSBs of voltages cell 0
 385:main.c        **** 					cmu->voltages[4]|=data[1];			//data 1 will hold the 8 LSBs of voltages cell 0
 386:main.c        **** 					cmu->voltages[5]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 387:main.c        **** 					cmu->voltages[5]|=data[3];			//and so on...
 388:main.c        **** 					cmu->voltages[6]=data[4]<<8;
 389:main.c        **** 					cmu->voltages[6]|=data[5];
 390:main.c        **** 					cmu->voltages[7]=data[6]<<8;
 391:main.c        **** 					cmu->voltages[7]|=data[7];
 392:main.c        **** 					
 393:main.c        **** 					CMU_data_count++;
 394:main.c        **** 					break;
 395:main.c        **** 				default:
 396:main.c        **** 				
 397:main.c        **** 					break;
 398:main.c        **** 			}
 399:main.c        **** 		
 400:main.c        **** 		}
 401:main.c        **** 		cmu++; //if this cmu was not a match, check the next one.
 1103               		.loc 1 401 3 discriminator 2 view .LVU276
 1104               		.loc 1 401 6 is_stmt 0 discriminator 2 view .LVU277
 1105 0070 0E5D      		subi r16,-34
 1106 0072 1F4F      		sbci r17,-1
 1107               	.LVL68:
 333:main.c        **** 	{
 1108               		.loc 1 333 2 discriminator 2 view .LVU278
 1109 0074 C016      		cp r12,r16
 1110 0076 D106      		cpc r13,r17
 1111 0078 01F4      		brne .L67
 1112               	/* epilogue start */
 1113               	.LBE82:
 402:main.c        **** 	}
 403:main.c        **** 	if (!found) return 0; //if we went through the entire cell database and couldn't find the cell ID,
 404:main.c        **** 	else return 1; //otherwise all ok.
 405:main.c        **** 	return 1;
 406:main.c        **** }
 1114               		.loc 1 406 1 view .LVU279
 1115 007a 2896      		adiw r28,8
 1116 007c 0FB6      		in __tmp_reg__,__SREG__
 1117 007e F894      		cli
 1118 0080 DEBF      		out __SP_H__,r29
 1119 0082 0FBE      		out __SREG__,__tmp_reg__
 1120 0084 CDBF      		out __SP_L__,r28
 1121 0086 DF91      		pop r29
 1122 0088 CF91      		pop r28
 1123 008a 1F91      		pop r17
 1124 008c 0F91      		pop r16
 1125               	.LVL69:
 1126               		.loc 1 406 1 view .LVU280
 1127 008e FF90      		pop r15
 1128               	.LVL70:
 1129               		.loc 1 406 1 view .LVU281
 1130 0090 EF90      		pop r14
 1131               	.LVL71:
 1132               		.loc 1 406 1 view .LVU282
 1133 0092 DF90      		pop r13
 1134 0094 CF90      		pop r12
 1135               	.LVL72:
 1136               		.loc 1 406 1 view .LVU283
 1137 0096 0895      		ret
 1138               	.LVL73:
 1139               	.L63:
 1140               		.loc 1 406 1 view .LVU284
 1141 0098 A4E0      		ldi r26,lo8(4)
 1142 009a FA16      		cp r15,r26
 1143 009c 01F0      		breq .L65
 1144 009e B5E0      		ldi r27,lo8(5)
 1145 00a0 FB16      		cp r15,r27
 1146 00a2 01F0      		breq .L66
 1147               	.L69:
 1148               	.LBB83:
 394:main.c        **** 				default:
 1149               		.loc 1 394 6 is_stmt 1 view .LVU285
 340:main.c        **** 			switch(message_type2)				//depending on the message type
 1150               		.loc 1 340 10 is_stmt 0 view .LVU286
 1151 00a4 81E0      		ldi r24,lo8(1)
 394:main.c        **** 				default:
 1152               		.loc 1 394 6 view .LVU287
 1153 00a6 00C0      		rjmp .L61
 1154               	.L65:
 345:main.c        **** 					cmu->temperatures[0]|=data[1];		//data 1 will hold the 8 LSBs of temp cell 0
 1155               		.loc 1 345 6 is_stmt 1 view .LVU288
 346:main.c        **** 					cmu->temperatures[1]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 1
 1156               		.loc 1 346 6 view .LVU289
 346:main.c        **** 					cmu->temperatures[1]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 1
 1157               		.loc 1 346 26 is_stmt 0 view .LVU290
 1158 00a8 D801      		movw r26,r16
 1159 00aa 5396      		adiw r26,18+1
 1160 00ac 3C93      		st X,r19
 1161 00ae 2E93      		st -X,r18
 1162 00b0 5297      		sbiw r26,18
 347:main.c        **** 					cmu->temperatures[1]|=data[3];		//and so on...
 1163               		.loc 1 347 6 is_stmt 1 view .LVU291
 348:main.c        **** 					cmu->temperatures[2]=data[4]<<8;
 1164               		.loc 1 348 6 view .LVU292
 348:main.c        **** 					cmu->temperatures[2]=data[4]<<8;
 1165               		.loc 1 348 26 is_stmt 0 view .LVU293
 1166 00b2 5596      		adiw r26,20+1
 1167 00b4 5C93      		st X,r21
 1168 00b6 4E93      		st -X,r20
 1169 00b8 5497      		sbiw r26,20
 349:main.c        **** 					cmu->temperatures[2]|=data[5];
 1170               		.loc 1 349 6 is_stmt 1 view .LVU294
 350:main.c        **** 					cmu->temperatures[3]=data[6]<<8;
 1171               		.loc 1 350 6 view .LVU295
 350:main.c        **** 					cmu->temperatures[3]=data[6]<<8;
 1172               		.loc 1 350 26 is_stmt 0 view .LVU296
 1173 00ba 5796      		adiw r26,22+1
 1174 00bc 7C93      		st X,r23
 1175 00be 6E93      		st -X,r22
 1176 00c0 5697      		sbiw r26,22
 351:main.c        **** 					cmu->temperatures[3]|=data[7];
 1177               		.loc 1 351 6 is_stmt 1 view .LVU297
 352:main.c        **** 					CMU_data_count++;
 1178               		.loc 1 352 6 view .LVU298
 352:main.c        **** 					CMU_data_count++;
 1179               		.loc 1 352 26 is_stmt 0 view .LVU299
 1180 00c2 5996      		adiw r26,24+1
 1181 00c4 FC93      		st X,r31
 1182 00c6 EE93      		st -X,r30
 1183 00c8 5897      		sbiw r26,24
 353:main.c        **** 					
 1184               		.loc 1 353 6 is_stmt 1 view .LVU300
 1185               	.L70:
 393:main.c        **** 					break;
 1186               		.loc 1 393 6 view .LVU301
 393:main.c        **** 					break;
 1187               		.loc 1 393 20 is_stmt 0 view .LVU302
 1188 00ca 8091 0000 		lds r24,CMU_data_count
 1189 00ce 8F5F      		subi r24,lo8(-(1))
 1190 00d0 8093 0000 		sts CMU_data_count,r24
 1191 00d4 00C0      		rjmp .L69
 1192               	.L64:
 358:main.c        **** 					cmu->voltages[0]|=data[1];			//data 1 will hold the 8 LSBs of voltages cell 0
 1193               		.loc 1 358 6 is_stmt 1 view .LVU303
 359:main.c        **** 					cmu->voltages[1]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 1194               		.loc 1 359 6 view .LVU304
 359:main.c        **** 					cmu->voltages[1]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 1195               		.loc 1 359 22 is_stmt 0 view .LVU305
 1196 00d6 D801      		movw r26,r16
 1197 00d8 1396      		adiw r26,2+1
 1198 00da 3C93      		st X,r19
 1199 00dc 2E93      		st -X,r18
 1200 00de 1297      		sbiw r26,2
 360:main.c        **** 					cmu->voltages[1]|=data[3];			//and so on...
 1201               		.loc 1 360 6 is_stmt 1 view .LVU306
 361:main.c        **** 					cmu->voltages[2]=data[4]<<8;
 1202               		.loc 1 361 6 view .LVU307
 361:main.c        **** 					cmu->voltages[2]=data[4]<<8;
 1203               		.loc 1 361 22 is_stmt 0 view .LVU308
 1204 00e0 1596      		adiw r26,4+1
 1205 00e2 5C93      		st X,r21
 1206 00e4 4E93      		st -X,r20
 1207 00e6 1497      		sbiw r26,4
 362:main.c        **** 					cmu->voltages[2]|=data[5];
 1208               		.loc 1 362 6 is_stmt 1 view .LVU309
 363:main.c        **** 					cmu->voltages[3]=data[6]<<8;
 1209               		.loc 1 363 6 view .LVU310
 363:main.c        **** 					cmu->voltages[3]=data[6]<<8;
 1210               		.loc 1 363 22 is_stmt 0 view .LVU311
 1211 00e8 1796      		adiw r26,6+1
 1212 00ea 7C93      		st X,r23
 1213 00ec 6E93      		st -X,r22
 1214 00ee 1697      		sbiw r26,6
 364:main.c        **** 					cmu->voltages[3]|=data[7];
 1215               		.loc 1 364 6 is_stmt 1 view .LVU312
 365:main.c        **** 					
 1216               		.loc 1 365 6 view .LVU313
 365:main.c        **** 					
 1217               		.loc 1 365 22 is_stmt 0 view .LVU314
 1218 00f0 1996      		adiw r26,8+1
 1219 00f2 FC93      		st X,r31
 1220 00f4 EE93      		st -X,r30
 1221 00f6 1897      		sbiw r26,8
 367:main.c        **** 					break;
 1222               		.loc 1 367 6 is_stmt 1 view .LVU315
 1223 00f8 00C0      		rjmp .L70
 1224               	.L66:
 371:main.c        **** 					cmu->temperatures[4]|=data[1];		//data 1 will hold the 8 LSBs of temp cell 4
 1225               		.loc 1 371 6 view .LVU316
 372:main.c        **** 					cmu->temperatures[5]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 5
 1226               		.loc 1 372 6 view .LVU317
 372:main.c        **** 					cmu->temperatures[5]=data[2]<<8;	//data 2 will hold the 8 MSBs of temp cell 5
 1227               		.loc 1 372 26 is_stmt 0 view .LVU318
 1228 00fa D801      		movw r26,r16
 1229 00fc 5B96      		adiw r26,26+1
 1230 00fe 3C93      		st X,r19
 1231 0100 2E93      		st -X,r18
 1232 0102 5A97      		sbiw r26,26
 373:main.c        **** 					cmu->temperatures[5]|=data[3];		//and so on...
 1233               		.loc 1 373 6 is_stmt 1 view .LVU319
 374:main.c        **** 					cmu->temperatures[6]=data[4]<<8;
 1234               		.loc 1 374 6 view .LVU320
 374:main.c        **** 					cmu->temperatures[6]=data[4]<<8;
 1235               		.loc 1 374 26 is_stmt 0 view .LVU321
 1236 0104 5D96      		adiw r26,28+1
 1237 0106 5C93      		st X,r21
 1238 0108 4E93      		st -X,r20
 1239 010a 5C97      		sbiw r26,28
 375:main.c        **** 					cmu->temperatures[6]|=data[5];
 1240               		.loc 1 375 6 is_stmt 1 view .LVU322
 376:main.c        **** 					cmu->temperatures[7]=data[6]<<8;
 1241               		.loc 1 376 6 view .LVU323
 376:main.c        **** 					cmu->temperatures[7]=data[6]<<8;
 1242               		.loc 1 376 26 is_stmt 0 view .LVU324
 1243 010c 5F96      		adiw r26,30+1
 1244 010e 7C93      		st X,r23
 1245 0110 6E93      		st -X,r22
 1246 0112 5E97      		sbiw r26,30
 377:main.c        **** 					cmu->temperatures[7]|=data[7];
 1247               		.loc 1 377 6 is_stmt 1 view .LVU325
 378:main.c        **** 					
 1248               		.loc 1 378 6 view .LVU326
 378:main.c        **** 					
 1249               		.loc 1 378 26 is_stmt 0 view .LVU327
 1250 0114 9196      		adiw r26,32+1
 1251 0116 FC93      		st X,r31
 1252 0118 EE93      		st -X,r30
 1253 011a 9097      		sbiw r26,32
 380:main.c        **** 					//LED_on(YELLOW_LED);
 1254               		.loc 1 380 6 is_stmt 1 view .LVU328
 1255 011c 00C0      		rjmp .L70
 1256               	.L62:
 384:main.c        **** 					cmu->voltages[4]|=data[1];			//data 1 will hold the 8 LSBs of voltages cell 0
 1257               		.loc 1 384 6 view .LVU329
 385:main.c        **** 					cmu->voltages[5]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 1258               		.loc 1 385 6 view .LVU330
 385:main.c        **** 					cmu->voltages[5]=data[2]<<8;		//data 2 will hold the 8 MSBs of voltages cell 1
 1259               		.loc 1 385 22 is_stmt 0 view .LVU331
 1260 011e D801      		movw r26,r16
 1261 0120 1B96      		adiw r26,10+1
 1262 0122 3C93      		st X,r19
 1263 0124 2E93      		st -X,r18
 1264 0126 1A97      		sbiw r26,10
 386:main.c        **** 					cmu->voltages[5]|=data[3];			//and so on...
 1265               		.loc 1 386 6 is_stmt 1 view .LVU332
 387:main.c        **** 					cmu->voltages[6]=data[4]<<8;
 1266               		.loc 1 387 6 view .LVU333
 387:main.c        **** 					cmu->voltages[6]=data[4]<<8;
 1267               		.loc 1 387 22 is_stmt 0 view .LVU334
 1268 0128 1D96      		adiw r26,12+1
 1269 012a 5C93      		st X,r21
 1270 012c 4E93      		st -X,r20
 1271 012e 1C97      		sbiw r26,12
 388:main.c        **** 					cmu->voltages[6]|=data[5];
 1272               		.loc 1 388 6 is_stmt 1 view .LVU335
 389:main.c        **** 					cmu->voltages[7]=data[6]<<8;
 1273               		.loc 1 389 6 view .LVU336
 389:main.c        **** 					cmu->voltages[7]=data[6]<<8;
 1274               		.loc 1 389 22 is_stmt 0 view .LVU337
 1275 0130 1F96      		adiw r26,14+1
 1276 0132 7C93      		st X,r23
 1277 0134 6E93      		st -X,r22
 1278 0136 1E97      		sbiw r26,14
 390:main.c        **** 					cmu->voltages[7]|=data[7];
 1279               		.loc 1 390 6 is_stmt 1 view .LVU338
 391:main.c        **** 					
 1280               		.loc 1 391 6 view .LVU339
 391:main.c        **** 					
 1281               		.loc 1 391 22 is_stmt 0 view .LVU340
 1282 0138 5196      		adiw r26,16+1
 1283 013a FC93      		st X,r31
 1284 013c EE93      		st -X,r30
 1285 013e 5097      		sbiw r26,16
 1286 0140 00C0      		rjmp .L70
 1287               	.LBE83:
 1288               		.cfi_endproc
 1289               	.LFE29:
 1291               		.section	.text.TX_cellTemps,"ax",@progbits
 1292               	.global	TX_cellTemps
 1294               	TX_cellTemps:
 1295               	.LVL74:
 1296               	.LFB30:
 407:main.c        **** 
 408:main.c        **** 
 409:main.c        **** uint16_t TX_cellTemps(CMU _cmu, uint16_t * max_cell, uint16_t * min_cell, uint32_t *avgSum)
 410:main.c        **** {
 1297               		.loc 1 410 1 is_stmt 1 view -0
 1298               		.cfi_startproc
 1299               		.loc 1 410 1 is_stmt 0 view .LVU342
 1300 0000 2F92      		push r2
 1301               	.LCFI23:
 1302               		.cfi_def_cfa_offset 3
 1303               		.cfi_offset 2, -2
 1304 0002 3F92      		push r3
 1305               	.LCFI24:
 1306               		.cfi_def_cfa_offset 4
 1307               		.cfi_offset 3, -3
 1308 0004 5F92      		push r5
 1309               	.LCFI25:
 1310               		.cfi_def_cfa_offset 5
 1311               		.cfi_offset 5, -4
 1312 0006 6F92      		push r6
 1313               	.LCFI26:
 1314               		.cfi_def_cfa_offset 6
 1315               		.cfi_offset 6, -5
 1316 0008 7F92      		push r7
 1317               	.LCFI27:
 1318               		.cfi_def_cfa_offset 7
 1319               		.cfi_offset 7, -6
 1320 000a 8F92      		push r8
 1321               	.LCFI28:
 1322               		.cfi_def_cfa_offset 8
 1323               		.cfi_offset 8, -7
 1324 000c 9F92      		push r9
 1325               	.LCFI29:
 1326               		.cfi_def_cfa_offset 9
 1327               		.cfi_offset 9, -8
 1328 000e AF92      		push r10
 1329               	.LCFI30:
 1330               		.cfi_def_cfa_offset 10
 1331               		.cfi_offset 10, -9
 1332 0010 BF92      		push r11
 1333               	.LCFI31:
 1334               		.cfi_def_cfa_offset 11
 1335               		.cfi_offset 11, -10
 1336 0012 CF92      		push r12
 1337               	.LCFI32:
 1338               		.cfi_def_cfa_offset 12
 1339               		.cfi_offset 12, -11
 1340 0014 DF92      		push r13
 1341               	.LCFI33:
 1342               		.cfi_def_cfa_offset 13
 1343               		.cfi_offset 13, -12
 1344 0016 EF92      		push r14
 1345               	.LCFI34:
 1346               		.cfi_def_cfa_offset 14
 1347               		.cfi_offset 14, -13
 1348 0018 FF92      		push r15
 1349               	.LCFI35:
 1350               		.cfi_def_cfa_offset 15
 1351               		.cfi_offset 15, -14
 1352 001a 0F93      		push r16
 1353               	.LCFI36:
 1354               		.cfi_def_cfa_offset 16
 1355               		.cfi_offset 16, -15
 1356 001c 1F93      		push r17
 1357               	.LCFI37:
 1358               		.cfi_def_cfa_offset 17
 1359               		.cfi_offset 17, -16
 1360 001e CF93      		push r28
 1361               	.LCFI38:
 1362               		.cfi_def_cfa_offset 18
 1363               		.cfi_offset 28, -17
 1364 0020 DF93      		push r29
 1365               	.LCFI39:
 1366               		.cfi_def_cfa_offset 19
 1367               		.cfi_offset 29, -18
 1368 0022 CDB7      		in r28,__SP_L__
 1369 0024 DEB7      		in r29,__SP_H__
 1370               	.LCFI40:
 1371               		.cfi_def_cfa_register 28
 1372 0026 2897      		sbiw r28,8
 1373               	.LCFI41:
 1374               		.cfi_def_cfa_offset 27
 1375 0028 0FB6      		in __tmp_reg__,__SREG__
 1376 002a F894      		cli
 1377 002c DEBF      		out __SP_H__,r29
 1378 002e 0FBE      		out __SREG__,__tmp_reg__
 1379 0030 CDBF      		out __SP_L__,r28
 1380               	/* prologue: function */
 1381               	/* frame size = 8 */
 1382               	/* stack size = 25 */
 1383               	.L__stack_usage = 25
 1384 0032 CEAC      		ldd r12,Y+62
 1385 0034 DFAC      		ldd r13,Y+63
 1386 0036 2296      		adiw r28,64-62
 1387 0038 AEAC      		ldd r10,Y+62
 1388 003a BFAC      		ldd r11,Y+63
 1389 003c 2297      		sbiw r28,64-62
 1390 003e 2496      		adiw r28,66-62
 1391 0040 8EAC      		ldd r8,Y+62
 1392 0042 9FAC      		ldd r9,Y+63
 1393 0044 2497      		sbiw r28,66-62
 411:main.c        **** 	int8_t mob;
 1394               		.loc 1 411 2 is_stmt 1 view .LVU343
 412:main.c        **** 	uint8_t tempData[8];
 1395               		.loc 1 412 2 view .LVU344
 413:main.c        **** 
 414:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 3; cellCount++)
 1396               		.loc 1 414 2 view .LVU345
 1397               	.LBB84:
 1398               		.loc 1 414 6 view .LVU346
 1399               	.LVL75:
 1400               		.loc 1 414 6 is_stmt 0 view .LVU347
 1401 0046 D401      		movw r26,r8
 1402 0048 4D91      		ld r20,X+
 1403 004a 5D91      		ld r21,X+
 1404 004c 6D91      		ld r22,X+
 1405 004e 7C91      		ld r23,X
 1406 0050 1E01      		movw r2,r28
 1407 0052 BEE2      		ldi r27,46
 1408 0054 2B0E      		add r2,r27
 1409 0056 311C      		adc r3,__zero_reg__
 1410 0058 FE01      		movw r30,r28
 1411 005a 3196      		adiw r30,1
 1412 005c 3F01      		movw r6,r30
 1413 005e 8E01      		movw r16,r28
 1414 0060 0A5C      		subi r16,-54
 1415 0062 1F4F      		sbci r17,-1
 1416 0064 5E2E      		mov r5,r30
 1417 0066 F72C      		mov r15,r7
 1418               	.LVL76:
 1419               	.L74:
 415:main.c        **** 	{
 416:main.c        **** 		*avgSum +=_cmu.temperatures[cellCount];
 1420               		.loc 1 416 3 is_stmt 1 discriminator 3 view .LVU348
 1421               		.loc 1 416 30 is_stmt 0 discriminator 3 view .LVU349
 1422 0068 D101      		movw r26,r2
 1423 006a 8D91      		ld r24,X+
 1424 006c 9D91      		ld r25,X+
 1425 006e 1D01      		movw r2,r26
 1426               		.loc 1 416 11 discriminator 3 view .LVU350
 1427 0070 480F      		add r20,r24
 1428 0072 591F      		adc r21,r25
 1429 0074 611D      		adc r22,__zero_reg__
 1430 0076 711D      		adc r23,__zero_reg__
 417:main.c        **** 		*min_cell = _cmu.temperatures[cellCount] < *min_cell ? _cmu.temperatures[cellCount] : *min_cell;	
 1431               		.loc 1 417 3 is_stmt 1 discriminator 3 view .LVU351
 1432               		.loc 1 417 87 is_stmt 0 discriminator 3 view .LVU352
 1433 0078 D501      		movw r26,r10
 1434 007a 2D91      		ld r18,X+
 1435 007c 3C91      		ld r19,X
 1436 007e 8217      		cp r24,r18
 1437 0080 9307      		cpc r25,r19
 1438 0082 00F4      		brsh .L72
 1439               	.LVL77:
 1440               		.loc 1 417 87 discriminator 3 view .LVU353
 1441 0084 9C01      		movw r18,r24
 1442               	.L72:
 1443               		.loc 1 417 13 discriminator 3 view .LVU354
 1444 0086 D501      		movw r26,r10
 1445 0088 2D93      		st X+,r18
 1446 008a 3C93      		st X,r19
 418:main.c        **** 		*max_cell = _cmu.temperatures[cellCount] > *max_cell ? _cmu.temperatures[cellCount] : *max_cell;	
 1447               		.loc 1 418 3 is_stmt 1 discriminator 3 view .LVU355
 1448               		.loc 1 418 87 is_stmt 0 discriminator 3 view .LVU356
 1449 008c D601      		movw r26,r12
 1450 008e 2D91      		ld r18,X+
 1451 0090 3C91      		ld r19,X
 1452 0092 2817      		cp r18,r24
 1453 0094 3907      		cpc r19,r25
 1454 0096 00F4      		brsh .L73
 1455               	.LVL78:
 1456               		.loc 1 418 87 discriminator 3 view .LVU357
 1457 0098 9C01      		movw r18,r24
 1458               	.L73:
 1459               		.loc 1 418 13 discriminator 3 view .LVU358
 1460 009a D601      		movw r26,r12
 1461 009c 2D93      		st X+,r18
 1462 009e 3C93      		st X,r19
 419:main.c        **** 		tempData[cellCount*2]	= _cmu.temperatures[cellCount] >> 8;
 1463               		.loc 1 419 3 is_stmt 1 discriminator 3 view .LVU359
 1464               		.loc 1 419 25 is_stmt 0 discriminator 3 view .LVU360
 1465 00a0 9083      		st Z,r25
 420:main.c        **** 		tempData[cellCount*2+1] = _cmu.temperatures[cellCount];
 1466               		.loc 1 420 3 is_stmt 1 discriminator 3 view .LVU361
 1467               		.loc 1 420 27 is_stmt 0 discriminator 3 view .LVU362
 1468 00a2 8183      		std Z+1,r24
 1469               		.loc 1 420 27 discriminator 3 view .LVU363
 1470 00a4 3296      		adiw r30,2
 414:main.c        **** 	{
 1471               		.loc 1 414 2 discriminator 3 view .LVU364
 1472 00a6 2016      		cp r2,r16
 1473 00a8 3106      		cpc r3,r17
 1474 00aa 01F4      		brne .L74
 414:main.c        **** 	{
 1475               		.loc 1 414 2 discriminator 3 view .LVU365
 1476 00ac F401      		movw r30,r8
 1477 00ae 4083      		st Z,r20
 1478 00b0 5183      		std Z+1,r21
 1479 00b2 6283      		std Z+2,r22
 1480 00b4 7383      		std Z+3,r23
 1481               	.LBE84:
 421:main.c        **** 	}
 422:main.c        **** 	mob = CAN_findFreeTXMOB();
 1482               		.loc 1 422 2 is_stmt 1 view .LVU366
 1483               		.loc 1 422 8 is_stmt 0 view .LVU367
 1484 00b6 0E94 0000 		call CAN_findFreeTXMOB
 1485               	.LVL79:
 423:main.c        **** 	CAN_TXMOB(mob, 8, tempData, ((uint32_t)1<<25)|((uint32_t)DEVICE_ID<<13)|CC_TEMP1_ID, 0); //transmi
 1486               		.loc 1 423 2 is_stmt 1 view .LVU368
 1487 00ba E12C      		mov r14,__zero_reg__
 1488 00bc 04E6      		ldi r16,lo8(100)
 1489 00be 10E2      		ldi r17,lo8(32)
 1490 00c0 20E0      		ldi r18,0
 1491 00c2 32E0      		ldi r19,lo8(2)
 1492 00c4 A301      		movw r20,r6
 1493 00c6 68E0      		ldi r22,lo8(8)
 1494 00c8 0E94 0000 		call CAN_TXMOB
 1495               	.LVL80:
 424:main.c        **** 	_delay_ms(1);
 1496               		.loc 1 424 2 view .LVU369
 1497               	.LBB85:
 1498               	.LBI85:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1499               		.loc 2 166 1 view .LVU370
 1500               	.LBB86:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1501               		.loc 2 168 2 view .LVU371
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1502               		.loc 2 172 2 view .LVU372
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1503               		.loc 2 173 2 view .LVU373
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1504               		.loc 2 174 2 view .LVU374
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1505               		.loc 2 184 3 view .LVU375
 1506               		.loc 2 187 2 view .LVU376
 1507 00cc 8FE9      		ldi r24,lo8(3999)
 1508 00ce 9FE0      		ldi r25,hi8(3999)
 1509 00d0 0197      	1:	sbiw r24,1
 1510 00d2 01F4      		brne 1b
 1511 00d4 00C0      		rjmp .
 1512 00d6 0000      		nop
 1513               	.LVL81:
 1514               		.loc 2 187 2 is_stmt 0 view .LVU377
 1515               	.LBE86:
 1516               	.LBE85:
 425:main.c        **** 	
 426:main.c        **** 	for(uint8_t cellCount = 4; cellCount <= 7; cellCount++)
 1517               		.loc 1 426 2 is_stmt 1 view .LVU378
 1518               	.LBB87:
 1519               		.loc 1 426 6 view .LVU379
 1520               		.loc 1 426 6 is_stmt 0 view .LVU380
 1521 00d8 D401      		movw r26,r8
 1522 00da 4D91      		ld r20,X+
 1523 00dc 5D91      		ld r21,X+
 1524 00de 6D91      		ld r22,X+
 1525 00e0 7C91      		ld r23,X
 1526 00e2 FE01      		movw r30,r28
 1527 00e4 F696      		adiw r30,54
 1528 00e6 8E01      		movw r16,r28
 1529 00e8 025C      		subi r16,-62
 1530 00ea 1F4F      		sbci r17,-1
 1531               	.LVL82:
 1532               	.L77:
 427:main.c        **** 	{
 428:main.c        **** 		*avgSum +=_cmu.temperatures[cellCount];
 1533               		.loc 1 428 3 is_stmt 1 discriminator 3 view .LVU381
 1534               		.loc 1 428 30 is_stmt 0 discriminator 3 view .LVU382
 1535 00ec 8191      		ld r24,Z+
 1536 00ee 9191      		ld r25,Z+
 1537               		.loc 1 428 11 discriminator 3 view .LVU383
 1538 00f0 480F      		add r20,r24
 1539 00f2 591F      		adc r21,r25
 1540 00f4 611D      		adc r22,__zero_reg__
 1541 00f6 711D      		adc r23,__zero_reg__
 429:main.c        **** 		*min_cell = _cmu.temperatures[cellCount] < *min_cell ? _cmu.temperatures[cellCount] : *min_cell;	
 1542               		.loc 1 429 3 is_stmt 1 discriminator 3 view .LVU384
 1543               		.loc 1 429 87 is_stmt 0 discriminator 3 view .LVU385
 1544 00f8 D501      		movw r26,r10
 1545 00fa 2D91      		ld r18,X+
 1546 00fc 3C91      		ld r19,X
 1547 00fe 8217      		cp r24,r18
 1548 0100 9307      		cpc r25,r19
 1549 0102 00F4      		brsh .L75
 1550               	.LVL83:
 1551               		.loc 1 429 87 discriminator 3 view .LVU386
 1552 0104 9C01      		movw r18,r24
 1553               	.L75:
 1554               		.loc 1 429 13 discriminator 3 view .LVU387
 1555 0106 D501      		movw r26,r10
 1556 0108 2D93      		st X+,r18
 1557 010a 3C93      		st X,r19
 430:main.c        **** 		*max_cell = _cmu.temperatures[cellCount] > *max_cell ? _cmu.temperatures[cellCount] : *max_cell;	
 1558               		.loc 1 430 3 is_stmt 1 discriminator 3 view .LVU388
 1559               		.loc 1 430 87 is_stmt 0 discriminator 3 view .LVU389
 1560 010c D601      		movw r26,r12
 1561 010e 2D91      		ld r18,X+
 1562 0110 3C91      		ld r19,X
 1563 0112 2817      		cp r18,r24
 1564 0114 3907      		cpc r19,r25
 1565 0116 00F4      		brsh .L76
 1566               	.LVL84:
 1567               		.loc 1 430 87 discriminator 3 view .LVU390
 1568 0118 9C01      		movw r18,r24
 1569               	.L76:
 1570               		.loc 1 430 13 discriminator 3 view .LVU391
 1571 011a D601      		movw r26,r12
 1572 011c 2D93      		st X+,r18
 1573 011e 3C93      		st X,r19
 431:main.c        **** 		tempData[(cellCount-4)*2]	= _cmu.temperatures[cellCount] >> 8;
 1574               		.loc 1 431 3 is_stmt 1 discriminator 3 view .LVU392
 1575               		.loc 1 431 29 is_stmt 0 discriminator 3 view .LVU393
 1576 0120 D301      		movw r26,r6
 1577 0122 9C93      		st X,r25
 432:main.c        **** 		tempData[(cellCount-4)*2+1] = _cmu.temperatures[cellCount];
 1578               		.loc 1 432 3 is_stmt 1 discriminator 3 view .LVU394
 1579               		.loc 1 432 31 is_stmt 0 discriminator 3 view .LVU395
 1580 0124 1196      		adiw r26,1
 1581 0126 8C93      		st X,r24
 1582               		.loc 1 432 31 discriminator 3 view .LVU396
 1583 0128 B2E0      		ldi r27,2
 1584 012a 6B0E      		add r6,r27
 1585 012c 711C      		adc r7,__zero_reg__
 426:main.c        **** 	{
 1586               		.loc 1 426 2 discriminator 3 view .LVU397
 1587 012e 0E17      		cp r16,r30
 1588 0130 1F07      		cpc r17,r31
 1589 0132 01F4      		brne .L77
 1590 0134 F401      		movw r30,r8
 1591 0136 4083      		st Z,r20
 1592 0138 5183      		std Z+1,r21
 1593 013a 6283      		std Z+2,r22
 1594 013c 7383      		std Z+3,r23
 1595               	.LBE87:
 433:main.c        **** 	}
 434:main.c        **** 	mob = CAN_findFreeTXMOB();
 1596               		.loc 1 434 2 is_stmt 1 view .LVU398
 1597               		.loc 1 434 8 is_stmt 0 view .LVU399
 1598 013e 0E94 0000 		call CAN_findFreeTXMOB
 1599               	.LVL85:
 435:main.c        **** 	CAN_TXMOB(mob, 8, tempData, ((uint32_t)1<<25)|((uint32_t)DEVICE_ID<<13)|CC_TEMP2_ID, 0); //transmi
 1600               		.loc 1 435 2 is_stmt 1 view .LVU400
 1601 0142 E12C      		mov r14,__zero_reg__
 1602 0144 05E6      		ldi r16,lo8(101)
 1603 0146 10E2      		ldi r17,lo8(32)
 1604 0148 20E0      		ldi r18,0
 1605 014a 32E0      		ldi r19,lo8(2)
 1606 014c 452D      		mov r20,r5
 1607 014e 5F2D      		mov r21,r15
 1608 0150 68E0      		ldi r22,lo8(8)
 1609 0152 0E94 0000 		call CAN_TXMOB
 1610               	.LVL86:
 436:main.c        **** 	_delay_ms(1);
 1611               		.loc 1 436 2 view .LVU401
 1612               	.LBB88:
 1613               	.LBI88:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1614               		.loc 2 166 1 view .LVU402
 1615               	.LBB89:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1616               		.loc 2 168 2 view .LVU403
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1617               		.loc 2 172 2 view .LVU404
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1618               		.loc 2 173 2 view .LVU405
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1619               		.loc 2 174 2 view .LVU406
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1620               		.loc 2 184 3 view .LVU407
 1621               		.loc 2 187 2 view .LVU408
 1622 0156 8FE9      		ldi r24,lo8(3999)
 1623 0158 9FE0      		ldi r25,hi8(3999)
 1624 015a 0197      	1:	sbiw r24,1
 1625 015c 01F4      		brne 1b
 1626 015e 00C0      		rjmp .
 1627 0160 0000      		nop
 1628               	.LVL87:
 1629               		.loc 2 187 2 is_stmt 0 view .LVU409
 1630               	.LBE89:
 1631               	.LBE88:
 437:main.c        **** 	
 438:main.c        **** 	return 0;
 1632               		.loc 1 438 2 is_stmt 1 view .LVU410
 439:main.c        **** 	
 440:main.c        **** }
 1633               		.loc 1 440 1 is_stmt 0 view .LVU411
 1634 0162 90E0      		ldi r25,0
 1635 0164 80E0      		ldi r24,0
 1636               	/* epilogue start */
 1637 0166 2896      		adiw r28,8
 1638 0168 0FB6      		in __tmp_reg__,__SREG__
 1639 016a F894      		cli
 1640 016c DEBF      		out __SP_H__,r29
 1641 016e 0FBE      		out __SREG__,__tmp_reg__
 1642 0170 CDBF      		out __SP_L__,r28
 1643 0172 DF91      		pop r29
 1644 0174 CF91      		pop r28
 1645 0176 1F91      		pop r17
 1646 0178 0F91      		pop r16
 1647 017a FF90      		pop r15
 1648 017c EF90      		pop r14
 1649 017e DF90      		pop r13
 1650 0180 CF90      		pop r12
 1651 0182 BF90      		pop r11
 1652 0184 AF90      		pop r10
 1653 0186 9F90      		pop r9
 1654 0188 8F90      		pop r8
 1655               	.LVL88:
 1656               		.loc 1 440 1 view .LVU412
 1657 018a 7F90      		pop r7
 1658 018c 6F90      		pop r6
 1659 018e 5F90      		pop r5
 1660 0190 3F90      		pop r3
 1661 0192 2F90      		pop r2
 1662 0194 0895      		ret
 1663               		.cfi_endproc
 1664               	.LFE30:
 1666               		.section	.text.TX_cellVoltage,"ax",@progbits
 1667               	.global	TX_cellVoltage
 1669               	TX_cellVoltage:
 1670               	.LVL89:
 1671               	.LFB31:
 441:main.c        **** 
 442:main.c        **** uint8_t TX_cellVoltage(CMU _cmu, uint16_t * max_cell, uint16_t * min_cell, uint32_t * avgSum)
 443:main.c        **** {
 1672               		.loc 1 443 1 is_stmt 1 view -0
 1673               		.cfi_startproc
 1674               		.loc 1 443 1 is_stmt 0 view .LVU414
 1675 0000 2F92      		push r2
 1676               	.LCFI42:
 1677               		.cfi_def_cfa_offset 3
 1678               		.cfi_offset 2, -2
 1679 0002 3F92      		push r3
 1680               	.LCFI43:
 1681               		.cfi_def_cfa_offset 4
 1682               		.cfi_offset 3, -3
 1683 0004 5F92      		push r5
 1684               	.LCFI44:
 1685               		.cfi_def_cfa_offset 5
 1686               		.cfi_offset 5, -4
 1687 0006 6F92      		push r6
 1688               	.LCFI45:
 1689               		.cfi_def_cfa_offset 6
 1690               		.cfi_offset 6, -5
 1691 0008 7F92      		push r7
 1692               	.LCFI46:
 1693               		.cfi_def_cfa_offset 7
 1694               		.cfi_offset 7, -6
 1695 000a 8F92      		push r8
 1696               	.LCFI47:
 1697               		.cfi_def_cfa_offset 8
 1698               		.cfi_offset 8, -7
 1699 000c 9F92      		push r9
 1700               	.LCFI48:
 1701               		.cfi_def_cfa_offset 9
 1702               		.cfi_offset 9, -8
 1703 000e AF92      		push r10
 1704               	.LCFI49:
 1705               		.cfi_def_cfa_offset 10
 1706               		.cfi_offset 10, -9
 1707 0010 BF92      		push r11
 1708               	.LCFI50:
 1709               		.cfi_def_cfa_offset 11
 1710               		.cfi_offset 11, -10
 1711 0012 CF92      		push r12
 1712               	.LCFI51:
 1713               		.cfi_def_cfa_offset 12
 1714               		.cfi_offset 12, -11
 1715 0014 DF92      		push r13
 1716               	.LCFI52:
 1717               		.cfi_def_cfa_offset 13
 1718               		.cfi_offset 13, -12
 1719 0016 EF92      		push r14
 1720               	.LCFI53:
 1721               		.cfi_def_cfa_offset 14
 1722               		.cfi_offset 14, -13
 1723 0018 FF92      		push r15
 1724               	.LCFI54:
 1725               		.cfi_def_cfa_offset 15
 1726               		.cfi_offset 15, -14
 1727 001a 0F93      		push r16
 1728               	.LCFI55:
 1729               		.cfi_def_cfa_offset 16
 1730               		.cfi_offset 16, -15
 1731 001c 1F93      		push r17
 1732               	.LCFI56:
 1733               		.cfi_def_cfa_offset 17
 1734               		.cfi_offset 17, -16
 1735 001e CF93      		push r28
 1736               	.LCFI57:
 1737               		.cfi_def_cfa_offset 18
 1738               		.cfi_offset 28, -17
 1739 0020 DF93      		push r29
 1740               	.LCFI58:
 1741               		.cfi_def_cfa_offset 19
 1742               		.cfi_offset 29, -18
 1743 0022 CDB7      		in r28,__SP_L__
 1744 0024 DEB7      		in r29,__SP_H__
 1745               	.LCFI59:
 1746               		.cfi_def_cfa_register 28
 1747 0026 2897      		sbiw r28,8
 1748               	.LCFI60:
 1749               		.cfi_def_cfa_offset 27
 1750 0028 0FB6      		in __tmp_reg__,__SREG__
 1751 002a F894      		cli
 1752 002c DEBF      		out __SP_H__,r29
 1753 002e 0FBE      		out __SREG__,__tmp_reg__
 1754 0030 CDBF      		out __SP_L__,r28
 1755               	/* prologue: function */
 1756               	/* frame size = 8 */
 1757               	/* stack size = 25 */
 1758               	.L__stack_usage = 25
 1759 0032 CEAC      		ldd r12,Y+62
 1760 0034 DFAC      		ldd r13,Y+63
 1761 0036 2296      		adiw r28,64-62
 1762 0038 AEAC      		ldd r10,Y+62
 1763 003a BFAC      		ldd r11,Y+63
 1764 003c 2297      		sbiw r28,64-62
 1765 003e 2496      		adiw r28,66-62
 1766 0040 8EAC      		ldd r8,Y+62
 1767 0042 9FAC      		ldd r9,Y+63
 1768 0044 2497      		sbiw r28,66-62
 444:main.c        **** 	int8_t mob;
 1769               		.loc 1 444 2 is_stmt 1 view .LVU415
 445:main.c        **** 	uint8_t tempData[8];
 1770               		.loc 1 445 2 view .LVU416
 446:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 3; cellCount++)
 1771               		.loc 1 446 2 view .LVU417
 1772               	.LBB90:
 1773               		.loc 1 446 6 view .LVU418
 1774               	.LVL90:
 1775               		.loc 1 446 6 is_stmt 0 view .LVU419
 1776 0046 D401      		movw r26,r8
 1777 0048 4D91      		ld r20,X+
 1778 004a 5D91      		ld r21,X+
 1779 004c 6D91      		ld r22,X+
 1780 004e 7C91      		ld r23,X
 1781 0050 1E01      		movw r2,r28
 1782 0052 BEE1      		ldi r27,30
 1783 0054 2B0E      		add r2,r27
 1784 0056 311C      		adc r3,__zero_reg__
 1785 0058 FE01      		movw r30,r28
 1786 005a 3196      		adiw r30,1
 1787 005c 3F01      		movw r6,r30
 1788 005e 8E01      		movw r16,r28
 1789 0060 0A5D      		subi r16,-38
 1790 0062 1F4F      		sbci r17,-1
 1791 0064 5E2E      		mov r5,r30
 1792 0066 F72C      		mov r15,r7
 1793               	.LVL91:
 1794               	.L83:
 447:main.c        **** 	{
 448:main.c        **** 		*min_cell = _cmu.voltages[cellCount] < *min_cell ? _cmu.voltages[cellCount] : *min_cell;		//if th
 1795               		.loc 1 448 3 is_stmt 1 discriminator 3 view .LVU420
 1796               		.loc 1 448 28 is_stmt 0 discriminator 3 view .LVU421
 1797 0068 D101      		movw r26,r2
 1798 006a 8D91      		ld r24,X+
 1799 006c 9D91      		ld r25,X+
 1800 006e 1D01      		movw r2,r26
 1801               		.loc 1 448 79 discriminator 3 view .LVU422
 1802 0070 D501      		movw r26,r10
 1803 0072 2D91      		ld r18,X+
 1804 0074 3C91      		ld r19,X
 1805 0076 8217      		cp r24,r18
 1806 0078 9307      		cpc r25,r19
 1807 007a 00F4      		brsh .L81
 1808               	.LVL92:
 1809               		.loc 1 448 79 discriminator 3 view .LVU423
 1810 007c 9C01      		movw r18,r24
 1811               	.L81:
 1812               		.loc 1 448 13 discriminator 3 view .LVU424
 1813 007e D501      		movw r26,r10
 1814 0080 2D93      		st X+,r18
 1815 0082 3C93      		st X,r19
 449:main.c        **** 		*max_cell = _cmu.voltages[cellCount] > *max_cell ? _cmu.voltages[cellCount] : *max_cell;		//if th
 1816               		.loc 1 449 3 is_stmt 1 discriminator 3 view .LVU425
 1817               		.loc 1 449 79 is_stmt 0 discriminator 3 view .LVU426
 1818 0084 D601      		movw r26,r12
 1819 0086 2D91      		ld r18,X+
 1820 0088 3C91      		ld r19,X
 1821 008a 2817      		cp r18,r24
 1822 008c 3907      		cpc r19,r25
 1823 008e 00F4      		brsh .L82
 1824               	.LVL93:
 1825               		.loc 1 449 79 discriminator 3 view .LVU427
 1826 0090 9C01      		movw r18,r24
 1827               	.L82:
 1828               		.loc 1 449 13 discriminator 3 view .LVU428
 1829 0092 D601      		movw r26,r12
 1830 0094 2D93      		st X+,r18
 1831 0096 3C93      		st X,r19
 450:main.c        **** 		*avgSum +=_cmu.voltages[cellCount];
 1832               		.loc 1 450 3 is_stmt 1 discriminator 3 view .LVU429
 1833               		.loc 1 450 11 is_stmt 0 discriminator 3 view .LVU430
 1834 0098 480F      		add r20,r24
 1835 009a 591F      		adc r21,r25
 1836 009c 611D      		adc r22,__zero_reg__
 1837 009e 711D      		adc r23,__zero_reg__
 451:main.c        **** 		tempData[cellCount*2]	= _cmu.voltages[cellCount] >> 8;
 1838               		.loc 1 451 3 is_stmt 1 discriminator 3 view .LVU431
 1839               		.loc 1 451 25 is_stmt 0 discriminator 3 view .LVU432
 1840 00a0 9083      		st Z,r25
 452:main.c        **** 		tempData[cellCount*2+1] = _cmu.voltages[cellCount];
 1841               		.loc 1 452 3 is_stmt 1 discriminator 3 view .LVU433
 1842               		.loc 1 452 27 is_stmt 0 discriminator 3 view .LVU434
 1843 00a2 8183      		std Z+1,r24
 1844               		.loc 1 452 27 discriminator 3 view .LVU435
 1845 00a4 3296      		adiw r30,2
 446:main.c        **** 	{
 1846               		.loc 1 446 2 discriminator 3 view .LVU436
 1847 00a6 2016      		cp r2,r16
 1848 00a8 3106      		cpc r3,r17
 1849 00aa 01F4      		brne .L83
 446:main.c        **** 	{
 1850               		.loc 1 446 2 discriminator 3 view .LVU437
 1851 00ac F401      		movw r30,r8
 1852 00ae 4083      		st Z,r20
 1853 00b0 5183      		std Z+1,r21
 1854 00b2 6283      		std Z+2,r22
 1855 00b4 7383      		std Z+3,r23
 1856               	.LBE90:
 453:main.c        **** 	}
 454:main.c        **** 	mob = CAN_findFreeTXMOB();
 1857               		.loc 1 454 2 is_stmt 1 view .LVU438
 1858               		.loc 1 454 8 is_stmt 0 view .LVU439
 1859 00b6 0E94 0000 		call CAN_findFreeTXMOB
 1860               	.LVL94:
 455:main.c        **** 	CAN_TXMOB(mob, 8, tempData, ((uint32_t)1<<25)|((uint32_t)DEVICE_ID<<13)|CC_VOLT1_ID, 0); //transmi
 1861               		.loc 1 455 2 is_stmt 1 view .LVU440
 1862 00ba E12C      		mov r14,__zero_reg__
 1863 00bc 0AE0      		ldi r16,lo8(10)
 1864 00be 10E2      		ldi r17,lo8(32)
 1865 00c0 20E0      		ldi r18,0
 1866 00c2 32E0      		ldi r19,lo8(2)
 1867 00c4 A301      		movw r20,r6
 1868 00c6 68E0      		ldi r22,lo8(8)
 1869 00c8 0E94 0000 		call CAN_TXMOB
 1870               	.LVL95:
 456:main.c        **** 	_delay_ms(1);
 1871               		.loc 1 456 2 view .LVU441
 1872               	.LBB91:
 1873               	.LBI91:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1874               		.loc 2 166 1 view .LVU442
 1875               	.LBB92:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1876               		.loc 2 168 2 view .LVU443
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1877               		.loc 2 172 2 view .LVU444
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1878               		.loc 2 173 2 view .LVU445
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1879               		.loc 2 174 2 view .LVU446
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1880               		.loc 2 184 3 view .LVU447
 1881               		.loc 2 187 2 view .LVU448
 1882 00cc 8FE9      		ldi r24,lo8(3999)
 1883 00ce 9FE0      		ldi r25,hi8(3999)
 1884 00d0 0197      	1:	sbiw r24,1
 1885 00d2 01F4      		brne 1b
 1886 00d4 00C0      		rjmp .
 1887 00d6 0000      		nop
 1888               	.LVL96:
 1889               		.loc 2 187 2 is_stmt 0 view .LVU449
 1890               	.LBE92:
 1891               	.LBE91:
 457:main.c        **** 	for(uint8_t cellCount = 4; cellCount <= 7; cellCount++)
 1892               		.loc 1 457 2 is_stmt 1 view .LVU450
 1893               	.LBB93:
 1894               		.loc 1 457 6 view .LVU451
 1895               		.loc 1 457 6 is_stmt 0 view .LVU452
 1896 00d8 D401      		movw r26,r8
 1897 00da 4D91      		ld r20,X+
 1898 00dc 5D91      		ld r21,X+
 1899 00de 6D91      		ld r22,X+
 1900 00e0 7C91      		ld r23,X
 1901 00e2 FE01      		movw r30,r28
 1902 00e4 B696      		adiw r30,38
 1903 00e6 8E01      		movw r16,r28
 1904 00e8 025D      		subi r16,-46
 1905 00ea 1F4F      		sbci r17,-1
 1906               	.LVL97:
 1907               	.L86:
 458:main.c        **** 	{
 459:main.c        **** 		*min_cell = _cmu.voltages[cellCount] < *min_cell ? _cmu.voltages[cellCount] : *min_cell;		//if th
 1908               		.loc 1 459 3 is_stmt 1 discriminator 3 view .LVU453
 1909               		.loc 1 459 28 is_stmt 0 discriminator 3 view .LVU454
 1910 00ec 8191      		ld r24,Z+
 1911 00ee 9191      		ld r25,Z+
 1912               		.loc 1 459 79 discriminator 3 view .LVU455
 1913 00f0 D501      		movw r26,r10
 1914 00f2 2D91      		ld r18,X+
 1915 00f4 3C91      		ld r19,X
 1916 00f6 8217      		cp r24,r18
 1917 00f8 9307      		cpc r25,r19
 1918 00fa 00F4      		brsh .L84
 1919               	.LVL98:
 1920               		.loc 1 459 79 discriminator 3 view .LVU456
 1921 00fc 9C01      		movw r18,r24
 1922               	.L84:
 1923               		.loc 1 459 13 discriminator 3 view .LVU457
 1924 00fe D501      		movw r26,r10
 1925 0100 2D93      		st X+,r18
 1926 0102 3C93      		st X,r19
 460:main.c        **** 		*max_cell = _cmu.voltages[cellCount] > *max_cell ? _cmu.voltages[cellCount] : *max_cell;		//if th
 1927               		.loc 1 460 3 is_stmt 1 discriminator 3 view .LVU458
 1928               		.loc 1 460 79 is_stmt 0 discriminator 3 view .LVU459
 1929 0104 D601      		movw r26,r12
 1930 0106 2D91      		ld r18,X+
 1931 0108 3C91      		ld r19,X
 1932 010a 2817      		cp r18,r24
 1933 010c 3907      		cpc r19,r25
 1934 010e 00F4      		brsh .L85
 1935               	.LVL99:
 1936               		.loc 1 460 79 discriminator 3 view .LVU460
 1937 0110 9C01      		movw r18,r24
 1938               	.L85:
 1939               		.loc 1 460 13 discriminator 3 view .LVU461
 1940 0112 D601      		movw r26,r12
 1941 0114 2D93      		st X+,r18
 1942 0116 3C93      		st X,r19
 461:main.c        **** 		*avgSum +=_cmu.voltages[cellCount];
 1943               		.loc 1 461 3 is_stmt 1 discriminator 3 view .LVU462
 1944               		.loc 1 461 11 is_stmt 0 discriminator 3 view .LVU463
 1945 0118 480F      		add r20,r24
 1946 011a 591F      		adc r21,r25
 1947 011c 611D      		adc r22,__zero_reg__
 1948 011e 711D      		adc r23,__zero_reg__
 462:main.c        **** 		tempData[(cellCount-4)*2]	= _cmu.voltages[cellCount] >> 8;
 1949               		.loc 1 462 3 is_stmt 1 discriminator 3 view .LVU464
 1950               		.loc 1 462 29 is_stmt 0 discriminator 3 view .LVU465
 1951 0120 D301      		movw r26,r6
 1952 0122 9C93      		st X,r25
 463:main.c        **** 		tempData[(cellCount-4)*2+1] = _cmu.voltages[cellCount];
 1953               		.loc 1 463 3 is_stmt 1 discriminator 3 view .LVU466
 1954               		.loc 1 463 31 is_stmt 0 discriminator 3 view .LVU467
 1955 0124 1196      		adiw r26,1
 1956 0126 8C93      		st X,r24
 1957               		.loc 1 463 31 discriminator 3 view .LVU468
 1958 0128 B2E0      		ldi r27,2
 1959 012a 6B0E      		add r6,r27
 1960 012c 711C      		adc r7,__zero_reg__
 457:main.c        **** 	{
 1961               		.loc 1 457 2 discriminator 3 view .LVU469
 1962 012e 0E17      		cp r16,r30
 1963 0130 1F07      		cpc r17,r31
 1964 0132 01F4      		brne .L86
 1965 0134 F401      		movw r30,r8
 1966 0136 4083      		st Z,r20
 1967 0138 5183      		std Z+1,r21
 1968 013a 6283      		std Z+2,r22
 1969 013c 7383      		std Z+3,r23
 1970               	.LBE93:
 464:main.c        **** 	}
 465:main.c        **** 	mob = CAN_findFreeTXMOB();
 1971               		.loc 1 465 2 is_stmt 1 view .LVU470
 1972               		.loc 1 465 8 is_stmt 0 view .LVU471
 1973 013e 0E94 0000 		call CAN_findFreeTXMOB
 1974               	.LVL100:
 466:main.c        **** 	CAN_TXMOB(mob, 8, tempData, ((uint32_t)1<<25)|((uint32_t)DEVICE_ID<<13)|CC_VOLT2_ID, 0); //transmi
 1975               		.loc 1 466 2 is_stmt 1 view .LVU472
 1976 0142 E12C      		mov r14,__zero_reg__
 1977 0144 0BE0      		ldi r16,lo8(11)
 1978 0146 10E2      		ldi r17,lo8(32)
 1979 0148 20E0      		ldi r18,0
 1980 014a 32E0      		ldi r19,lo8(2)
 1981 014c 452D      		mov r20,r5
 1982 014e 5F2D      		mov r21,r15
 1983 0150 68E0      		ldi r22,lo8(8)
 1984 0152 0E94 0000 		call CAN_TXMOB
 1985               	.LVL101:
 467:main.c        **** 	_delay_ms(1);
 1986               		.loc 1 467 2 view .LVU473
 1987               	.LBB94:
 1988               	.LBI94:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1989               		.loc 2 166 1 view .LVU474
 1990               	.LBB95:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1991               		.loc 2 168 2 view .LVU475
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1992               		.loc 2 172 2 view .LVU476
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1993               		.loc 2 173 2 view .LVU477
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1994               		.loc 2 174 2 view .LVU478
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1995               		.loc 2 184 3 view .LVU479
 1996               		.loc 2 187 2 view .LVU480
 1997 0156 8FE9      		ldi r24,lo8(3999)
 1998 0158 9FE0      		ldi r25,hi8(3999)
 1999 015a 0197      	1:	sbiw r24,1
 2000 015c 01F4      		brne 1b
 2001 015e 00C0      		rjmp .
 2002 0160 0000      		nop
 2003               	.LVL102:
 2004               		.loc 2 187 2 is_stmt 0 view .LVU481
 2005               	.LBE95:
 2006               	.LBE94:
 468:main.c        **** 	return 0;
 2007               		.loc 1 468 2 is_stmt 1 view .LVU482
 469:main.c        **** }
 2008               		.loc 1 469 1 is_stmt 0 view .LVU483
 2009 0162 80E0      		ldi r24,0
 2010               	/* epilogue start */
 2011 0164 2896      		adiw r28,8
 2012 0166 0FB6      		in __tmp_reg__,__SREG__
 2013 0168 F894      		cli
 2014 016a DEBF      		out __SP_H__,r29
 2015 016c 0FBE      		out __SREG__,__tmp_reg__
 2016 016e CDBF      		out __SP_L__,r28
 2017 0170 DF91      		pop r29
 2018 0172 CF91      		pop r28
 2019 0174 1F91      		pop r17
 2020 0176 0F91      		pop r16
 2021 0178 FF90      		pop r15
 2022 017a EF90      		pop r14
 2023 017c DF90      		pop r13
 2024 017e CF90      		pop r12
 2025 0180 BF90      		pop r11
 2026 0182 AF90      		pop r10
 2027 0184 9F90      		pop r9
 2028 0186 8F90      		pop r8
 2029               	.LVL103:
 2030               		.loc 1 469 1 view .LVU484
 2031 0188 7F90      		pop r7
 2032 018a 6F90      		pop r6
 2033 018c 5F90      		pop r5
 2034 018e 3F90      		pop r3
 2035 0190 2F90      		pop r2
 2036 0192 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE31:
 2040               		.section	.text.TX_globalData,"ax",@progbits
 2041               	.global	TX_globalData
 2043               	TX_globalData:
 2044               	.LVL104:
 2045               	.LFB32:
 470:main.c        **** 
 471:main.c        **** uint8_t TX_globalData(uint16_t max_volt, uint16_t min_volt, uint16_t max_temp, uint16_t min_temp, u
 472:main.c        **** {
 2046               		.loc 1 472 1 is_stmt 1 view -0
 2047               		.cfi_startproc
 2048               		.loc 1 472 1 is_stmt 0 view .LVU486
 2049 0000 2F92      		push r2
 2050               	.LCFI61:
 2051               		.cfi_def_cfa_offset 3
 2052               		.cfi_offset 2, -2
 2053 0002 3F92      		push r3
 2054               	.LCFI62:
 2055               		.cfi_def_cfa_offset 4
 2056               		.cfi_offset 3, -3
 2057 0004 4F92      		push r4
 2058               	.LCFI63:
 2059               		.cfi_def_cfa_offset 5
 2060               		.cfi_offset 4, -4
 2061 0006 5F92      		push r5
 2062               	.LCFI64:
 2063               		.cfi_def_cfa_offset 6
 2064               		.cfi_offset 5, -5
 2065 0008 6F92      		push r6
 2066               	.LCFI65:
 2067               		.cfi_def_cfa_offset 7
 2068               		.cfi_offset 6, -6
 2069 000a 7F92      		push r7
 2070               	.LCFI66:
 2071               		.cfi_def_cfa_offset 8
 2072               		.cfi_offset 7, -7
 2073 000c 8F92      		push r8
 2074               	.LCFI67:
 2075               		.cfi_def_cfa_offset 9
 2076               		.cfi_offset 8, -8
 2077 000e 9F92      		push r9
 2078               	.LCFI68:
 2079               		.cfi_def_cfa_offset 10
 2080               		.cfi_offset 9, -9
 2081 0010 AF92      		push r10
 2082               	.LCFI69:
 2083               		.cfi_def_cfa_offset 11
 2084               		.cfi_offset 10, -10
 2085 0012 BF92      		push r11
 2086               	.LCFI70:
 2087               		.cfi_def_cfa_offset 12
 2088               		.cfi_offset 11, -11
 2089 0014 CF92      		push r12
 2090               	.LCFI71:
 2091               		.cfi_def_cfa_offset 13
 2092               		.cfi_offset 12, -12
 2093 0016 DF92      		push r13
 2094               	.LCFI72:
 2095               		.cfi_def_cfa_offset 14
 2096               		.cfi_offset 13, -13
 2097 0018 EF92      		push r14
 2098               	.LCFI73:
 2099               		.cfi_def_cfa_offset 15
 2100               		.cfi_offset 14, -14
 2101 001a FF92      		push r15
 2102               	.LCFI74:
 2103               		.cfi_def_cfa_offset 16
 2104               		.cfi_offset 15, -15
 2105 001c 0F93      		push r16
 2106               	.LCFI75:
 2107               		.cfi_def_cfa_offset 17
 2108               		.cfi_offset 16, -16
 2109 001e 1F93      		push r17
 2110               	.LCFI76:
 2111               		.cfi_def_cfa_offset 18
 2112               		.cfi_offset 17, -17
 2113 0020 CF93      		push r28
 2114               	.LCFI77:
 2115               		.cfi_def_cfa_offset 19
 2116               		.cfi_offset 28, -18
 2117 0022 DF93      		push r29
 2118               	.LCFI78:
 2119               		.cfi_def_cfa_offset 20
 2120               		.cfi_offset 29, -19
 2121 0024 CDB7      		in r28,__SP_L__
 2122 0026 DEB7      		in r29,__SP_H__
 2123               	.LCFI79:
 2124               		.cfi_def_cfa_register 28
 2125 0028 2897      		sbiw r28,8
 2126               	.LCFI80:
 2127               		.cfi_def_cfa_offset 28
 2128 002a 0FB6      		in __tmp_reg__,__SREG__
 2129 002c F894      		cli
 2130 002e DEBF      		out __SP_H__,r29
 2131 0030 0FBE      		out __SREG__,__tmp_reg__
 2132 0032 CDBF      		out __SP_L__,r28
 2133               	/* prologue: function */
 2134               	/* frame size = 8 */
 2135               	/* stack size = 26 */
 2136               	.L__stack_usage = 26
 2137 0034 4A01      		movw r8,r20
 2138 0036 3901      		movw r6,r18
 473:main.c        **** 	int8_t mob;
 2139               		.loc 1 473 2 is_stmt 1 view .LVU487
 474:main.c        **** 	uint8_t tempData[8];
 2140               		.loc 1 474 2 view .LVU488
 475:main.c        **** 	uint16_t avgV = avgVSum/(CMU_COUNT*8), avgT = avgTSum/(CMU_COUNT*8);
 2141               		.loc 1 475 2 view .LVU489
 2142               	.LVL105:
 476:main.c        **** 	
 477:main.c        **** 	tempData[0]	= min_volt >> 8;
 2143               		.loc 1 477 2 view .LVU490
 478:main.c        **** 	tempData[1] = min_volt;
 2144               		.loc 1 478 2 view .LVU491
 477:main.c        **** 	tempData[1] = min_volt;
 2145               		.loc 1 477 14 is_stmt 0 view .LVU492
 2146 0038 F62F      		mov r31,r22
 2147 003a E72F      		mov r30,r23
 2148 003c FA83      		std Y+2,r31
 2149 003e E983      		std Y+1,r30
 479:main.c        **** 	tempData[2]	= max_volt >> 8;
 2150               		.loc 1 479 2 is_stmt 1 view .LVU493
 480:main.c        **** 	tempData[3] = max_volt;
 2151               		.loc 1 480 2 view .LVU494
 479:main.c        **** 	tempData[2]	= max_volt >> 8;
 2152               		.loc 1 479 14 is_stmt 0 view .LVU495
 2153 0040 9827      		eor r25,r24
 2154 0042 8927      		eor r24,r25
 2155               	.LVL106:
 479:main.c        **** 	tempData[2]	= max_volt >> 8;
 2156               		.loc 1 479 14 view .LVU496
 2157 0044 9827      		eor r25,r24
 2158 0046 9C83      		std Y+4,r25
 2159 0048 8B83      		std Y+3,r24
 481:main.c        **** 	tempData[4]	= avgV >> 8;
 2160               		.loc 1 481 2 is_stmt 1 view .LVU497
 482:main.c        **** 	tempData[5] = avgV;
 2161               		.loc 1 482 2 view .LVU498
 475:main.c        **** 	
 2162               		.loc 1 475 25 is_stmt 0 view .LVU499
 2163 004a 88E1      		ldi r24,lo8(24)
 2164 004c 282E      		mov r2,r24
 2165 004e 312C      		mov r3,__zero_reg__
 2166 0050 412C      		mov r4,__zero_reg__
 2167 0052 512C      		mov r5,__zero_reg__
 2168 0054 C801      		movw r24,r16
 2169 0056 B701      		movw r22,r14
 2170               	.LVL107:
 475:main.c        **** 	
 2171               		.loc 1 475 25 view .LVU500
 2172 0058 A201      		movw r20,r4
 2173               	.LVL108:
 475:main.c        **** 	
 2174               		.loc 1 475 25 view .LVU501
 2175 005a 9101      		movw r18,r2
 2176               	.LVL109:
 475:main.c        **** 	
 2177               		.loc 1 475 25 view .LVU502
 2178 005c 0E94 0000 		call __udivmodsi4
 481:main.c        **** 	tempData[4]	= avgV >> 8;
 2179               		.loc 1 481 14 view .LVU503
 2180 0060 3227      		eor r19,r18
 2181 0062 2327      		eor r18,r19
 2182 0064 3227      		eor r19,r18
 2183 0066 3E83      		std Y+6,r19
 2184 0068 2D83      		std Y+5,r18
 483:main.c        **** 	mob = CAN_findFreeTXMOB();
 2185               		.loc 1 483 2 is_stmt 1 view .LVU504
 2186               		.loc 1 483 8 is_stmt 0 view .LVU505
 2187 006a 0E94 0000 		call CAN_findFreeTXMOB
 2188               	.LVL110:
 484:main.c        **** 	CAN_TXMOB(mob, 6, tempData, ((uint32_t)1<<25)|((uint32_t)deviceID<<13)|CC_V_GLOBAL_ID, 0); //trans
 2189               		.loc 1 484 2 is_stmt 1 view .LVU506
 2190               		.loc 1 484 49 is_stmt 0 view .LVU507
 2191 006e 0091 0000 		lds r16,deviceID
 2192 0072 1091 0000 		lds r17,deviceID+1
 2193 0076 30E0      		ldi r19,0
 2194 0078 20E0      		ldi r18,0
 2195               		.loc 1 484 67 view .LVU508
 2196 007a 9DE0      		ldi r25,13
 2197               		1:
 2198 007c 000F      		lsl r16
 2199 007e 111F      		rol r17
 2200 0080 221F      		rol r18
 2201 0082 331F      		rol r19
 2202 0084 9A95      		dec r25
 2203 0086 01F4      		brne 1b
 2204               		.loc 1 484 2 view .LVU509
 2205 0088 0160      		ori r16,1
 2206 008a 3260      		ori r19,2
 2207 008c E12C      		mov r14,__zero_reg__
 2208               	.LVL111:
 2209               		.loc 1 484 2 view .LVU510
 2210 008e AE01      		movw r20,r28
 2211 0090 4F5F      		subi r20,-1
 2212 0092 5F4F      		sbci r21,-1
 2213 0094 66E0      		ldi r22,lo8(6)
 2214 0096 0E94 0000 		call CAN_TXMOB
 2215               	.LVL112:
 485:main.c        **** 	_delay_ms(1);
 2216               		.loc 1 485 2 is_stmt 1 view .LVU511
 2217               	.LBB96:
 2218               	.LBI96:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2219               		.loc 2 166 1 view .LVU512
 2220               	.LBB97:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2221               		.loc 2 168 2 view .LVU513
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2222               		.loc 2 172 2 view .LVU514
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2223               		.loc 2 173 2 view .LVU515
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2224               		.loc 2 174 2 view .LVU516
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2225               		.loc 2 184 3 view .LVU517
 2226               		.loc 2 187 2 view .LVU518
 2227 009a 8FE9      		ldi r24,lo8(3999)
 2228 009c 9FE0      		ldi r25,hi8(3999)
 2229 009e 0197      	1:	sbiw r24,1
 2230 00a0 01F4      		brne 1b
 2231 00a2 00C0      		rjmp .
 2232 00a4 0000      		nop
 2233               	.LVL113:
 2234               		.loc 2 187 2 is_stmt 0 view .LVU519
 2235               	.LBE97:
 2236               	.LBE96:
 486:main.c        **** 	tempData[0]	= min_temp >> 8;
 2237               		.loc 1 486 2 is_stmt 1 view .LVU520
 487:main.c        **** 	tempData[1] = min_temp;
 2238               		.loc 1 487 2 view .LVU521
 486:main.c        **** 	tempData[0]	= min_temp >> 8;
 2239               		.loc 1 486 14 is_stmt 0 view .LVU522
 2240 00a6 7624      		eor r7,r6
 2241 00a8 6724      		eor r6,r7
 2242               	.LVL114:
 486:main.c        **** 	tempData[0]	= min_temp >> 8;
 2243               		.loc 1 486 14 view .LVU523
 2244 00aa 7624      		eor r7,r6
 2245 00ac 7A82      		std Y+2,r7
 2246 00ae 6982      		std Y+1,r6
 488:main.c        **** 	tempData[2]	= max_temp >> 8;
 2247               		.loc 1 488 2 is_stmt 1 view .LVU524
 489:main.c        **** 	tempData[3] = max_temp;
 2248               		.loc 1 489 2 view .LVU525
 488:main.c        **** 	tempData[2]	= max_temp >> 8;
 2249               		.loc 1 488 14 is_stmt 0 view .LVU526
 2250 00b0 9824      		eor r9,r8
 2251 00b2 8924      		eor r8,r9
 2252               	.LVL115:
 488:main.c        **** 	tempData[2]	= max_temp >> 8;
 2253               		.loc 1 488 14 view .LVU527
 2254 00b4 9824      		eor r9,r8
 2255 00b6 9C82      		std Y+4,r9
 2256 00b8 8B82      		std Y+3,r8
 490:main.c        **** 	tempData[4]	= avgT >> 8;
 2257               		.loc 1 490 2 is_stmt 1 view .LVU528
 491:main.c        **** 	tempData[5] = avgT;
 2258               		.loc 1 491 2 view .LVU529
 475:main.c        **** 	
 2259               		.loc 1 475 55 is_stmt 0 view .LVU530
 2260 00ba C601      		movw r24,r12
 2261 00bc B501      		movw r22,r10
 2262 00be A201      		movw r20,r4
 2263 00c0 9101      		movw r18,r2
 2264 00c2 0E94 0000 		call __udivmodsi4
 490:main.c        **** 	tempData[4]	= avgT >> 8;
 2265               		.loc 1 490 14 view .LVU531
 2266 00c6 3227      		eor r19,r18
 2267 00c8 2327      		eor r18,r19
 2268 00ca 3227      		eor r19,r18
 2269 00cc 3E83      		std Y+6,r19
 2270 00ce 2D83      		std Y+5,r18
 492:main.c        **** 	mob = CAN_findFreeTXMOB();
 2271               		.loc 1 492 2 is_stmt 1 view .LVU532
 2272               		.loc 1 492 8 is_stmt 0 view .LVU533
 2273 00d0 0E94 0000 		call CAN_findFreeTXMOB
 2274               	.LVL116:
 493:main.c        **** 	CAN_TXMOB(mob, 6, tempData, ((uint32_t)1<<25)|((uint32_t)deviceID<<13)|CC_T_GLOBAL_ID, 0); //trans
 2275               		.loc 1 493 2 is_stmt 1 view .LVU534
 2276               		.loc 1 493 49 is_stmt 0 view .LVU535
 2277 00d4 0091 0000 		lds r16,deviceID
 2278 00d8 1091 0000 		lds r17,deviceID+1
 2279 00dc 30E0      		ldi r19,0
 2280 00de 20E0      		ldi r18,0
 2281               		.loc 1 493 67 view .LVU536
 2282 00e0 4DE0      		ldi r20,13
 2283               		1:
 2284 00e2 000F      		lsl r16
 2285 00e4 111F      		rol r17
 2286 00e6 221F      		rol r18
 2287 00e8 331F      		rol r19
 2288 00ea 4A95      		dec r20
 2289 00ec 01F4      		brne 1b
 2290               		.loc 1 493 2 view .LVU537
 2291 00ee 0260      		ori r16,2
 2292 00f0 3260      		ori r19,2
 2293 00f2 AE01      		movw r20,r28
 2294 00f4 4F5F      		subi r20,-1
 2295 00f6 5F4F      		sbci r21,-1
 2296 00f8 66E0      		ldi r22,lo8(6)
 2297 00fa 0E94 0000 		call CAN_TXMOB
 2298               	.LVL117:
 494:main.c        **** 	_delay_ms(1);
 2299               		.loc 1 494 2 is_stmt 1 view .LVU538
 2300               	.LBB98:
 2301               	.LBI98:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2302               		.loc 2 166 1 view .LVU539
 2303               	.LBB99:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2304               		.loc 2 168 2 view .LVU540
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2305               		.loc 2 172 2 view .LVU541
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2306               		.loc 2 173 2 view .LVU542
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2307               		.loc 2 174 2 view .LVU543
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2308               		.loc 2 184 3 view .LVU544
 2309               		.loc 2 187 2 view .LVU545
 2310 00fe 8FE9      		ldi r24,lo8(3999)
 2311 0100 9FE0      		ldi r25,hi8(3999)
 2312 0102 0197      	1:	sbiw r24,1
 2313 0104 01F4      		brne 1b
 2314 0106 00C0      		rjmp .
 2315 0108 0000      		nop
 2316               	.LVL118:
 2317               		.loc 2 187 2 is_stmt 0 view .LVU546
 2318               	.LBE99:
 2319               	.LBE98:
 495:main.c        **** 	
 496:main.c        **** 	return 0;
 2320               		.loc 1 496 2 is_stmt 1 view .LVU547
 497:main.c        **** }
 2321               		.loc 1 497 1 is_stmt 0 view .LVU548
 2322 010a 80E0      		ldi r24,0
 2323               	/* epilogue start */
 2324 010c 2896      		adiw r28,8
 2325 010e 0FB6      		in __tmp_reg__,__SREG__
 2326 0110 F894      		cli
 2327 0112 DEBF      		out __SP_H__,r29
 2328 0114 0FBE      		out __SREG__,__tmp_reg__
 2329 0116 CDBF      		out __SP_L__,r28
 2330 0118 DF91      		pop r29
 2331 011a CF91      		pop r28
 2332 011c 1F91      		pop r17
 2333 011e 0F91      		pop r16
 2334 0120 FF90      		pop r15
 2335 0122 EF90      		pop r14
 2336 0124 DF90      		pop r13
 2337 0126 CF90      		pop r12
 2338 0128 BF90      		pop r11
 2339 012a AF90      		pop r10
 2340               	.LVL119:
 2341               		.loc 1 497 1 view .LVU549
 2342 012c 9F90      		pop r9
 2343 012e 8F90      		pop r8
 2344 0130 7F90      		pop r7
 2345 0132 6F90      		pop r6
 2346 0134 5F90      		pop r5
 2347 0136 4F90      		pop r4
 2348 0138 3F90      		pop r3
 2349 013a 2F90      		pop r2
 2350 013c 0895      		ret
 2351               		.cfi_endproc
 2352               	.LFE32:
 2354               		.section	.text.LED_on,"ax",@progbits
 2355               	.global	LED_on
 2357               	LED_on:
 2358               	.LVL120:
 2359               	.LFB33:
 498:main.c        **** void LED_on( uint8_t selection)
 499:main.c        **** {
 2360               		.loc 1 499 1 is_stmt 1 view -0
 2361               		.cfi_startproc
 2362               	/* prologue: function */
 2363               	/* frame size = 0 */
 2364               	/* stack size = 0 */
 2365               	.L__stack_usage = 0
 500:main.c        **** 	switch(selection)
 2366               		.loc 1 500 2 view .LVU551
 2367 0000 8823      		tst r24
 2368 0002 01F0      		breq .L91
 2369 0004 8130      		cpi r24,lo8(1)
 2370 0006 01F0      		breq .L92
 2371 0008 0895      		ret
 2372               	.L91:
 2373               	.LVL121:
 2374               	.LBB102:
 2375               	.LBB103:
 501:main.c        **** 	{
 502:main.c        **** 		case YELLOW_LED:
 503:main.c        **** 			PORTD &= ~(1<<PIND7);
 2376               		.loc 1 503 4 view .LVU552
 2377               		.loc 1 503 10 is_stmt 0 view .LVU553
 2378 000a 5F98      		cbi 0xb,7
 504:main.c        **** 			break;
 2379               		.loc 1 504 4 is_stmt 1 view .LVU554
 2380 000c 0895      		ret
 2381               	.LVL122:
 2382               	.L92:
 2383               		.loc 1 504 4 is_stmt 0 view .LVU555
 2384               	.LBE103:
 2385               	.LBE102:
 505:main.c        **** 		case RED_LED:
 506:main.c        **** 			PORTD &= ~(1<<PIND1);
 2386               		.loc 1 506 4 is_stmt 1 view .LVU556
 2387               		.loc 1 506 10 is_stmt 0 view .LVU557
 2388 000e 5998      		cbi 0xb,1
 507:main.c        **** 			break;
 2389               		.loc 1 507 4 is_stmt 1 view .LVU558
 2390               	/* epilogue start */
 508:main.c        **** 		default:
 509:main.c        **** 			break;
 510:main.c        **** 	}
 511:main.c        **** }
 2391               		.loc 1 511 1 is_stmt 0 view .LVU559
 2392 0010 0895      		ret
 2393               		.cfi_endproc
 2394               	.LFE33:
 2396               		.section	.text.LED_off,"ax",@progbits
 2397               	.global	LED_off
 2399               	LED_off:
 2400               	.LVL123:
 2401               	.LFB34:
 512:main.c        **** void LED_off( uint8_t selection)
 513:main.c        **** {
 2402               		.loc 1 513 1 is_stmt 1 view -0
 2403               		.cfi_startproc
 2404               	/* prologue: function */
 2405               	/* frame size = 0 */
 2406               	/* stack size = 0 */
 2407               	.L__stack_usage = 0
 514:main.c        **** 	switch(selection)
 2408               		.loc 1 514 2 view .LVU561
 2409 0000 8823      		tst r24
 2410 0002 01F0      		breq .L95
 2411 0004 8130      		cpi r24,lo8(1)
 2412 0006 01F0      		breq .L96
 2413 0008 0895      		ret
 2414               	.L95:
 2415               	.LVL124:
 2416               	.LBB106:
 2417               	.LBB107:
 515:main.c        **** 	{
 516:main.c        **** 		case YELLOW_LED:
 517:main.c        **** 			PORTD |= (1<<PIND7);
 2418               		.loc 1 517 4 view .LVU562
 2419               		.loc 1 517 10 is_stmt 0 view .LVU563
 2420 000a 5F9A      		sbi 0xb,7
 518:main.c        **** 			break;
 2421               		.loc 1 518 4 is_stmt 1 view .LVU564
 2422 000c 0895      		ret
 2423               	.LVL125:
 2424               	.L96:
 2425               		.loc 1 518 4 is_stmt 0 view .LVU565
 2426               	.LBE107:
 2427               	.LBE106:
 519:main.c        **** 		case RED_LED:
 520:main.c        **** 			PORTD |= (1<<PIND1);
 2428               		.loc 1 520 4 is_stmt 1 view .LVU566
 2429               		.loc 1 520 10 is_stmt 0 view .LVU567
 2430 000e 599A      		sbi 0xb,1
 521:main.c        **** 			break;
 2431               		.loc 1 521 4 is_stmt 1 view .LVU568
 2432               	/* epilogue start */
 522:main.c        **** 		default:
 523:main.c        **** 			break;
 524:main.c        **** 	}
 525:main.c        **** }
 2433               		.loc 1 525 1 is_stmt 0 view .LVU569
 2434 0010 0895      		ret
 2435               		.cfi_endproc
 2436               	.LFE34:
 2438               		.section	.text.flash_LED,"ax",@progbits
 2439               	.global	flash_LED
 2441               	flash_LED:
 2442               	.LVL126:
 2443               	.LFB35:
 526:main.c        **** void flash_LED(uint8_t number, uint8_t selection, uint8_t duration)
 527:main.c        **** {
 2444               		.loc 1 527 1 is_stmt 1 view -0
 2445               		.cfi_startproc
 2446               	/* prologue: function */
 2447               	/* frame size = 0 */
 2448               	/* stack size = 0 */
 2449               	.L__stack_usage = 0
 528:main.c        **** 	duration = duration/2;
 2450               		.loc 1 528 2 view .LVU571
 2451               		.loc 1 528 11 is_stmt 0 view .LVU572
 2452 0000 4695      		lsr r20
 2453               	.LVL127:
 529:main.c        **** 	if(selection == RED_LED)
 2454               		.loc 1 529 2 is_stmt 1 view .LVU573
 2455               	.LBB108:
 530:main.c        **** 	{
 531:main.c        **** 		for(uint8_t count = 0; count < number ;count++)
 2456               		.loc 1 531 15 is_stmt 0 view .LVU574
 2457 0002 90E0      		ldi r25,0
 2458               	.LBE108:
 529:main.c        **** 	if(selection == RED_LED)
 2459               		.loc 1 529 4 view .LVU575
 2460 0004 6130      		cpi r22,lo8(1)
 2461 0006 01F0      		breq .L99
 2462               	.L100:
 2463               	.LVL128:
 2464               	.LBB117:
 532:main.c        **** 		{
 533:main.c        **** 			PORTD &= ~(1<<PIND1);
 534:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 535:main.c        **** 			{
 536:main.c        **** 				_delay_us(995);
 537:main.c        **** 			}
 538:main.c        **** 			PORTD |= (1<<PIND1);
 539:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 540:main.c        **** 			{
 541:main.c        **** 				_delay_us(995);
 542:main.c        **** 			}
 543:main.c        **** 		}
 544:main.c        **** 	}
 545:main.c        **** 	else
 546:main.c        **** 	{
 547:main.c        **** 		for(uint8_t count = 0;count<number;count++)
 2465               		.loc 1 547 3 discriminator 1 view .LVU576
 2466 0008 9813      		cpse r25,r24
 2467 000a 00C0      		rjmp .L110
 2468               	/* epilogue start */
 2469               	.LBE117:
 548:main.c        **** 		{
 549:main.c        **** 			PORTD &= ~(1<<PIND7);
 550:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 551:main.c        **** 			{
 552:main.c        **** 				_delay_us(995);
 553:main.c        **** 			}
 554:main.c        **** 			PORTD |= (1<<PIND7);
 555:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 556:main.c        **** 			{
 557:main.c        **** 				_delay_us(995);
 558:main.c        **** 			}
 559:main.c        **** 		}
 560:main.c        **** 	}
 561:main.c        **** 
 562:main.c        **** }
 2470               		.loc 1 562 1 view .LVU577
 2471 000c 0895      		ret
 2472               	.LVL129:
 2473               	.L105:
 2474               	.LBB126:
 533:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2475               		.loc 1 533 4 is_stmt 1 view .LVU578
 533:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2476               		.loc 1 533 10 is_stmt 0 view .LVU579
 2477 000e 5998      		cbi 0xb,1
 534:main.c        **** 			{
 2478               		.loc 1 534 4 is_stmt 1 view .LVU580
 2479               	.LBB109:
 534:main.c        **** 			{
 2480               		.loc 1 534 8 view .LVU581
 2481               	.LVL130:
 534:main.c        **** 			{
 2482               		.loc 1 534 16 is_stmt 0 view .LVU582
 2483 0010 20E0      		ldi r18,0
 2484               	.LVL131:
 2485               	.L101:
 534:main.c        **** 			{
 2486               		.loc 1 534 4 discriminator 1 view .LVU583
 2487 0012 2413      		cpse r18,r20
 2488 0014 00C0      		rjmp .L102
 2489               	.LBE109:
 538:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2490               		.loc 1 538 4 is_stmt 1 view .LVU584
 538:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2491               		.loc 1 538 10 is_stmt 0 view .LVU585
 2492 0016 599A      		sbi 0xb,1
 539:main.c        **** 			{
 2493               		.loc 1 539 4 is_stmt 1 view .LVU586
 2494               	.LBB112:
 539:main.c        **** 			{
 2495               		.loc 1 539 8 view .LVU587
 2496               	.LVL132:
 539:main.c        **** 			{
 2497               		.loc 1 539 16 is_stmt 0 view .LVU588
 2498 0018 20E0      		ldi r18,0
 2499               	.LVL133:
 2500               	.L103:
 539:main.c        **** 			{
 2501               		.loc 1 539 4 discriminator 1 view .LVU589
 2502 001a 2413      		cpse r18,r20
 2503 001c 00C0      		rjmp .L104
 2504               	.LBE112:
 531:main.c        **** 		{
 2505               		.loc 1 531 47 discriminator 2 view .LVU590
 2506 001e 9F5F      		subi r25,lo8(-(1))
 2507               	.LVL134:
 2508               	.L99:
 531:main.c        **** 		{
 2509               		.loc 1 531 3 discriminator 1 view .LVU591
 2510 0020 9813      		cpse r25,r24
 2511 0022 00C0      		rjmp .L105
 2512 0024 0895      		ret
 2513               	.LVL135:
 2514               	.L102:
 2515               	.LBB115:
 536:main.c        **** 			}
 2516               		.loc 1 536 5 is_stmt 1 view .LVU592
 2517               	.LBB110:
 2518               	.LBI110:
 188:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_us(double __us)
 2519               		.loc 2 255 1 view .LVU593
 2520               	.LBB111:
 256:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
 2521               		.loc 2 257 2 view .LVU594
 258:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 2522               		.loc 2 261 2 view .LVU595
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2523               		.loc 2 262 2 view .LVU596
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2524               		.loc 2 263 2 view .LVU597
 264:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 2525               		.loc 2 273 3 view .LVU598
 274:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 2526               		.loc 2 276 2 view .LVU599
 2527 0026 EBE8      		ldi r30,lo8(3979)
 2528 0028 FFE0      		ldi r31,hi8(3979)
 2529 002a 3197      	1:	sbiw r30,1
 2530 002c 01F4      		brne 1b
 2531 002e 00C0      		rjmp .
 2532 0030 0000      		nop
 2533               	.LVL136:
 2534               		.loc 2 276 2 is_stmt 0 view .LVU600
 2535               	.LBE111:
 2536               	.LBE110:
 534:main.c        **** 			{
 2537               		.loc 1 534 56 view .LVU601
 2538 0032 2F5F      		subi r18,lo8(-(1))
 2539               	.LVL137:
 534:main.c        **** 			{
 2540               		.loc 1 534 56 view .LVU602
 2541 0034 00C0      		rjmp .L101
 2542               	.LVL138:
 2543               	.L104:
 534:main.c        **** 			{
 2544               		.loc 1 534 56 view .LVU603
 2545               	.LBE115:
 2546               	.LBB116:
 541:main.c        **** 			}
 2547               		.loc 1 541 5 is_stmt 1 view .LVU604
 2548               	.LBB113:
 2549               	.LBI113:
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2550               		.loc 2 255 1 view .LVU605
 2551               	.LBB114:
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2552               		.loc 2 257 2 view .LVU606
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2553               		.loc 2 261 2 view .LVU607
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2554               		.loc 2 262 2 view .LVU608
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2555               		.loc 2 263 2 view .LVU609
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2556               		.loc 2 273 3 view .LVU610
 2557               		.loc 2 276 2 view .LVU611
 2558 0036 EBE8      		ldi r30,lo8(3979)
 2559 0038 FFE0      		ldi r31,hi8(3979)
 2560 003a 3197      	1:	sbiw r30,1
 2561 003c 01F4      		brne 1b
 2562 003e 00C0      		rjmp .
 2563 0040 0000      		nop
 2564               	.LVL139:
 2565               		.loc 2 276 2 is_stmt 0 view .LVU612
 2566               	.LBE114:
 2567               	.LBE113:
 539:main.c        **** 			{
 2568               		.loc 1 539 56 view .LVU613
 2569 0042 2F5F      		subi r18,lo8(-(1))
 2570               	.LVL140:
 539:main.c        **** 			{
 2571               		.loc 1 539 56 view .LVU614
 2572 0044 00C0      		rjmp .L103
 2573               	.LVL141:
 2574               	.L110:
 539:main.c        **** 			{
 2575               		.loc 1 539 56 view .LVU615
 2576               	.LBE116:
 2577               	.LBE126:
 2578               	.LBB127:
 549:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2579               		.loc 1 549 4 is_stmt 1 view .LVU616
 549:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2580               		.loc 1 549 10 is_stmt 0 view .LVU617
 2581 0046 5F98      		cbi 0xb,7
 550:main.c        **** 			{
 2582               		.loc 1 550 4 is_stmt 1 view .LVU618
 2583               	.LBB118:
 550:main.c        **** 			{
 2584               		.loc 1 550 8 view .LVU619
 2585               	.LVL142:
 550:main.c        **** 			{
 2586               		.loc 1 550 16 is_stmt 0 view .LVU620
 2587 0048 20E0      		ldi r18,0
 2588               	.LVL143:
 2589               	.L106:
 550:main.c        **** 			{
 2590               		.loc 1 550 4 discriminator 1 view .LVU621
 2591 004a 2413      		cpse r18,r20
 2592 004c 00C0      		rjmp .L107
 2593               	.LBE118:
 554:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2594               		.loc 1 554 4 is_stmt 1 view .LVU622
 554:main.c        **** 			for(uint8_t counter = 0; counter < duration; counter++)
 2595               		.loc 1 554 10 is_stmt 0 view .LVU623
 2596 004e 5F9A      		sbi 0xb,7
 555:main.c        **** 			{
 2597               		.loc 1 555 4 is_stmt 1 view .LVU624
 2598               	.LBB121:
 555:main.c        **** 			{
 2599               		.loc 1 555 8 view .LVU625
 2600               	.LVL144:
 555:main.c        **** 			{
 2601               		.loc 1 555 16 is_stmt 0 view .LVU626
 2602 0050 20E0      		ldi r18,0
 2603               	.LVL145:
 2604               	.L108:
 555:main.c        **** 			{
 2605               		.loc 1 555 4 discriminator 1 view .LVU627
 2606 0052 2413      		cpse r18,r20
 2607 0054 00C0      		rjmp .L109
 2608               	.LBE121:
 547:main.c        **** 		{
 2609               		.loc 1 547 43 discriminator 2 view .LVU628
 2610 0056 9F5F      		subi r25,lo8(-(1))
 2611               	.LVL146:
 547:main.c        **** 		{
 2612               		.loc 1 547 43 discriminator 2 view .LVU629
 2613 0058 00C0      		rjmp .L100
 2614               	.LVL147:
 2615               	.L107:
 2616               	.LBB124:
 552:main.c        **** 			}
 2617               		.loc 1 552 5 is_stmt 1 view .LVU630
 2618               	.LBB119:
 2619               	.LBI119:
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2620               		.loc 2 255 1 view .LVU631
 2621               	.LBB120:
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2622               		.loc 2 257 2 view .LVU632
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2623               		.loc 2 261 2 view .LVU633
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2624               		.loc 2 262 2 view .LVU634
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2625               		.loc 2 263 2 view .LVU635
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2626               		.loc 2 273 3 view .LVU636
 2627               		.loc 2 276 2 view .LVU637
 2628 005a EBE8      		ldi r30,lo8(3979)
 2629 005c FFE0      		ldi r31,hi8(3979)
 2630 005e 3197      	1:	sbiw r30,1
 2631 0060 01F4      		brne 1b
 2632 0062 00C0      		rjmp .
 2633 0064 0000      		nop
 2634               	.LVL148:
 2635               		.loc 2 276 2 is_stmt 0 view .LVU638
 2636               	.LBE120:
 2637               	.LBE119:
 550:main.c        **** 			{
 2638               		.loc 1 550 56 view .LVU639
 2639 0066 2F5F      		subi r18,lo8(-(1))
 2640               	.LVL149:
 550:main.c        **** 			{
 2641               		.loc 1 550 56 view .LVU640
 2642 0068 00C0      		rjmp .L106
 2643               	.LVL150:
 2644               	.L109:
 550:main.c        **** 			{
 2645               		.loc 1 550 56 view .LVU641
 2646               	.LBE124:
 2647               	.LBB125:
 557:main.c        **** 			}
 2648               		.loc 1 557 5 is_stmt 1 view .LVU642
 2649               	.LBB122:
 2650               	.LBI122:
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2651               		.loc 2 255 1 view .LVU643
 2652               	.LBB123:
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2653               		.loc 2 257 2 view .LVU644
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2654               		.loc 2 261 2 view .LVU645
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 2655               		.loc 2 262 2 view .LVU646
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2656               		.loc 2 263 2 view .LVU647
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2657               		.loc 2 273 3 view .LVU648
 2658               		.loc 2 276 2 view .LVU649
 2659 006a EBE8      		ldi r30,lo8(3979)
 2660 006c FFE0      		ldi r31,hi8(3979)
 2661 006e 3197      	1:	sbiw r30,1
 2662 0070 01F4      		brne 1b
 2663 0072 00C0      		rjmp .
 2664 0074 0000      		nop
 2665               	.LVL151:
 2666               		.loc 2 276 2 is_stmt 0 view .LVU650
 2667               	.LBE123:
 2668               	.LBE122:
 555:main.c        **** 			{
 2669               		.loc 1 555 56 view .LVU651
 2670 0076 2F5F      		subi r18,lo8(-(1))
 2671               	.LVL152:
 555:main.c        **** 			{
 2672               		.loc 1 555 56 view .LVU652
 2673 0078 00C0      		rjmp .L108
 2674               	.LBE125:
 2675               	.LBE127:
 2676               		.cfi_endproc
 2677               	.LFE35:
 2679               		.section	.text.error_state,"ax",@progbits
 2680               	.global	error_state
 2682               	error_state:
 2683               	.LVL153:
 2684               	.LFB36:
 563:main.c        **** 
 564:main.c        **** void error_state(uint8_t code)
 565:main.c        **** {
 2685               		.loc 1 565 1 is_stmt 1 view -0
 2686               		.cfi_startproc
 2687               		.loc 1 565 1 is_stmt 0 view .LVU654
 2688 0000 CF93      		push r28
 2689               	.LCFI81:
 2690               		.cfi_def_cfa_offset 3
 2691               		.cfi_offset 28, -2
 2692 0002 DF93      		push r29
 2693               	.LCFI82:
 2694               		.cfi_def_cfa_offset 4
 2695               		.cfi_offset 29, -3
 2696 0004 0F92      		push __tmp_reg__
 2697               	.LCFI83:
 2698               		.cfi_def_cfa_offset 5
 2699 0006 CDB7      		in r28,__SP_L__
 2700 0008 DEB7      		in r29,__SP_H__
 2701               	.LCFI84:
 2702               		.cfi_def_cfa_register 28
 2703               	/* prologue: function */
 2704               	/* frame size = 1 */
 2705               	/* stack size = 3 */
 2706               	.L__stack_usage = 3
 2707 000a 8983      		std Y+1,r24
 566:main.c        **** 	CMU_Wake_reset();
 2708               		.loc 1 566 2 is_stmt 1 view .LVU655
 2709 000c 0E94 0000 		call CMU_Wake_reset
 2710               	.LVL154:
 567:main.c        **** 	ALARM_PORT &= ~(ALARM_PIN);
 2711               		.loc 1 567 2 view .LVU656
 2712               		.loc 1 567 13 is_stmt 0 view .LVU657
 2713 0010 88B1      		in r24,0x8
 2714 0012 88B9      		out 0x8,r24
 568:main.c        **** 	cli();
 2715               		.loc 1 568 2 is_stmt 1 view .LVU658
 2716               	/* #APP */
 2717               	 ;  568 "main.c" 1
 2718 0014 F894      		cli
 2719               	 ;  0 "" 2
 569:main.c        **** 	while(1)
 570:main.c        **** 	{
 571:main.c        **** 		ALARM_PORT ^= (1<<ALARM_PIN);
 2720               		.loc 1 571 14 is_stmt 0 view .LVU659
 2721               	/* #NOAPP */
 2722 0016 FF24      		clr r15
 2723 0018 F394      		inc r15
 2724               	.L114:
 569:main.c        **** 	while(1)
 2725               		.loc 1 569 2 is_stmt 1 discriminator 1 view .LVU660
 2726               		.loc 1 571 3 discriminator 1 view .LVU661
 2727               		.loc 1 571 14 is_stmt 0 discriminator 1 view .LVU662
 2728 001a 88B1      		in r24,0x8
 2729 001c 8F25      		eor r24,r15
 2730 001e 88B9      		out 0x8,r24
 572:main.c        **** 		CAN_TXMOB(CAN_findFreeTXMOB(), 1, &code, ((uint32_t)1<<25)|((uint32_t)deviceID<<13)|ALARM_MSG,0);
 2731               		.loc 1 572 3 is_stmt 1 discriminator 1 view .LVU663
 2732               		.loc 1 572 63 is_stmt 0 discriminator 1 view .LVU664
 2733 0020 8090 0000 		lds r8,deviceID
 2734 0024 9090 0000 		lds r9,deviceID+1
 2735 0028 B12C      		mov r11,__zero_reg__
 2736 002a A12C      		mov r10,__zero_reg__
 2737               		.loc 1 572 81 discriminator 1 view .LVU665
 2738 002c 8DE0      		ldi r24,13
 2739               		1:
 2740 002e 880C      		lsl r8
 2741 0030 991C      		rol r9
 2742 0032 AA1C      		rol r10
 2743 0034 BB1C      		rol r11
 2744 0036 8A95      		dec r24
 2745 0038 01F4      		brne 1b
 2746               		.loc 1 572 3 discriminator 1 view .LVU666
 2747 003a 83E0      		ldi r24,3
 2748 003c 882A      		or r8,r24
 2749 003e 6894      		set
 2750 0040 B1F8      		bld r11,1
 2751 0042 0E94 0000 		call CAN_findFreeTXMOB
 2752               	.LVL155:
 2753 0046 E12C      		mov r14,__zero_reg__
 2754 0048 9501      		movw r18,r10
 2755 004a 8401      		movw r16,r8
 2756 004c AE01      		movw r20,r28
 2757 004e 4F5F      		subi r20,-1
 2758 0050 5F4F      		sbci r21,-1
 2759 0052 61E0      		ldi r22,lo8(1)
 2760 0054 0E94 0000 		call CAN_TXMOB
 2761               	.LVL156:
 573:main.c        **** 		flash_LED(2,YELLOW_LED,100);
 2762               		.loc 1 573 3 is_stmt 1 discriminator 1 view .LVU667
 2763 0058 44E6      		ldi r20,lo8(100)
 2764 005a 60E0      		ldi r22,0
 2765 005c 82E0      		ldi r24,lo8(2)
 2766 005e 0E94 0000 		call flash_LED
 2767               	.LVL157:
 574:main.c        **** 		flash_LED(2,RED_LED,100);
 2768               		.loc 1 574 3 discriminator 1 view .LVU668
 2769 0062 44E6      		ldi r20,lo8(100)
 2770 0064 61E0      		ldi r22,lo8(1)
 2771 0066 82E0      		ldi r24,lo8(2)
 2772 0068 0E94 0000 		call flash_LED
 2773               	.LVL158:
 2774 006c 00C0      		rjmp .L114
 2775               		.cfi_endproc
 2776               	.LFE36:
 2778               		.section	.text.CMU_process_inbound_message,"ax",@progbits
 2779               	.global	CMU_process_inbound_message
 2781               	CMU_process_inbound_message:
 2782               	.LVL159:
 2783               	.LFB21:
 167:main.c        **** 	//potential for optimisation here
 2784               		.loc 1 167 1 view -0
 2785               		.cfi_startproc
 167:main.c        **** 	//potential for optimisation here
 2786               		.loc 1 167 1 is_stmt 0 view .LVU670
 2787 0000 EF92      		push r14
 2788               	.LCFI85:
 2789               		.cfi_def_cfa_offset 3
 2790               		.cfi_offset 14, -2
 2791 0002 FF92      		push r15
 2792               	.LCFI86:
 2793               		.cfi_def_cfa_offset 4
 2794               		.cfi_offset 15, -3
 2795 0004 1F93      		push r17
 2796               	.LCFI87:
 2797               		.cfi_def_cfa_offset 5
 2798               		.cfi_offset 17, -4
 2799 0006 CF93      		push r28
 2800               	.LCFI88:
 2801               		.cfi_def_cfa_offset 6
 2802               		.cfi_offset 28, -5
 2803 0008 DF93      		push r29
 2804               	.LCFI89:
 2805               		.cfi_def_cfa_offset 7
 2806               		.cfi_offset 29, -6
 2807               	/* prologue: function */
 2808               	/* frame size = 0 */
 2809               	/* stack size = 5 */
 2810               	.L__stack_usage = 5
 2811 000a 182F      		mov r17,r24
 2812 000c 7B01      		movw r14,r22
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2813               		.loc 1 170 2 is_stmt 1 view .LVU671
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2814               		.loc 1 170 24 is_stmt 0 view .LVU672
 2815 000e 81E0      		ldi r24,lo8(1)
 2816               	.LVL160:
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2817               		.loc 1 170 24 view .LVU673
 2818 0010 810F      		add r24,r17
 2819 0012 0E94 0000 		call MCP2515_reg_read
 2820               	.LVL161:
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2821               		.loc 1 170 24 view .LVU674
 2822 0016 C82F      		mov r28,r24
 171:main.c        ****     //message type is held in the 5 LSBs of EID0	
 2823               		.loc 1 171 27 view .LVU675
 2824 0018 82E0      		ldi r24,lo8(2)
 2825 001a 810F      		add r24,r17
 2826 001c 0E94 0000 		call MCP2515_reg_read
 2827               	.LVL162:
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2828               		.loc 1 170 66 view .LVU676
 2829 0020 98E0      		ldi r25,lo8(8)
 2830 0022 C99F      		mul r28,r25
 2831 0024 E001      		movw r28,r0
 2832 0026 1124      		clr __zero_reg__
 2833 0028 C87F      		andi r28,248
 2834 002a D170      		andi r29,1
 171:main.c        ****     //message type is held in the 5 LSBs of EID0	
 2835               		.loc 1 171 69 view .LVU677
 2836 002c 90E0      		ldi r25,0
 2837 002e 25E0      		ldi r18,5
 2838               		1:
 2839 0030 9595      		asr r25
 2840 0032 8795      		ror r24
 2841 0034 2A95      		dec r18
 2842 0036 01F4      		brne 1b
 170:main.c        ****                         ((MCP2515_reg_read(rx_buf_address+2) & 0xE0)>>5) );
 2843               		.loc 1 170 70 view .LVU678
 2844 0038 C82B      		or r28,r24
 2845 003a D92B      		or r29,r25
 2846               	.LVL163:
 173:main.c        **** 
 2847               		.loc 1 173 2 is_stmt 1 view .LVU679
 173:main.c        **** 
 2848               		.loc 1 173 26 is_stmt 0 view .LVU680
 2849 003c 84E0      		ldi r24,lo8(4)
 2850 003e 810F      		add r24,r17
 2851 0040 0E94 0000 		call MCP2515_reg_read
 2852               	.LVL164:
 173:main.c        **** 
 2853               		.loc 1 173 10 view .LVU681
 2854 0044 8F71      		andi r24,lo8(31)
 2855               	.LVL165:
 175:main.c        **** 	{
 2856               		.loc 1 175 2 is_stmt 1 view .LVU682
 2857 0046 8430      		cpi r24,lo8(4)
 2858 0048 01F0      		breq .L116
 2859 004a 00F4      		brsh .L117
 2860 004c 8130      		cpi r24,lo8(1)
 2861 004e 01F0      		breq .L118
 207:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2862               		.loc 1 207 8 is_stmt 0 view .LVU683
 2863 0050 212F      		mov r18,r17
 2864 0052 42E0      		ldi r20,lo8(2)
 2865 0054 8230      		cpi r24,lo8(2)
 2866 0056 01F0      		breq .L139
 2867               	.LVL166:
 2868               	.L115:
 2869               	/* epilogue start */
 213:main.c        **** 
 2870               		.loc 1 213 1 view .LVU684
 2871 0058 DF91      		pop r29
 2872 005a CF91      		pop r28
 2873               	.LVL167:
 213:main.c        **** 
 2874               		.loc 1 213 1 view .LVU685
 2875 005c 1F91      		pop r17
 2876               	.LVL168:
 213:main.c        **** 
 2877               		.loc 1 213 1 view .LVU686
 2878 005e FF90      		pop r15
 2879 0060 EF90      		pop r14
 2880               	.LVL169:
 213:main.c        **** 
 2881               		.loc 1 213 1 view .LVU687
 2882 0062 0895      		ret
 2883               	.LVL170:
 2884               	.L117:
 213:main.c        **** 
 2885               		.loc 1 213 1 view .LVU688
 2886 0064 8530      		cpi r24,lo8(5)
 2887 0066 01F0      		breq .L121
 2888 0068 8331      		cpi r24,lo8(19)
 2889 006a 01F4      		brne .L115
 180:main.c        **** 			{
 2890               		.loc 1 180 4 is_stmt 1 view .LVU689
 2891               	.LVL171:
 2892               	.LBB128:
 2893               	.LBI128:
 295:main.c        **** {
 2894               		.loc 1 295 9 view .LVU690
 2895               	.LBB129:
 297:main.c        **** 	{
 2896               		.loc 1 297 2 view .LVU691
 2897               	.LBE129:
 2898               	.LBE128:
 297:main.c        **** 	{
 2899               		.loc 1 297 6 view .LVU692
 2900               	.LBB131:
 2901               	.LBB130:
 297:main.c        **** 	{
 2902               		.loc 1 297 6 is_stmt 0 view .LVU693
 2903 006c BE01      		movw r22,r28
 2904 006e C701      		movw r24,r14
 2905               	.LVL172:
 297:main.c        **** 	{
 2906               		.loc 1 297 6 view .LVU694
 2907 0070 0E94 0000 		call CMU_Register.part.0
 2908               	.LVL173:
 297:main.c        **** 	{
 2909               		.loc 1 297 6 view .LVU695
 2910 0074 8130      		cpi r24,lo8(1)
 2911 0076 01F0      		breq .L122
 2912 0078 8230      		cpi r24,lo8(2)
 2913 007a 01F4      		brne .L115
 2914               	.LBE130:
 2915               	.LBE131:
 188:main.c        **** 					break;
 2916               		.loc 1 188 6 is_stmt 1 view .LVU696
 2917 007c 83E0      		ldi r24,lo8(3)
 2918 007e 00C0      		rjmp .L142
 2919               	.L122:
 185:main.c        **** 					break;
 2920               		.loc 1 185 6 view .LVU697
 2921 0080 82E0      		ldi r24,lo8(2)
 2922               	.LVL174:
 2923               	.L142:
 188:main.c        **** 					break;
 2924               		.loc 1 188 6 is_stmt 0 view .LVU698
 2925 0082 0E94 0000 		call error_state
 2926               	.LVL175:
 2927               	.L116:
 195:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2928               		.loc 1 195 4 is_stmt 1 view .LVU699
 195:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2929               		.loc 1 195 8 is_stmt 0 view .LVU700
 2930 0086 212F      		mov r18,r17
 2931 0088 44E0      		ldi r20,lo8(4)
 2932               	.L139:
 195:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2933               		.loc 1 195 8 view .LVU701
 2934 008a 6C2F      		mov r22,r28
 2935 008c C701      		movw r24,r14
 2936               	.LVL176:
 195:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2937               		.loc 1 195 8 view .LVU702
 2938 008e 0E94 0000 		call CMU_Store_Data
 2939               	.LVL177:
 195:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2940               		.loc 1 195 6 view .LVU703
 2941 0092 8111      		cpse r24,__zero_reg__
 2942 0094 00C0      		rjmp .L115
 196:main.c        **** 			break;
 2943               		.loc 1 196 10 is_stmt 1 view .LVU704
 2944 0096 86E0      		ldi r24,lo8(6)
 2945 0098 00C0      		rjmp .L142
 2946               	.LVL178:
 2947               	.L121:
 199:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2948               		.loc 1 199 4 view .LVU705
 199:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2949               		.loc 1 199 8 is_stmt 0 view .LVU706
 2950 009a 212F      		mov r18,r17
 2951 009c 45E0      		ldi r20,lo8(5)
 2952 009e 00C0      		rjmp .L139
 2953               	.L118:
 203:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2954               		.loc 1 203 4 is_stmt 1 view .LVU707
 203:main.c        **** 			    { error_state(ERROR_UNKNOWN_CMU_ID); } // Fails if the CMU ID is not known 
 2955               		.loc 1 203 8 is_stmt 0 view .LVU708
 2956 00a0 212F      		mov r18,r17
 2957 00a2 41E0      		ldi r20,lo8(1)
 2958 00a4 00C0      		rjmp .L139
 2959               		.cfi_endproc
 2960               	.LFE21:
 2962               		.section	.text.CMU_PollandProcess_RxBuffers,"ax",@progbits
 2963               	.global	CMU_PollandProcess_RxBuffers
 2965               	CMU_PollandProcess_RxBuffers:
 2966               	.LVL179:
 2967               	.LFB23:
 235:main.c        **** 	
 2968               		.loc 1 235 1 is_stmt 1 view -0
 2969               		.cfi_startproc
 235:main.c        **** 	
 2970               		.loc 1 235 1 is_stmt 0 view .LVU710
 2971 0000 CF93      		push r28
 2972               	.LCFI90:
 2973               		.cfi_def_cfa_offset 3
 2974               		.cfi_offset 28, -2
 2975 0002 DF93      		push r29
 2976               	.LCFI91:
 2977               		.cfi_def_cfa_offset 4
 2978               		.cfi_offset 29, -3
 2979               	/* prologue: function */
 2980               	/* frame size = 0 */
 2981               	/* stack size = 2 */
 2982               	.L__stack_usage = 2
 2983 0004 EC01      		movw r28,r24
 238:main.c        **** 	switch(status)
 2984               		.loc 1 238 2 is_stmt 1 view .LVU711
 238:main.c        **** 	switch(status)
 2985               		.loc 1 238 20 is_stmt 0 view .LVU712
 2986 0006 0E94 0000 		call MCP2515_receive_status
 2987               	.LVL180:
 238:main.c        **** 	switch(status)
 2988               		.loc 1 238 10 view .LVU713
 2989 000a 8370      		andi r24,lo8(3)
 2990               	.LVL181:
 239:main.c        **** 	{
 2991               		.loc 1 239 2 is_stmt 1 view .LVU714
 2992 000c 8230      		cpi r24,lo8(2)
 2993 000e 01F0      		breq .L144
 2994 0010 8330      		cpi r24,lo8(3)
 2995 0012 01F0      		breq .L145
 2996 0014 8130      		cpi r24,lo8(1)
 2997 0016 01F4      		brne .L143
 244:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);				//e.g if status is 0b00000001, it will only
 2998               		.loc 1 244 4 view .LVU715
 2999 0018 BE01      		movw r22,r28
 3000 001a 80E6      		ldi r24,lo8(96)
 3001               	.LVL182:
 244:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);				//e.g if status is 0b00000001, it will only
 3002               		.loc 1 244 4 is_stmt 0 view .LVU716
 3003 001c 0E94 0000 		call CMU_process_inbound_message
 3004               	.LVL183:
 245:main.c        **** 			break;
 3005               		.loc 1 245 4 is_stmt 1 view .LVU717
 3006 0020 41E0      		ldi r20,lo8(1)
 3007               	.L147:
 254:main.c        **** 			break;
 3008               		.loc 1 254 4 is_stmt 0 view .LVU718
 3009 0022 60E0      		ldi r22,0
 3010 0024 8CE2      		ldi r24,lo8(44)
 3011               	/* epilogue start */
 260:main.c        **** 
 3012               		.loc 1 260 1 view .LVU719
 3013 0026 DF91      		pop r29
 3014 0028 CF91      		pop r28
 3015               	.LVL184:
 254:main.c        **** 			break;
 3016               		.loc 1 254 4 view .LVU720
 3017 002a 0C94 0000 		jmp MCP2515_bit_modify
 3018               	.LVL185:
 3019               	.L144:
 248:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);
 3020               		.loc 1 248 4 is_stmt 1 view .LVU721
 3021 002e BE01      		movw r22,r28
 3022 0030 80E7      		ldi r24,lo8(112)
 3023               	.LVL186:
 248:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);
 3024               		.loc 1 248 4 is_stmt 0 view .LVU722
 3025 0032 0E94 0000 		call CMU_process_inbound_message
 3026               	.LVL187:
 249:main.c        **** 			break;
 3027               		.loc 1 249 4 is_stmt 1 view .LVU723
 3028 0036 42E0      		ldi r20,lo8(2)
 3029 0038 00C0      		rjmp .L147
 3030               	.LVL188:
 3031               	.L145:
 252:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB0, cmu);
 3032               		.loc 1 252 4 view .LVU724
 3033 003a BE01      		movw r22,r28
 3034 003c 80E7      		ldi r24,lo8(112)
 3035               	.LVL189:
 252:main.c        **** 			CMU_process_inbound_message(MCP2515_RXB0, cmu);
 3036               		.loc 1 252 4 is_stmt 0 view .LVU725
 3037 003e 0E94 0000 		call CMU_process_inbound_message
 3038               	.LVL190:
 253:main.c        **** 			MCP2515_bit_modify(MCP2515_CANINTF,0x00, status);
 3039               		.loc 1 253 4 is_stmt 1 view .LVU726
 3040 0042 BE01      		movw r22,r28
 3041 0044 80E6      		ldi r24,lo8(96)
 3042 0046 0E94 0000 		call CMU_process_inbound_message
 3043               	.LVL191:
 254:main.c        **** 			break;
 3044               		.loc 1 254 4 view .LVU727
 3045 004a 43E0      		ldi r20,lo8(3)
 3046 004c 00C0      		rjmp .L147
 3047               	.LVL192:
 3048               	.L143:
 3049               	/* epilogue start */
 260:main.c        **** 
 3050               		.loc 1 260 1 is_stmt 0 view .LVU728
 3051 004e DF91      		pop r29
 3052 0050 CF91      		pop r28
 3053               	.LVL193:
 260:main.c        **** 
 3054               		.loc 1 260 1 view .LVU729
 3055 0052 0895      		ret
 3056               		.cfi_endproc
 3057               	.LFE23:
 3059               		.section	.rodata
 3060               	.LC0:
 3061 0000 0E        		.byte	14
 3062 0001 74        		.byte	116
 3063 0002 2D        		.byte	45
 3064 0003 00        		.byte	0
 3065 0004 00        		.byte	0
 3066               		.section	.text.startup.main,"ax",@progbits
 3067               	.global	main
 3069               	main:
 3070               	.LFB37:
 575:main.c        **** 	}
 576:main.c        **** }
 577:main.c        **** 
 578:main.c        **** int main(void)
 579:main.c        **** {
 3071               		.loc 1 579 1 is_stmt 1 view -0
 3072               		.cfi_startproc
 3073 0000 CDB7      		in r28,__SP_L__
 3074 0002 DEB7      		in r29,__SP_H__
 3075               	.LCFI92:
 3076               		.cfi_def_cfa_register 28
 3077 0004 6897      		sbiw r28,24
 3078               	.LCFI93:
 3079               		.cfi_def_cfa_offset 26
 3080 0006 0FB6      		in __tmp_reg__,__SREG__
 3081 0008 F894      		cli
 3082 000a DEBF      		out __SP_H__,r29
 3083 000c 0FBE      		out __SREG__,__tmp_reg__
 3084 000e CDBF      		out __SP_L__,r28
 3085               	/* prologue: function */
 3086               	/* frame size = 24 */
 3087               	/* stack size = 24 */
 3088               	.L__stack_usage = 24
 580:main.c        **** 	AMU_eeprom_write(EEPROM_FW_VERSION, 1002);
 3089               		.loc 1 580 2 view .LVU731
 3090 0010 6AEE      		ldi r22,lo8(-22)
 3091 0012 73E0      		ldi r23,lo8(3)
 3092 0014 82E0      		ldi r24,lo8(2)
 3093 0016 90E0      		ldi r25,0
 3094 0018 0E94 0000 		call AMU_eeprom_write
 3095               	.LVL194:
 581:main.c        **** 	AMU_eeprom_write(EEPROM_DEVICE_ID, 2);
 3096               		.loc 1 581 2 view .LVU732
 3097 001c 62E0      		ldi r22,lo8(2)
 3098 001e 70E0      		ldi r23,0
 3099 0020 90E0      		ldi r25,0
 3100 0022 80E0      		ldi r24,0
 3101 0024 0E94 0000 		call AMU_eeprom_write
 3102               	.LVL195:
 582:main.c        **** 	
 583:main.c        **** 	_delay_ms(10);
 3103               		.loc 1 583 2 view .LVU733
 3104               	.LBB157:
 3105               	.LBI157:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3106               		.loc 2 166 1 view .LVU734
 3107               	.LBB158:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3108               		.loc 2 168 2 view .LVU735
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3109               		.loc 2 172 2 view .LVU736
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3110               		.loc 2 173 2 view .LVU737
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3111               		.loc 2 174 2 view .LVU738
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3112               		.loc 2 184 3 view .LVU739
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3113               		.loc 2 187 2 view .LVU740
 3114 0028 8FE3      		ldi r24,lo8(-25537)
 3115 002a 9CE9      		ldi r25,hi8(-25537)
 3116 002c 0197      	1:	sbiw r24,1
 3117 002e 01F4      		brne 1b
 3118 0030 00C0      		rjmp .
 3119 0032 0000      		nop
 3120               	.LVL196:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3121               		.loc 2 187 2 is_stmt 0 view .LVU741
 3122               	.LBE158:
 3123               	.LBE157:
 584:main.c        **** 	IO_init();
 3124               		.loc 1 584 2 is_stmt 1 view .LVU742
 3125 0034 0E94 0000 		call IO_init
 3126               	.LVL197:
 585:main.c        **** 	Parameters_init();
 3127               		.loc 1 585 2 view .LVU743
 3128 0038 0E94 0000 		call Parameters_init
 3129               	.LVL198:
 586:main.c        **** 	CMU_Wake_reset();
 3130               		.loc 1 586 2 view .LVU744
 3131 003c 0E94 0000 		call CMU_Wake_reset
 3132               	.LVL199:
 587:main.c        **** 	_delay_ms(50);
 3133               		.loc 1 587 2 view .LVU745
 3134               	.LBB159:
 3135               	.LBI159:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3136               		.loc 2 166 1 view .LVU746
 3137               	.LBB160:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3138               		.loc 2 168 2 view .LVU747
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3139               		.loc 2 172 2 view .LVU748
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3140               		.loc 2 173 2 view .LVU749
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3141               		.loc 2 174 2 view .LVU750
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3142               		.loc 2 184 3 view .LVU751
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3143               		.loc 2 187 2 view .LVU752
 3144 0040 9FEF      		ldi r25,lo8(159999)
 3145 0042 20E7      		ldi r18,hi8(159999)
 3146 0044 32E0      		ldi r19,hlo8(159999)
 3147 0046 9150      	1:	subi r25,1
 3148 0048 2040      		sbci r18,0
 3149 004a 3040      		sbci r19,0
 3150 004c 01F4      		brne 1b
 3151 004e 00C0      		rjmp .
 3152 0050 0000      		nop
 3153               	.LVL200:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3154               		.loc 2 187 2 is_stmt 0 view .LVU753
 3155               	.LBE160:
 3156               	.LBE159:
 588:main.c        **** 	SPI_init();
 3157               		.loc 1 588 2 is_stmt 1 view .LVU754
 3158 0052 0E94 0000 		call SPI_init
 3159               	.LVL201:
 589:main.c        **** 	init_cmuData(cmuData); //initialise our struct(s) with valid null data.
 3160               		.loc 1 589 2 view .LVU755
 3161 0056 80E0      		ldi r24,lo8(cmuData)
 3162 0058 90E0      		ldi r25,hi8(cmuData)
 3163 005a 0E94 0000 		call init_cmuData
 3164               	.LVL202:
 590:main.c        **** 	CAN_init();	//enable this for AVR CAN
 3165               		.loc 1 590 2 view .LVU756
 3166 005e 0E94 0000 		call CAN_init
 3167               	.LVL203:
 591:main.c        **** 	MCP2515_init();
 3168               		.loc 1 591 2 view .LVU757
 3169 0062 0E94 0000 		call MCP2515_init
 3170               	.LVL204:
 592:main.c        **** 	PCINT_init();
 3171               		.loc 1 592 2 view .LVU758
 3172 0066 0E94 0000 		call PCINT_init
 3173               	.LVL205:
 593:main.c        **** 	timer_init();
 3174               		.loc 1 593 2 view .LVU759
 3175 006a 0E94 0000 		call timer_init
 3176               	.LVL206:
 594:main.c        **** 	CAN_RXInit(5, 4, 0, 0);
 3177               		.loc 1 594 2 view .LVU760
 3178 006e E12C      		mov r14,__zero_reg__
 3179 0070 F12C      		mov r15,__zero_reg__
 3180 0072 8701      		movw r16,r14
 3181 0074 20E0      		ldi r18,0
 3182 0076 30E0      		ldi r19,0
 3183 0078 A901      		movw r20,r18
 3184 007a 64E0      		ldi r22,lo8(4)
 3185 007c 85E0      		ldi r24,lo8(5)
 3186 007e 0E94 0000 		call CAN_RXInit
 3187               	.LVL207:
 595:main.c        ****     //mark the transmit buffer as free. seems hacky, but the first interrupt never actually sets, s
 596:main.c        **** 	MCP2515_reg_write(MCP2515_CANINTF, 0b00000000);		
 3188               		.loc 1 596 2 view .LVU761
 3189 0082 60E0      		ldi r22,0
 3190 0084 8CE2      		ldi r24,lo8(44)
 3191 0086 0E94 0000 		call MCP2515_reg_write
 3192               	.LVL208:
 597:main.c        **** 	sei();
 3193               		.loc 1 597 2 view .LVU762
 3194               	/* #APP */
 3195               	 ;  597 "main.c" 1
 3196 008a 7894      		sei
 3197               	 ;  0 "" 2
 598:main.c        **** 	CMUAudit = 0;
 3198               		.loc 1 598 2 view .LVU763
 3199               		.loc 1 598 11 is_stmt 0 view .LVU764
 3200               	/* #NOAPP */
 3201 008c 1092 0000 		sts CMUAudit,__zero_reg__
 599:main.c        **** 
 600:main.c        **** 	uint8_t status = 0; 
 3202               		.loc 1 600 2 is_stmt 1 view .LVU765
 3203               		.loc 1 600 10 is_stmt 0 view .LVU766
 3204 0090 1A8A      		std Y+18,__zero_reg__
 601:main.c        **** 	MCP2515_FilterInit(0, AUDIT_RESPONSE); //setup the filter to receive audit responses
 3205               		.loc 1 601 2 is_stmt 1 view .LVU767
 3206 0092 43E1      		ldi r20,lo8(19)
 3207 0094 50E0      		ldi r21,0
 3208 0096 60E0      		ldi r22,0
 3209 0098 70E0      		ldi r23,0
 3210 009a 80E0      		ldi r24,0
 3211 009c 0E94 0000 		call MCP2515_FilterInit
 3212               	.LVL209:
 602:main.c        **** 	MCP2515_RXInit(0, 0); //setup the buffer to match to the packet type bits
 3213               		.loc 1 602 2 view .LVU768
 3214 00a0 40E0      		ldi r20,0
 3215 00a2 50E0      		ldi r21,0
 3216 00a4 BA01      		movw r22,r20
 3217 00a6 80E0      		ldi r24,0
 3218 00a8 0E94 0000 		call MCP2515_RXInit
 3219               	.LVL210:
 603:main.c        **** 	_delay_ms(50);
 3220               		.loc 1 603 2 view .LVU769
 3221               	.LBB161:
 3222               	.LBI161:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3223               		.loc 2 166 1 view .LVU770
 3224               	.LBB162:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3225               		.loc 2 168 2 view .LVU771
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3226               		.loc 2 172 2 view .LVU772
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3227               		.loc 2 173 2 view .LVU773
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3228               		.loc 2 174 2 view .LVU774
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3229               		.loc 2 184 3 view .LVU775
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3230               		.loc 2 187 2 view .LVU776
 3231 00ac 8FEF      		ldi r24,lo8(159999)
 3232 00ae 90E7      		ldi r25,hi8(159999)
 3233 00b0 22E0      		ldi r18,hlo8(159999)
 3234 00b2 8150      	1:	subi r24,1
 3235 00b4 9040      		sbci r25,0
 3236 00b6 2040      		sbci r18,0
 3237 00b8 01F4      		brne 1b
 3238 00ba 00C0      		rjmp .
 3239 00bc 0000      		nop
 3240               	.LVL211:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3241               		.loc 2 187 2 is_stmt 0 view .LVU777
 3242               	.LBE162:
 3243               	.LBE161:
 604:main.c        **** 	CMU_Wake_set();
 3244               		.loc 1 604 2 is_stmt 1 view .LVU778
 3245 00be 0E94 0000 		call CMU_Wake_set
 3246               	.LVL212:
 605:main.c        **** 	LED_on(RED_LED);
 3247               		.loc 1 605 2 view .LVU779
 3248 00c2 81E0      		ldi r24,lo8(1)
 3249 00c4 0E94 0000 		call LED_on
 3250               	.LVL213:
 606:main.c        **** 	HEARTBEATCOUNTER = 0;
 3251               		.loc 1 606 2 view .LVU780
 3252               		.loc 1 606 19 is_stmt 0 view .LVU781
 3253 00c8 1ABA      		out 0x1a,__zero_reg__
 607:main.c        **** 	CMU_WAKE_TIMER = 0;
 3254               		.loc 1 607 2 is_stmt 1 view .LVU782
 3255               		.loc 1 607 17 is_stmt 0 view .LVU783
 3256 00ca 19BA      		out 0x19,__zero_reg__
 608:main.c        ****     //if the number of registered CMU does not match the required number
 609:main.c        **** 	while(CMUAudit != CMU_COUNT)
 3257               		.loc 1 609 2 is_stmt 1 view .LVU784
 3258               	.L151:
 3259               		.loc 1 609 7 is_stmt 0 view .LVU785
 3260 00cc 8091 0000 		lds r24,CMUAudit
 3261 00d0 8330      		cpi r24,lo8(3)
 3262 00d2 01F0      		breq .+2
 3263 00d4 00C0      		rjmp .L153
 610:main.c        **** 	{
 611:main.c        **** 		flash_LED(1,YELLOW_LED,50);
 612:main.c        ****         //the &status is just dummy data so in case the function is written wrong, no harm should c
 613:main.c        **** 		MCP2515_TX(MCP2515_findFreeTxBuffer(), 0, &status, ((uint32_t)1<<27)|((uint32_t)DEVICE_ID<<18)|AU
 614:main.c        **** 		_delay_ms(5);
 615:main.c        ****         // If the time the checking for the CMU responses are over 1 second
 616:main.c        **** 		if(CMU_WAKE_TIMER > TIM_1_SEC)error_state(ERROR_CMU_TIMEOUT);
 617:main.c        **** 		if(STATUS_REG & MCP2515_DataWaiting)
 618:main.c        **** 		{
 619:main.c        **** 			status = MCP2515_reg_read(MCP2515_CANINTF);
 620:main.c        **** 			if(status & 3)
 621:main.c        **** 			{
 622:main.c        ****                 //if the program has indicated there is data waiting on the MCP2515, process this d
 623:main.c        **** 				CMU_PollandProcess_RxBuffers(cmuData);
 624:main.c        **** 			}
 625:main.c        **** 			STATUS_REG &= ~(MCP2515_DataWaiting);
 626:main.c        **** 			MCP2515_reg_write(MCP2515_CANINTF, 0b00000000);
 627:main.c        **** 		}
 628:main.c        **** 	}
 629:main.c        **** 	
 630:main.c        **** 	LED_off(RED_LED);
 3264               		.loc 1 630 2 is_stmt 1 view .LVU786
 3265 00d6 81E0      		ldi r24,lo8(1)
 3266 00d8 0E94 0000 		call LED_off
 3267               	.LVL214:
 631:main.c        **** 	CMU_Wake_reset();
 3268               		.loc 1 631 2 view .LVU787
 3269 00dc 0E94 0000 		call CMU_Wake_reset
 3270               	.LVL215:
 632:main.c        **** 	flash_LED(2,YELLOW_LED,200);
 3271               		.loc 1 632 2 view .LVU788
 3272 00e0 48EC      		ldi r20,lo8(-56)
 3273 00e2 60E0      		ldi r22,0
 3274 00e4 82E0      		ldi r24,lo8(2)
 3275 00e6 0E94 0000 		call flash_LED
 3276               	.LVL216:
 633:main.c        **** 	_delay_ms(500);
 3277               		.loc 1 633 2 view .LVU789
 3278               	.LBB163:
 3279               	.LBI163:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3280               		.loc 2 166 1 view .LVU790
 3281               	.LBB164:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3282               		.loc 2 168 2 view .LVU791
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3283               		.loc 2 172 2 view .LVU792
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3284               		.loc 2 173 2 view .LVU793
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3285               		.loc 2 174 2 view .LVU794
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3286               		.loc 2 184 3 view .LVU795
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3287               		.loc 2 187 2 view .LVU796
 3288 00ea 9FEF      		ldi r25,lo8(1599999)
 3289 00ec 29E6      		ldi r18,hi8(1599999)
 3290 00ee 38E1      		ldi r19,hlo8(1599999)
 3291 00f0 9150      	1:	subi r25,1
 3292 00f2 2040      		sbci r18,0
 3293 00f4 3040      		sbci r19,0
 3294 00f6 01F4      		brne 1b
 3295 00f8 00C0      		rjmp .
 3296 00fa 0000      		nop
 3297               	.L154:
 3298               	.LBE164:
 3299               	.LBE163:
 634:main.c        **** 	
 635:main.c        **** 	//MCP2515_FilterInit(0, 0);
 636:main.c        **** 	//MCP2515_FilterInit(1, 0);
 637:main.c        **** 	//MCP2515_RXInit(0, 0);	//setup the buffer to match to the packet type bits
 638:main.c        **** 	//MCP2515_RXInit(1, 0);	//setup the buffer to match to the packet type bits
 639:main.c        **** 	
 640:main.c        **** 	while(!(STATUS_REG & MODE_HEARTBEATRECVD));
 3300               		.loc 1 640 44 discriminator 1 view .LVU797
 3301               		.loc 1 640 7 is_stmt 0 discriminator 1 view .LVU798
 3302 00fc F29B      		sbis 0x1e,2
 3303 00fe 00C0      		rjmp .L154
 641:main.c        **** 	CMUTimeToScan = 1;
 3304               		.loc 1 641 2 is_stmt 1 view .LVU799
 3305               		.loc 1 641 16 is_stmt 0 view .LVU800
 3306 0100 81E0      		ldi r24,lo8(1)
 3307 0102 8093 0000 		sts CMUTimeToScan,r24
 3308               	.LBB165:
 642:main.c        **** 	
 643:main.c        ****     // Loop forever
 644:main.c        ****     while(1)
 645:main.c        ****     {
 646:main.c        **** 		if(STATUS_REG & MODE_BALANCING)
 647:main.c        **** 		{
 648:main.c        **** 			uint8_t balanceInstruction[5] = { (uint8_t)(3700>>8),(uint8_t)(3700),45,0,0};
 3309               		.loc 1 648 12 view .LVU801
 3310 0106 CE01      		movw r24,r28
 3311 0108 0196      		adiw r24,1
 3312 010a 4C01      		movw r8,r24
 3313               	.LBE165:
 3314               	.LBB170:
 649:main.c        **** 			MCP2515_TX(MCP2515_findFreeTxBuffer(),sizeof(balanceInstruction),balanceInstruction,((uint32_t)1
 650:main.c        **** 			LED_on(YELLOW_LED);
 651:main.c        **** 		}
 652:main.c        **** 		else
 653:main.c        **** 		{
 654:main.c        **** 			LED_off(YELLOW_LED);
 655:main.c        **** 		}
 656:main.c        **** 		
 657:main.c        **** 		if(CMUTimeToScan) //if the program indicates that we will need new cell information, send wake si
 658:main.c        **** 		{
 659:main.c        **** 			CMU_data_count = 0;
 660:main.c        **** 			CMU_Wake_set();
 661:main.c        **** 			_delay_ms(5);
 662:main.c        **** 			if((STATUS_REG & MODE_HEARTBEATRECVD)==0)
 663:main.c        **** 			{
 664:main.c        **** 				STATUS_REG &= ~MODE_BALANCING;
 665:main.c        **** 				//send alarm code here
 666:main.c        **** 				//this is an error state
 667:main.c        **** 			}
 668:main.c        **** 			if(STATUS_REG & MODE_BALANCING)
 669:main.c        **** 			{ CMU_Wake_set(); }
 670:main.c        **** 			else
 671:main.c        **** 			{ CMU_Wake_reset(); }
 672:main.c        **** 
 673:main.c        **** 			LED_on(RED_LED);
 674:main.c        **** 			
 675:main.c        **** 			CMU_WAKE_TIMER = 0;
 676:main.c        **** 			do
 677:main.c        **** 			{
 678:main.c        ****                 //give all CMUs a total of 1 second to respond
 679:main.c        **** 				if(CMU_WAKE_TIMER > TIM_1_SEC) error_state(ERROR_CMU_TIMEOUT);
 680:main.c        **** 				if(STATUS_REG & MCP2515_DataWaiting)
 681:main.c        **** 				{
 682:main.c        **** 					status = MCP2515_reg_read(MCP2515_CANINTF);
 683:main.c        **** 					if(status & 3)
 684:main.c        **** 					{
 685:main.c        **** 						CMU_PollandProcess_RxBuffers(cmuData);	//if the program has indicated there is data waiting o
 686:main.c        **** 						STATUS_REG &= ~(MCP2515_DataWaiting);
 687:main.c        **** 					}
 688:main.c        **** 				}
 689:main.c        **** 			}while(CMU_data_count != CMU_COUNT*4);
 690:main.c        **** 				
 691:main.c        **** 			LED_off(RED_LED);
 692:main.c        **** 			CMUTimeToScan = 0;
 693:main.c        **** 			
 694:main.c        **** 		}
 695:main.c        **** 		if(STATUS_REG & MODE_HEARTBEATRECVD)
 696:main.c        **** 		{
 697:main.c        **** 			uint16_t min_temp = 0xFFFF;		//set it to maximum value
 3315               		.loc 1 697 13 view .LVU802
 3316 010c 6624      		clr r6
 3317 010e 6A94      		dec r6
 3318 0110 762C      		mov r7,r6
 3319               	.LBB171:
 698:main.c        **** 			uint16_t max_temp = 0x00;		//set it to minimum value
 699:main.c        **** 			uint16_t min_volt = 0xFFFF;
 700:main.c        **** 			uint16_t max_volt = 0x00;
 701:main.c        **** 			uint32_t avgVSum = 0;
 702:main.c        **** 			uint32_t avgTSum = 0;
 703:main.c        **** 			for(uint8_t i = 0; i<CMU_COUNT; i++)
 704:main.c        **** 			{
 705:main.c        **** 				TX_cellVoltage(cmuData[i], &max_volt, &min_volt, &avgVSum);
 3320               		.loc 1 705 5 view .LVU803
 3321 0112 1E01      		movw r2,r28
 3322 0114 96E0      		ldi r25,6
 3323 0116 290E      		add r2,r25
 3324 0118 311C      		adc r3,__zero_reg__
 3325 011a 9E01      		movw r18,r28
 3326 011c 245F      		subi r18,-12
 3327 011e 3F4F      		sbci r19,-1
 3328 0120 3C8B      		std Y+20,r19
 3329 0122 2B8B      		std Y+19,r18
 3330 0124 CE01      		movw r24,r28
 3331 0126 0A96      		adiw r24,10
 3332 0128 9E8B      		std Y+22,r25
 3333 012a 8D8B      		std Y+21,r24
 706:main.c        **** 				TX_cellTemps(cmuData[i], &max_temp, &min_temp, &avgTSum);
 3334               		.loc 1 706 5 view .LVU804
 3335 012c 2C5F      		subi r18,-4
 3336 012e 3F4F      		sbci r19,-1
 3337 0130 388F      		std Y+24,r19
 3338 0132 2F8B      		std Y+23,r18
 3339 0134 2E01      		movw r4,r28
 3340 0136 3EE0      		ldi r19,14
 3341 0138 430E      		add r4,r19
 3342 013a 511C      		adc r5,__zero_reg__
 3343               	.L170:
 3344               	.LBE171:
 3345               	.LBE170:
 644:main.c        ****     {
 3346               		.loc 1 644 5 is_stmt 1 view .LVU805
 646:main.c        **** 		{
 3347               		.loc 1 646 3 view .LVU806
 646:main.c        **** 		{
 3348               		.loc 1 646 5 is_stmt 0 view .LVU807
 3349 013c F19B      		sbis 0x1e,1
 3350 013e 00C0      		rjmp .L155
 3351               	.LBB174:
 648:main.c        **** 			MCP2515_TX(MCP2515_findFreeTxBuffer(),sizeof(balanceInstruction),balanceInstruction,((uint32_t)1
 3352               		.loc 1 648 4 is_stmt 1 view .LVU808
 648:main.c        **** 			MCP2515_TX(MCP2515_findFreeTxBuffer(),sizeof(balanceInstruction),balanceInstruction,((uint32_t)1
 3353               		.loc 1 648 12 is_stmt 0 view .LVU809
 3354 0140 85E0      		ldi r24,lo8(5)
 3355 0142 E0E0      		ldi r30,lo8(.LC0)
 3356 0144 F0E0      		ldi r31,hi8(.LC0)
 3357 0146 D401      		movw r26,r8
 3358               		0:
 3359 0148 0190      		ld r0,Z+
 3360 014a 0D92      		st X+,r0
 3361 014c 8A95      		dec r24
 3362 014e 01F4      		brne 0b
 649:main.c        **** 			LED_on(YELLOW_LED);
 3363               		.loc 1 649 4 is_stmt 1 view .LVU810
 649:main.c        **** 			LED_on(YELLOW_LED);
 3364               		.loc 1 649 15 is_stmt 0 view .LVU811
 3365 0150 0E94 0000 		call MCP2515_findFreeTxBuffer
 3366               	.LVL217:
 649:main.c        **** 			LED_on(YELLOW_LED);
 3367               		.loc 1 649 4 view .LVU812
 3368 0154 04E1      		ldi r16,lo8(20)
 3369 0156 10E0      		ldi r17,0
 3370 0158 24E0      		ldi r18,lo8(4)
 3371 015a 38E0      		ldi r19,lo8(8)
 3372 015c A401      		movw r20,r8
 3373 015e 65E0      		ldi r22,lo8(5)
 3374 0160 0E94 0000 		call MCP2515_TX
 3375               	.LVL218:
 650:main.c        **** 		}
 3376               		.loc 1 650 4 is_stmt 1 view .LVU813
 3377               	.LBB166:
 3378               	.LBI166:
 498:main.c        **** {
 3379               		.loc 1 498 6 view .LVU814
 3380               	.LBE166:
 3381               	.LBE174:
 500:main.c        **** 	{
 3382               		.loc 1 500 2 view .LVU815
 3383               	.LBB175:
 3384               	.LBB169:
 3385               	.LBB167:
 3386               	.LBB168:
 503:main.c        **** 			break;
 3387               		.loc 1 503 4 view .LVU816
 503:main.c        **** 			break;
 3388               		.loc 1 503 10 is_stmt 0 view .LVU817
 3389 0164 5F98      		cbi 0xb,7
 504:main.c        **** 		case RED_LED:
 3390               		.loc 1 504 4 is_stmt 1 view .LVU818
 3391               	.LVL219:
 3392               	.L156:
 504:main.c        **** 		case RED_LED:
 3393               		.loc 1 504 4 is_stmt 0 view .LVU819
 3394               	.LBE168:
 3395               	.LBE167:
 3396               	.LBE169:
 3397               	.LBE175:
 657:main.c        **** 		{
 3398               		.loc 1 657 3 is_stmt 1 view .LVU820
 657:main.c        **** 		{
 3399               		.loc 1 657 5 is_stmt 0 view .LVU821
 3400 0166 8091 0000 		lds r24,CMUTimeToScan
 3401 016a 8823      		tst r24
 3402 016c 01F0      		breq .L157
 659:main.c        **** 			CMU_Wake_set();
 3403               		.loc 1 659 4 is_stmt 1 view .LVU822
 659:main.c        **** 			CMU_Wake_set();
 3404               		.loc 1 659 19 is_stmt 0 view .LVU823
 3405 016e 1092 0000 		sts CMU_data_count,__zero_reg__
 660:main.c        **** 			_delay_ms(5);
 3406               		.loc 1 660 4 is_stmt 1 view .LVU824
 3407 0172 0E94 0000 		call CMU_Wake_set
 3408               	.LVL220:
 661:main.c        **** 			if((STATUS_REG & MODE_HEARTBEATRECVD)==0)
 3409               		.loc 1 661 4 view .LVU825
 3410               	.LBB176:
 3411               	.LBI176:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3412               		.loc 2 166 1 view .LVU826
 3413               	.LBB177:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3414               		.loc 2 168 2 view .LVU827
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3415               		.loc 2 172 2 view .LVU828
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3416               		.loc 2 173 2 view .LVU829
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3417               		.loc 2 174 2 view .LVU830
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3418               		.loc 2 184 3 view .LVU831
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3419               		.loc 2 187 2 view .LVU832
 3420 0176 8FE1      		ldi r24,lo8(19999)
 3421 0178 9EE4      		ldi r25,hi8(19999)
 3422 017a 0197      	1:	sbiw r24,1
 3423 017c 01F4      		brne 1b
 3424 017e 00C0      		rjmp .
 3425 0180 0000      		nop
 3426               	.LVL221:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3427               		.loc 2 187 2 is_stmt 0 view .LVU833
 3428               	.LBE177:
 3429               	.LBE176:
 662:main.c        **** 			{
 3430               		.loc 1 662 4 is_stmt 1 view .LVU834
 662:main.c        **** 			{
 3431               		.loc 1 662 6 is_stmt 0 view .LVU835
 3432 0182 F29B      		sbis 0x1e,2
 664:main.c        **** 				//send alarm code here
 3433               		.loc 1 664 5 is_stmt 1 view .LVU836
 664:main.c        **** 				//send alarm code here
 3434               		.loc 1 664 16 is_stmt 0 view .LVU837
 3435 0184 F198      		cbi 0x1e,1
 3436               	.L158:
 668:main.c        **** 			{ CMU_Wake_set(); }
 3437               		.loc 1 668 4 is_stmt 1 view .LVU838
 668:main.c        **** 			{ CMU_Wake_set(); }
 3438               		.loc 1 668 6 is_stmt 0 view .LVU839
 3439 0186 F19B      		sbis 0x1e,1
 3440 0188 00C0      		rjmp .L159
 669:main.c        **** 			else
 3441               		.loc 1 669 6 is_stmt 1 view .LVU840
 3442 018a 0E94 0000 		call CMU_Wake_set
 3443               	.LVL222:
 3444               	.L160:
 673:main.c        **** 			
 3445               		.loc 1 673 4 view .LVU841
 3446 018e 81E0      		ldi r24,lo8(1)
 3447 0190 0E94 0000 		call LED_on
 3448               	.LVL223:
 675:main.c        **** 			do
 3449               		.loc 1 675 4 view .LVU842
 675:main.c        **** 			do
 3450               		.loc 1 675 19 is_stmt 0 view .LVU843
 3451 0194 19BA      		out 0x19,__zero_reg__
 3452               	.L165:
 676:main.c        **** 			{
 3453               		.loc 1 676 4 is_stmt 1 view .LVU844
 679:main.c        **** 				if(STATUS_REG & MCP2515_DataWaiting)
 3454               		.loc 1 679 5 view .LVU845
 679:main.c        **** 				if(STATUS_REG & MCP2515_DataWaiting)
 3455               		.loc 1 679 8 is_stmt 0 view .LVU846
 3456 0196 89B3      		in r24,0x19
 679:main.c        **** 				if(STATUS_REG & MCP2515_DataWaiting)
 3457               		.loc 1 679 7 view .LVU847
 3458 0198 8E33      		cpi r24,lo8(62)
 3459 019a 00F0      		brlo .+2
 3460 019c 00C0      		rjmp .L161
 680:main.c        **** 				{
 3461               		.loc 1 680 5 is_stmt 1 view .LVU848
 680:main.c        **** 				{
 3462               		.loc 1 680 7 is_stmt 0 view .LVU849
 3463 019e F79B      		sbis 0x1e,7
 3464 01a0 00C0      		rjmp .L163
 682:main.c        **** 					if(status & 3)
 3465               		.loc 1 682 6 is_stmt 1 view .LVU850
 682:main.c        **** 					if(status & 3)
 3466               		.loc 1 682 15 is_stmt 0 view .LVU851
 3467 01a2 8CE2      		ldi r24,lo8(44)
 3468 01a4 0E94 0000 		call MCP2515_reg_read
 3469               	.LVL224:
 682:main.c        **** 					if(status & 3)
 3470               		.loc 1 682 13 view .LVU852
 3471 01a8 8A8B      		std Y+18,r24
 683:main.c        **** 					{
 3472               		.loc 1 683 6 is_stmt 1 view .LVU853
 683:main.c        **** 					{
 3473               		.loc 1 683 8 is_stmt 0 view .LVU854
 3474 01aa 8370      		andi r24,lo8(3)
 3475 01ac 01F0      		breq .L163
 685:main.c        **** 						STATUS_REG &= ~(MCP2515_DataWaiting);
 3476               		.loc 1 685 7 is_stmt 1 view .LVU855
 3477 01ae 80E0      		ldi r24,lo8(cmuData)
 3478 01b0 90E0      		ldi r25,hi8(cmuData)
 3479 01b2 0E94 0000 		call CMU_PollandProcess_RxBuffers
 3480               	.LVL225:
 686:main.c        **** 					}
 3481               		.loc 1 686 7 view .LVU856
 686:main.c        **** 					}
 3482               		.loc 1 686 18 is_stmt 0 view .LVU857
 3483 01b6 F798      		cbi 0x1e,7
 3484               	.L163:
 689:main.c        **** 				
 3485               		.loc 1 689 26 view .LVU858
 3486 01b8 8091 0000 		lds r24,CMU_data_count
 689:main.c        **** 				
 3487               		.loc 1 689 4 view .LVU859
 3488 01bc 8C30      		cpi r24,lo8(12)
 3489 01be 01F4      		brne .L165
 691:main.c        **** 			CMUTimeToScan = 0;
 3490               		.loc 1 691 4 is_stmt 1 view .LVU860
 3491 01c0 81E0      		ldi r24,lo8(1)
 3492 01c2 0E94 0000 		call LED_off
 3493               	.LVL226:
 692:main.c        **** 			
 3494               		.loc 1 692 4 view .LVU861
 692:main.c        **** 			
 3495               		.loc 1 692 18 is_stmt 0 view .LVU862
 3496 01c6 1092 0000 		sts CMUTimeToScan,__zero_reg__
 3497               	.L157:
 695:main.c        **** 		{
 3498               		.loc 1 695 3 is_stmt 1 view .LVU863
 695:main.c        **** 		{
 3499               		.loc 1 695 5 is_stmt 0 view .LVU864
 3500 01ca F29B      		sbis 0x1e,2
 3501 01cc 00C0      		rjmp .L166
 3502               	.LBB178:
 697:main.c        **** 			uint16_t max_temp = 0x00;		//set it to minimum value
 3503               		.loc 1 697 4 is_stmt 1 view .LVU865
 697:main.c        **** 			uint16_t max_temp = 0x00;		//set it to minimum value
 3504               		.loc 1 697 13 is_stmt 0 view .LVU866
 3505 01ce 798A      		std Y+17,r7
 3506 01d0 688A      		std Y+16,r6
 698:main.c        **** 			uint16_t min_volt = 0xFFFF;
 3507               		.loc 1 698 4 is_stmt 1 view .LVU867
 698:main.c        **** 			uint16_t min_volt = 0xFFFF;
 3508               		.loc 1 698 13 is_stmt 0 view .LVU868
 3509 01d2 1F86      		std Y+15,__zero_reg__
 3510 01d4 1E86      		std Y+14,__zero_reg__
 699:main.c        **** 			uint16_t max_volt = 0x00;
 3511               		.loc 1 699 4 is_stmt 1 view .LVU869
 699:main.c        **** 			uint16_t max_volt = 0x00;
 3512               		.loc 1 699 13 is_stmt 0 view .LVU870
 3513 01d6 7D86      		std Y+13,r7
 3514 01d8 6C86      		std Y+12,r6
 700:main.c        **** 			uint32_t avgVSum = 0;
 3515               		.loc 1 700 4 is_stmt 1 view .LVU871
 700:main.c        **** 			uint32_t avgVSum = 0;
 3516               		.loc 1 700 13 is_stmt 0 view .LVU872
 3517 01da 1B86      		std Y+11,__zero_reg__
 3518 01dc 1A86      		std Y+10,__zero_reg__
 701:main.c        **** 			uint32_t avgTSum = 0;
 3519               		.loc 1 701 4 is_stmt 1 view .LVU873
 701:main.c        **** 			uint32_t avgTSum = 0;
 3520               		.loc 1 701 13 is_stmt 0 view .LVU874
 3521 01de 1E82      		std Y+6,__zero_reg__
 3522 01e0 1F82      		std Y+7,__zero_reg__
 3523 01e2 1886      		std Y+8,__zero_reg__
 3524 01e4 1986      		std Y+9,__zero_reg__
 702:main.c        **** 			for(uint8_t i = 0; i<CMU_COUNT; i++)
 3525               		.loc 1 702 4 is_stmt 1 view .LVU875
 702:main.c        **** 			for(uint8_t i = 0; i<CMU_COUNT; i++)
 3526               		.loc 1 702 13 is_stmt 0 view .LVU876
 3527 01e6 1982      		std Y+1,__zero_reg__
 3528 01e8 1A82      		std Y+2,__zero_reg__
 3529 01ea 1B82      		std Y+3,__zero_reg__
 3530 01ec 1C82      		std Y+4,__zero_reg__
 703:main.c        **** 			{
 3531               		.loc 1 703 4 is_stmt 1 view .LVU877
 3532               	.LBB172:
 703:main.c        **** 			{
 3533               		.loc 1 703 8 view .LVU878
 3534               	.LVL227:
 703:main.c        **** 			{
 3535               		.loc 1 703 8 is_stmt 0 view .LVU879
 3536               	.LBE172:
 702:main.c        **** 			for(uint8_t i = 0; i<CMU_COUNT; i++)
 3537               		.loc 1 702 13 view .LVU880
 3538 01ee 10E0      		ldi r17,0
 3539 01f0 00E0      		ldi r16,0
 3540               	.LVL228:
 3541               	.L167:
 3542               	.LBB173:
 705:main.c        **** 				TX_cellTemps(cmuData[i], &max_temp, &min_temp, &avgTSum);
 3543               		.loc 1 705 5 is_stmt 1 discriminator 3 view .LVU881
 3544 01f2 3F92      		push r3
 3545 01f4 2F92      		push r2
 3546 01f6 9C89      		ldd r25,Y+20
 3547 01f8 9F93      		push r25
 3548 01fa 2B89      		ldd r18,Y+19
 3549 01fc 2F93      		push r18
 3550 01fe 3E89      		ldd r19,Y+22
 3551 0200 3F93      		push r19
 3552 0202 8D89      		ldd r24,Y+21
 3553 0204 8F93      		push r24
 3554 0206 22E2      		ldi r18,lo8(34)
 3555 0208 209F      		mul r18,r16
 3556 020a C001      		movw r24,r0
 3557 020c 219F      		mul r18,r17
 3558 020e 900D      		add r25,r0
 3559 0210 1124      		clr __zero_reg__
 3560 0212 9C01      		movw r18,r24
 3561 0214 2050      		subi r18,lo8(-(cmuData))
 3562 0216 3040      		sbci r19,hi8(-(cmuData))
 3563 0218 7901      		movw r14,r18
 3564 021a 8DB7      		in r24,__SP_L__
 3565 021c 9EB7      		in r25,__SP_H__
 3566 021e 8297      		sbiw r24,34
 3567 0220 0FB6      		in __tmp_reg__,__SREG__
 3568 0222 F894      		cli
 3569 0224 9EBF      		out __SP_H__,r25
 3570 0226 0FBE      		out __SREG__,__tmp_reg__
 3571 0228 8DBF      		out __SP_L__,r24
 3572 022a ADB7      		in r26,__SP_L__
 3573 022c BEB7      		in r27,__SP_H__
 3574 022e 1196      		adiw r26,1
 3575 0230 F901      		movw r30,r18
 3576 0232 82E2      		ldi r24,lo8(34)
 3577               		0:
 3578 0234 0190      		ld r0,Z+
 3579 0236 0D92      		st X+,r0
 3580 0238 8A95      		dec r24
 3581 023a 01F4      		brne 0b
 3582 023c 0E94 0000 		call TX_cellVoltage
 3583               	.LVL229:
 3584               		.loc 1 706 5 discriminator 3 view .LVU882
 3585 0240 0FB6      		in __tmp_reg__,__SREG__
 3586 0242 F894      		cli
 3587 0244 DEBF      		out __SP_H__,r29
 3588 0246 0FBE      		out __SREG__,__tmp_reg__
 3589 0248 CDBF      		out __SP_L__,r28
 3590 024a 9F92      		push r9
 3591 024c 8F92      		push r8
 3592 024e 388D      		ldd r19,Y+24
 3593 0250 3F93      		push r19
 3594 0252 8F89      		ldd r24,Y+23
 3595 0254 8F93      		push r24
 3596 0256 5F92      		push r5
 3597 0258 4F92      		push r4
 3598 025a 2DB7      		in r18,__SP_L__
 3599 025c 3EB7      		in r19,__SP_H__
 3600 025e 2252      		subi r18,34
 3601 0260 3109      		sbc r19,__zero_reg__
 3602 0262 0FB6      		in __tmp_reg__,__SREG__
 3603 0264 F894      		cli
 3604 0266 3EBF      		out __SP_H__,r19
 3605 0268 0FBE      		out __SREG__,__tmp_reg__
 3606 026a 2DBF      		out __SP_L__,r18
 3607 026c ADB7      		in r26,__SP_L__
 3608 026e BEB7      		in r27,__SP_H__
 3609 0270 1196      		adiw r26,1
 3610 0272 F701      		movw r30,r14
 3611 0274 82E2      		ldi r24,lo8(34)
 3612               		0:
 3613 0276 0190      		ld r0,Z+
 3614 0278 0D92      		st X+,r0
 3615 027a 8A95      		dec r24
 3616 027c 01F4      		brne 0b
 3617 027e 0E94 0000 		call TX_cellTemps
 3618               	.LVL230:
 3619               		.loc 1 706 5 is_stmt 0 discriminator 3 view .LVU883
 3620 0282 0F5F      		subi r16,-1
 3621 0284 1F4F      		sbci r17,-1
 3622               	.LVL231:
 703:main.c        **** 			{
 3623               		.loc 1 703 4 discriminator 3 view .LVU884
 3624 0286 0FB6      		in __tmp_reg__,__SREG__
 3625 0288 F894      		cli
 3626 028a DEBF      		out __SP_H__,r29
 3627 028c 0FBE      		out __SREG__,__tmp_reg__
 3628 028e CDBF      		out __SP_L__,r28
 3629 0290 0330      		cpi r16,3
 3630 0292 1105      		cpc r17,__zero_reg__
 3631 0294 01F0      		breq .+2
 3632 0296 00C0      		rjmp .L167
 3633               	.LBE173:
 707:main.c        **** 			}
 708:main.c        **** 			TX_globalData( max_volt, min_volt, max_temp, min_temp, avgVSum, avgTSum);
 3634               		.loc 1 708 4 is_stmt 1 view .LVU885
 3635 0298 A980      		ldd r10,Y+1
 3636 029a BA80      		ldd r11,Y+2
 3637 029c CB80      		ldd r12,Y+3
 3638 029e DC80      		ldd r13,Y+4
 3639 02a0 EE80      		ldd r14,Y+6
 3640 02a2 FF80      		ldd r15,Y+7
 3641 02a4 0885      		ldd r16,Y+8
 3642 02a6 1985      		ldd r17,Y+9
 3643 02a8 2889      		ldd r18,Y+16
 3644 02aa 3989      		ldd r19,Y+17
 3645 02ac 4E85      		ldd r20,Y+14
 3646 02ae 5F85      		ldd r21,Y+15
 3647 02b0 6C85      		ldd r22,Y+12
 3648 02b2 7D85      		ldd r23,Y+13
 3649 02b4 8A85      		ldd r24,Y+10
 3650 02b6 9B85      		ldd r25,Y+11
 3651 02b8 0E94 0000 		call TX_globalData
 3652               	.LVL232:
 709:main.c        **** 			//CoulombCount_readAndUpdate();
 710:main.c        **** 			STATUS_REG &= ~MODE_HEARTBEATRECVD;
 3653               		.loc 1 710 4 view .LVU886
 3654               		.loc 1 710 15 is_stmt 0 view .LVU887
 3655 02bc F298      		cbi 0x1e,2
 711:main.c        **** 			if(max_volt > CELL_V_ERR_MAX || min_volt < CELL_V_ERR_MIN || max_temp > CELL_T_ERR_MAX || min_te
 3656               		.loc 1 711 4 is_stmt 1 view .LVU888
 3657               		.loc 1 711 6 is_stmt 0 view .LVU889
 3658 02be 8A85      		ldd r24,Y+10
 3659 02c0 9B85      		ldd r25,Y+11
 3660 02c2 8539      		cpi r24,-107
 3661 02c4 9141      		sbci r25,17
 3662 02c6 00F4      		brsh .L168
 3663               		.loc 1 711 33 discriminator 1 view .LVU890
 3664 02c8 8C85      		ldd r24,Y+12
 3665 02ca 9D85      		ldd r25,Y+13
 3666 02cc 8435      		cpi r24,84
 3667 02ce 9B40      		sbci r25,11
 3668 02d0 00F0      		brlo .L168
 3669               		.loc 1 711 91 discriminator 2 view .LVU891
 3670 02d2 8E85      		ldd r24,Y+14
 3671 02d4 9F85      		ldd r25,Y+15
 3672 02d6 C397      		sbiw r24,51
 3673 02d8 00F0      		brlo .L166
 3674               	.L168:
 712:main.c        **** 				error_state(ERROR_V_T_OOR);
 3675               		.loc 1 712 5 is_stmt 1 view .LVU892
 3676 02da 81E0      		ldi r24,lo8(1)
 3677 02dc 00C0      		rjmp .L188
 3678               	.LVL233:
 3679               	.L153:
 3680               		.loc 1 712 5 is_stmt 0 view .LVU893
 3681               	.LBE178:
 611:main.c        ****         //the &status is just dummy data so in case the function is written wrong, no harm should c
 3682               		.loc 1 611 3 is_stmt 1 view .LVU894
 3683 02de 42E3      		ldi r20,lo8(50)
 3684 02e0 60E0      		ldi r22,0
 3685 02e2 81E0      		ldi r24,lo8(1)
 3686 02e4 0E94 0000 		call flash_LED
 3687               	.LVL234:
 613:main.c        **** 		_delay_ms(5);
 3688               		.loc 1 613 3 view .LVU895
 613:main.c        **** 		_delay_ms(5);
 3689               		.loc 1 613 14 is_stmt 0 view .LVU896
 3690 02e8 0E94 0000 		call MCP2515_findFreeTxBuffer
 3691               	.LVL235:
 613:main.c        **** 		_delay_ms(5);
 3692               		.loc 1 613 3 view .LVU897
 3693 02ec 01E1      		ldi r16,lo8(17)
 3694 02ee 10E0      		ldi r17,0
 3695 02f0 24E0      		ldi r18,lo8(4)
 3696 02f2 38E0      		ldi r19,lo8(8)
 3697 02f4 AE01      		movw r20,r28
 3698 02f6 4E5E      		subi r20,-18
 3699 02f8 5F4F      		sbci r21,-1
 3700 02fa 60E0      		ldi r22,0
 3701 02fc 0E94 0000 		call MCP2515_TX
 3702               	.LVL236:
 614:main.c        ****         // If the time the checking for the CMU responses are over 1 second
 3703               		.loc 1 614 3 is_stmt 1 view .LVU898
 3704               	.LBB179:
 3705               	.LBI179:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3706               		.loc 2 166 1 view .LVU899
 3707               	.LBB180:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3708               		.loc 2 168 2 view .LVU900
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3709               		.loc 2 172 2 view .LVU901
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3710               		.loc 2 173 2 view .LVU902
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3711               		.loc 2 174 2 view .LVU903
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3712               		.loc 2 184 3 view .LVU904
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3713               		.loc 2 187 2 view .LVU905
 3714 0300 8FE1      		ldi r24,lo8(19999)
 3715 0302 9EE4      		ldi r25,hi8(19999)
 3716 0304 0197      	1:	sbiw r24,1
 3717 0306 01F4      		brne 1b
 3718 0308 00C0      		rjmp .
 3719 030a 0000      		nop
 3720               	.LVL237:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3721               		.loc 2 187 2 is_stmt 0 view .LVU906
 3722               	.LBE180:
 3723               	.LBE179:
 616:main.c        **** 		if(STATUS_REG & MCP2515_DataWaiting)
 3724               		.loc 1 616 3 is_stmt 1 view .LVU907
 616:main.c        **** 		if(STATUS_REG & MCP2515_DataWaiting)
 3725               		.loc 1 616 6 is_stmt 0 view .LVU908
 3726 030c 89B3      		in r24,0x19
 616:main.c        **** 		if(STATUS_REG & MCP2515_DataWaiting)
 3727               		.loc 1 616 5 view .LVU909
 3728 030e 8E33      		cpi r24,lo8(62)
 3729 0310 00F0      		brlo .L150
 3730               	.L161:
 616:main.c        **** 		if(STATUS_REG & MCP2515_DataWaiting)
 3731               		.loc 1 616 33 is_stmt 1 discriminator 1 view .LVU910
 3732 0312 85E0      		ldi r24,lo8(5)
 3733               	.L188:
 3734               	.LBB181:
 3735               		.loc 1 712 5 is_stmt 0 view .LVU911
 3736 0314 0E94 0000 		call error_state
 3737               	.LVL238:
 3738               	.L150:
 3739               	.LBE181:
 617:main.c        **** 		{
 3740               		.loc 1 617 3 is_stmt 1 view .LVU912
 617:main.c        **** 		{
 3741               		.loc 1 617 5 is_stmt 0 view .LVU913
 3742 0318 F79B      		sbis 0x1e,7
 3743 031a 00C0      		rjmp .L151
 619:main.c        **** 			if(status & 3)
 3744               		.loc 1 619 4 is_stmt 1 view .LVU914
 619:main.c        **** 			if(status & 3)
 3745               		.loc 1 619 13 is_stmt 0 view .LVU915
 3746 031c 8CE2      		ldi r24,lo8(44)
 3747 031e 0E94 0000 		call MCP2515_reg_read
 3748               	.LVL239:
 619:main.c        **** 			if(status & 3)
 3749               		.loc 1 619 11 view .LVU916
 3750 0322 8A8B      		std Y+18,r24
 620:main.c        **** 			{
 3751               		.loc 1 620 4 is_stmt 1 view .LVU917
 620:main.c        **** 			{
 3752               		.loc 1 620 6 is_stmt 0 view .LVU918
 3753 0324 8370      		andi r24,lo8(3)
 3754 0326 01F0      		breq .L152
 623:main.c        **** 			}
 3755               		.loc 1 623 5 is_stmt 1 view .LVU919
 3756 0328 80E0      		ldi r24,lo8(cmuData)
 3757 032a 90E0      		ldi r25,hi8(cmuData)
 3758 032c 0E94 0000 		call CMU_PollandProcess_RxBuffers
 3759               	.LVL240:
 3760               	.L152:
 625:main.c        **** 			MCP2515_reg_write(MCP2515_CANINTF, 0b00000000);
 3761               		.loc 1 625 4 view .LVU920
 625:main.c        **** 			MCP2515_reg_write(MCP2515_CANINTF, 0b00000000);
 3762               		.loc 1 625 15 is_stmt 0 view .LVU921
 3763 0330 F798      		cbi 0x1e,7
 626:main.c        **** 		}
 3764               		.loc 1 626 4 is_stmt 1 view .LVU922
 3765 0332 60E0      		ldi r22,0
 3766 0334 8CE2      		ldi r24,lo8(44)
 3767 0336 0E94 0000 		call MCP2515_reg_write
 3768               	.LVL241:
 3769 033a 00C0      		rjmp .L151
 3770               	.LVL242:
 3771               	.L155:
 654:main.c        **** 		}
 3772               		.loc 1 654 4 view .LVU923
 3773               	.LBB182:
 3774               	.LBI182:
 512:main.c        **** {
 3775               		.loc 1 512 6 view .LVU924
 3776               	.LBE182:
 514:main.c        **** 	{
 3777               		.loc 1 514 2 view .LVU925
 3778               	.LBB185:
 3779               	.LBB183:
 3780               	.LBB184:
 517:main.c        **** 			break;
 3781               		.loc 1 517 4 view .LVU926
 517:main.c        **** 			break;
 3782               		.loc 1 517 10 is_stmt 0 view .LVU927
 3783 033c 5F9A      		sbi 0xb,7
 518:main.c        **** 		case RED_LED:
 3784               		.loc 1 518 4 is_stmt 1 view .LVU928
 3785 033e 00C0      		rjmp .L156
 3786               	.LVL243:
 3787               	.L159:
 518:main.c        **** 		case RED_LED:
 3788               		.loc 1 518 4 is_stmt 0 view .LVU929
 3789               	.LBE184:
 3790               	.LBE183:
 3791               	.LBE185:
 671:main.c        **** 
 3792               		.loc 1 671 6 is_stmt 1 view .LVU930
 3793 0340 0E94 0000 		call CMU_Wake_reset
 3794               	.LVL244:
 3795 0344 00C0      		rjmp .L160
 3796               	.L166:
 713:main.c        **** 		}
 714:main.c        **** 		CAN_RXInit(5,0,CCmsk,CC);
 3797               		.loc 1 714 3 view .LVU931
 3798 0346 E12C      		mov r14,__zero_reg__
 3799 0348 F12C      		mov r15,__zero_reg__
 3800 034a 00E0      		ldi r16,0
 3801 034c 18E0      		ldi r17,lo8(8)
 3802 034e 20E0      		ldi r18,0
 3803 0350 30E0      		ldi r19,0
 3804 0352 40E0      		ldi r20,0
 3805 0354 58E0      		ldi r21,lo8(8)
 3806 0356 60E0      		ldi r22,0
 3807 0358 85E0      		ldi r24,lo8(5)
 3808 035a 0E94 0000 		call CAN_RXInit
 3809               	.LVL245:
 715:main.c        **** 		_delay_ms(50);
 3810               		.loc 1 715 3 view .LVU932
 3811               	.LBB186:
 3812               	.LBI186:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 3813               		.loc 2 166 1 view .LVU933
 3814               	.LBB187:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 3815               		.loc 2 168 2 view .LVU934
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 3816               		.loc 2 172 2 view .LVU935
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 3817               		.loc 2 173 2 view .LVU936
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3818               		.loc 2 174 2 view .LVU937
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 3819               		.loc 2 184 3 view .LVU938
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 3820               		.loc 2 187 2 view .LVU939
 3821 035e 8FEF      		ldi r24,lo8(159999)
 3822 0360 90E7      		ldi r25,hi8(159999)
 3823 0362 22E0      		ldi r18,hlo8(159999)
 3824 0364 8150      	1:	subi r24,1
 3825 0366 9040      		sbci r25,0
 3826 0368 2040      		sbci r18,0
 3827 036a 01F4      		brne 1b
 3828 036c 00C0      		rjmp .
 3829 036e 0000      		nop
 3830 0370 00C0      		rjmp .L170
 3831               	.LBE187:
 3832               	.LBE186:
 3833               		.cfi_endproc
 3834               	.LFE37:
 3836               		.section	.text.__vector_22,"ax",@progbits
 3837               	.global	__vector_22
 3839               	__vector_22:
 3840               	.LFB38:
 716:main.c        ****     }
 717:main.c        **** }
 718:main.c        **** 
 719:main.c        **** //ISR(PCINT3_vect)			//This interrupt from the MCP2515 is not reliable, it doesn't trigger.
 720:main.c        **** //{
 721:main.c        **** //	//upon signal of the RX0 buffer full pin,
 722:main.c        **** //	PCIFR |= (1<<PCIE3);				//should clear on this execution routine.
 723:main.c        **** //}
 724:main.c        **** 
 725:main.c        **** ISR(PCINT0_vect)
 726:main.c        **** {
 3841               		.loc 1 726 1 view -0
 3842               		.cfi_startproc
 3843 0000 1F92      		push r1
 3844               	.LCFI94:
 3845               		.cfi_def_cfa_offset 3
 3846               		.cfi_offset 1, -2
 3847 0002 0F92      		push r0
 3848               	.LCFI95:
 3849               		.cfi_def_cfa_offset 4
 3850               		.cfi_offset 0, -3
 3851 0004 0FB6      		in r0,__SREG__
 3852 0006 0F92      		push r0
 3853 0008 1124      		clr __zero_reg__
 3854 000a 2F93      		push r18
 3855               	.LCFI96:
 3856               		.cfi_def_cfa_offset 5
 3857               		.cfi_offset 18, -4
 3858 000c 3F93      		push r19
 3859               	.LCFI97:
 3860               		.cfi_def_cfa_offset 6
 3861               		.cfi_offset 19, -5
 3862 000e 4F93      		push r20
 3863               	.LCFI98:
 3864               		.cfi_def_cfa_offset 7
 3865               		.cfi_offset 20, -6
 3866 0010 5F93      		push r21
 3867               	.LCFI99:
 3868               		.cfi_def_cfa_offset 8
 3869               		.cfi_offset 21, -7
 3870 0012 6F93      		push r22
 3871               	.LCFI100:
 3872               		.cfi_def_cfa_offset 9
 3873               		.cfi_offset 22, -8
 3874 0014 7F93      		push r23
 3875               	.LCFI101:
 3876               		.cfi_def_cfa_offset 10
 3877               		.cfi_offset 23, -9
 3878 0016 8F93      		push r24
 3879               	.LCFI102:
 3880               		.cfi_def_cfa_offset 11
 3881               		.cfi_offset 24, -10
 3882 0018 9F93      		push r25
 3883               	.LCFI103:
 3884               		.cfi_def_cfa_offset 12
 3885               		.cfi_offset 25, -11
 3886 001a AF93      		push r26
 3887               	.LCFI104:
 3888               		.cfi_def_cfa_offset 13
 3889               		.cfi_offset 26, -12
 3890 001c BF93      		push r27
 3891               	.LCFI105:
 3892               		.cfi_def_cfa_offset 14
 3893               		.cfi_offset 27, -13
 3894 001e EF93      		push r30
 3895               	.LCFI106:
 3896               		.cfi_def_cfa_offset 15
 3897               		.cfi_offset 30, -14
 3898 0020 FF93      		push r31
 3899               	.LCFI107:
 3900               		.cfi_def_cfa_offset 16
 3901               		.cfi_offset 31, -15
 3902               	/* prologue: Signal */
 3903               	/* frame size = 0 */
 3904               	/* stack size = 15 */
 3905               	.L__stack_usage = 15
 727:main.c        **** 	//upon signal of the INT pin.
 728:main.c        **** 	LED_off(RED_LED);
 3906               		.loc 1 728 2 view .LVU941
 3907 0022 81E0      		ldi r24,lo8(1)
 3908 0024 0E94 0000 		call LED_off
 3909               	.LVL246:
 729:main.c        **** 	if(PINB & ~(1<<PINB3))		//if the pin is low
 3910               		.loc 1 729 2 view .LVU942
 3911               		.loc 1 729 5 is_stmt 0 view .LVU943
 3912 0028 83B1      		in r24,0x3
 3913               		.loc 1 729 10 view .LVU944
 3914 002a 877F      		andi r24,lo8(-9)
 3915               		.loc 1 729 4 view .LVU945
 3916 002c 01F0      		breq .L190
 730:main.c        **** 	{
 731:main.c        **** 		STATUS_REG |= MCP2515_DataWaiting;
 3917               		.loc 1 731 3 is_stmt 1 view .LVU946
 3918               		.loc 1 731 14 is_stmt 0 view .LVU947
 3919 002e F79A      		sbi 0x1e,7
 3920               	.L190:
 732:main.c        **** 	}
 733:main.c        **** 	PCIFR |= (1<<PCIE0);								//clear the interrupt.
 3921               		.loc 1 733 2 is_stmt 1 view .LVU948
 3922               		.loc 1 733 8 is_stmt 0 view .LVU949
 3923 0030 D89A      		sbi 0x1b,0
 3924               	/* epilogue start */
 734:main.c        **** }
 3925               		.loc 1 734 1 view .LVU950
 3926 0032 FF91      		pop r31
 3927 0034 EF91      		pop r30
 3928 0036 BF91      		pop r27
 3929 0038 AF91      		pop r26
 3930 003a 9F91      		pop r25
 3931 003c 8F91      		pop r24
 3932 003e 7F91      		pop r23
 3933 0040 6F91      		pop r22
 3934 0042 5F91      		pop r21
 3935 0044 4F91      		pop r20
 3936 0046 3F91      		pop r19
 3937 0048 2F91      		pop r18
 3938 004a 0F90      		pop r0
 3939 004c 0FBE      		out __SREG__,r0
 3940 004e 0F90      		pop r0
 3941 0050 1F90      		pop r1
 3942 0052 1895      		reti
 3943               		.cfi_endproc
 3944               	.LFE38:
 3946               		.section	.text.__vector_18,"ax",@progbits
 3947               	.global	__vector_18
 3949               	__vector_18:
 3950               	.LFB39:
 735:main.c        **** 
 736:main.c        **** ISR(CAN_INT_vect)
 737:main.c        **** {
 3951               		.loc 1 737 1 is_stmt 1 view -0
 3952               		.cfi_startproc
 3953 0000 1F92      		push r1
 3954               	.LCFI108:
 3955               		.cfi_def_cfa_offset 3
 3956               		.cfi_offset 1, -2
 3957 0002 0F92      		push r0
 3958               	.LCFI109:
 3959               		.cfi_def_cfa_offset 4
 3960               		.cfi_offset 0, -3
 3961 0004 0FB6      		in r0,__SREG__
 3962 0006 0F92      		push r0
 3963 0008 1124      		clr __zero_reg__
 3964 000a EF92      		push r14
 3965               	.LCFI110:
 3966               		.cfi_def_cfa_offset 5
 3967               		.cfi_offset 14, -4
 3968 000c FF92      		push r15
 3969               	.LCFI111:
 3970               		.cfi_def_cfa_offset 6
 3971               		.cfi_offset 15, -5
 3972 000e 0F93      		push r16
 3973               	.LCFI112:
 3974               		.cfi_def_cfa_offset 7
 3975               		.cfi_offset 16, -6
 3976 0010 1F93      		push r17
 3977               	.LCFI113:
 3978               		.cfi_def_cfa_offset 8
 3979               		.cfi_offset 17, -7
 3980 0012 2F93      		push r18
 3981               	.LCFI114:
 3982               		.cfi_def_cfa_offset 9
 3983               		.cfi_offset 18, -8
 3984 0014 3F93      		push r19
 3985               	.LCFI115:
 3986               		.cfi_def_cfa_offset 10
 3987               		.cfi_offset 19, -9
 3988 0016 4F93      		push r20
 3989               	.LCFI116:
 3990               		.cfi_def_cfa_offset 11
 3991               		.cfi_offset 20, -10
 3992 0018 5F93      		push r21
 3993               	.LCFI117:
 3994               		.cfi_def_cfa_offset 12
 3995               		.cfi_offset 21, -11
 3996 001a 6F93      		push r22
 3997               	.LCFI118:
 3998               		.cfi_def_cfa_offset 13
 3999               		.cfi_offset 22, -12
 4000 001c 7F93      		push r23
 4001               	.LCFI119:
 4002               		.cfi_def_cfa_offset 14
 4003               		.cfi_offset 23, -13
 4004 001e 8F93      		push r24
 4005               	.LCFI120:
 4006               		.cfi_def_cfa_offset 15
 4007               		.cfi_offset 24, -14
 4008 0020 9F93      		push r25
 4009               	.LCFI121:
 4010               		.cfi_def_cfa_offset 16
 4011               		.cfi_offset 25, -15
 4012 0022 AF93      		push r26
 4013               	.LCFI122:
 4014               		.cfi_def_cfa_offset 17
 4015               		.cfi_offset 26, -16
 4016 0024 BF93      		push r27
 4017               	.LCFI123:
 4018               		.cfi_def_cfa_offset 18
 4019               		.cfi_offset 27, -17
 4020 0026 EF93      		push r30
 4021               	.LCFI124:
 4022               		.cfi_def_cfa_offset 19
 4023               		.cfi_offset 30, -18
 4024 0028 FF93      		push r31
 4025               	.LCFI125:
 4026               		.cfi_def_cfa_offset 20
 4027               		.cfi_offset 31, -19
 4028               	/* prologue: Signal */
 4029               	/* frame size = 0 */
 4030               	/* stack size = 19 */
 4031               	.L__stack_usage = 19
 738:main.c        **** 	//CANIDT4 is l
 739:main.c        **** 	if(CANSIT2 & (1 << SIT5))	//we received a CAN message on mob 5, which is set up to receive exclusi
 4032               		.loc 1 739 2 view .LVU952
 4033               		.loc 1 739 5 is_stmt 0 view .LVU953
 4034 002a 8091 E000 		lds r24,224
 4035               		.loc 1 739 4 view .LVU954
 4036 002e 85FF      		sbrs r24,5
 4037 0030 00C0      		rjmp .L195
 740:main.c        **** 	{
 741:main.c        **** 		CANPAGE = (5 << 4);			//set the canpage to the receiver MOB
 4038               		.loc 1 741 3 is_stmt 1 view .LVU955
 4039               		.loc 1 741 11 is_stmt 0 view .LVU956
 4040 0032 80E5      		ldi r24,lo8(80)
 4041 0034 8093 ED00 		sts 237,r24
 742:main.c        **** 		CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 4042               		.loc 1 742 3 is_stmt 1 view .LVU957
 4043               		.loc 1 742 12 is_stmt 0 view .LVU958
 4044 0038 8091 EE00 		lds r24,238
 4045 003c 8F7D      		andi r24,lo8(-33)
 4046 003e 8093 EE00 		sts 238,r24
 743:main.c        **** 		if((CANIDT1 == ((1<<6)|(1<<4))) && (CANIDT2==deviceID) && ((CANIDT4>>3)==CC_HEARTBEAT) )	//if the
 4047               		.loc 1 743 3 is_stmt 1 view .LVU959
 4048               		.loc 1 743 7 is_stmt 0 view .LVU960
 4049 0042 8091 F300 		lds r24,243
 4050               		.loc 1 743 5 view .LVU961
 4051 0046 8035      		cpi r24,lo8(80)
 4052 0048 01F4      		brne .L196
 4053               		.loc 1 743 39 discriminator 1 view .LVU962
 4054 004a 2091 F200 		lds r18,242
 4055               		.loc 1 743 35 discriminator 1 view .LVU963
 4056 004e 8091 0000 		lds r24,deviceID
 4057 0052 9091 0000 		lds r25,deviceID+1
 4058 0056 2817      		cp r18,r24
 4059 0058 1906      		cpc __zero_reg__,r25
 4060 005a 01F4      		brne .L196
 4061               		.loc 1 743 63 discriminator 2 view .LVU964
 4062 005c 8091 F000 		lds r24,240
 4063               		.loc 1 743 74 discriminator 2 view .LVU965
 4064 0060 8695      		lsr r24
 4065 0062 8695      		lsr r24
 4066 0064 8695      		lsr r24
 4067               		.loc 1 743 58 discriminator 2 view .LVU966
 4068 0066 8130      		cpi r24,lo8(1)
 4069 0068 01F4      		brne .L196
 4070               	.LBB188:
 744:main.c        **** 		{
 745:main.c        **** 			STATUS_REG |= MODE_HEARTBEATRECVD;
 4071               		.loc 1 745 4 is_stmt 1 view .LVU967
 4072               		.loc 1 745 15 is_stmt 0 view .LVU968
 4073 006a F29A      		sbi 0x1e,2
 746:main.c        **** 			HEARTBEATCOUNTER = 0;
 4074               		.loc 1 746 4 is_stmt 1 view .LVU969
 4075               		.loc 1 746 21 is_stmt 0 view .LVU970
 4076 006c 1ABA      		out 0x1a,__zero_reg__
 747:main.c        **** 			uint32_t heartbeat =	(uint32_t)CANMSG<<24;	//byte 0
 4077               		.loc 1 747 4 is_stmt 1 view .LVU971
 4078               		.loc 1 747 35 is_stmt 0 view .LVU972
 4079 006e 8091 FA00 		lds r24,250
 4080               	.LVL247:
 748:main.c        **** 			heartbeat |= (uint32_t)CANMSG<<16;				//byte 1
 4081               		.loc 1 748 4 is_stmt 1 view .LVU973
 4082               		.loc 1 748 27 is_stmt 0 view .LVU974
 4083 0072 8091 FA00 		lds r24,250
 749:main.c        **** 			heartbeat |= (uint32_t)CANMSG<<8;				//byte 2
 4084               		.loc 1 749 4 is_stmt 1 view .LVU975
 4085               		.loc 1 749 27 is_stmt 0 view .LVU976
 4086 0076 8091 FA00 		lds r24,250
 750:main.c        **** 			heartbeat |= (uint32_t)CANMSG;					//byte 3
 4087               		.loc 1 750 4 is_stmt 1 view .LVU977
 4088               		.loc 1 750 27 is_stmt 0 view .LVU978
 4089 007a 8091 FA00 		lds r24,250
 751:main.c        **** 
 752:main.c        **** 			if((heartbeat&1) == 1)
 4090               		.loc 1 752 4 is_stmt 1 view .LVU979
 4091               		.loc 1 752 6 is_stmt 0 view .LVU980
 4092 007e 80FF      		sbrs r24,0
 4093 0080 00C0      		rjmp .L197
 753:main.c        **** 				STATUS_REG |= MODE_BALANCING;
 4094               		.loc 1 753 5 is_stmt 1 view .LVU981
 4095               		.loc 1 753 16 is_stmt 0 view .LVU982
 4096 0082 F19A      		sbi 0x1e,1
 4097               	.L196:
 4098               		.loc 1 753 16 view .LVU983
 4099               	.LBE188:
 754:main.c        **** 			else
 755:main.c        **** 				STATUS_REG &= ~MODE_BALANCING;
 756:main.c        **** 			///considering we got a heartbeat, we will send voltages back here. TBA
 757:main.c        **** 
 758:main.c        **** 		}
 759:main.c        **** 		if((CANIDT1 == ((1<<6)|(1<<4))) && (CANIDT2==deviceID) && ((CANIDT4>>3)==CC_MODE_CHANGE) )	//if t
 4100               		.loc 1 759 3 is_stmt 1 view .LVU984
 4101               		.loc 1 759 7 is_stmt 0 view .LVU985
 4102 0084 8091 F300 		lds r24,243
 4103               		.loc 1 759 5 view .LVU986
 4104 0088 8035      		cpi r24,lo8(80)
 4105 008a 01F4      		brne .L198
 4106               		.loc 1 759 39 discriminator 1 view .LVU987
 4107 008c 2091 F200 		lds r18,242
 4108               		.loc 1 759 35 discriminator 1 view .LVU988
 4109 0090 8091 0000 		lds r24,deviceID
 4110 0094 9091 0000 		lds r25,deviceID+1
 4111 0098 2817      		cp r18,r24
 4112 009a 1906      		cpc __zero_reg__,r25
 4113 009c 01F4      		brne .L198
 4114               		.loc 1 759 63 discriminator 2 view .LVU989
 4115 009e 8091 F000 		lds r24,240
 4116               		.loc 1 759 74 discriminator 2 view .LVU990
 4117 00a2 8695      		lsr r24
 4118 00a4 8695      		lsr r24
 4119 00a6 8695      		lsr r24
 4120               		.loc 1 759 58 discriminator 2 view .LVU991
 4121 00a8 8031      		cpi r24,lo8(16)
 4122 00aa 01F4      		brne .L198
 4123               	.LBB189:
 760:main.c        **** 		{
 761:main.c        **** 			uint16_t modeAddress =	CANMSG<<8;	//byte 0
 4124               		.loc 1 761 4 is_stmt 1 view .LVU992
 4125               		.loc 1 761 27 is_stmt 0 view .LVU993
 4126 00ac 3091 FA00 		lds r19,250
 4127               	.LVL248:
 762:main.c        **** 			modeAddress |= CANMSG;				//byte 1
 4128               		.loc 1 762 4 is_stmt 1 view .LVU994
 4129               		.loc 1 762 19 is_stmt 0 view .LVU995
 4130 00b0 2091 FA00 		lds r18,250
 4131               	.LVL249:
 763:main.c        **** 			uint16_t modeValue	=	CANMSG<<8;	//byte 2
 4132               		.loc 1 763 4 is_stmt 1 view .LVU996
 4133               		.loc 1 763 25 is_stmt 0 view .LVU997
 4134 00b4 9091 FA00 		lds r25,250
 4135               	.LVL250:
 764:main.c        **** 			modeValue  |= CANMSG;				//byte 3
 4136               		.loc 1 764 4 is_stmt 1 view .LVU998
 4137               		.loc 1 764 18 is_stmt 0 view .LVU999
 4138 00b8 8091 FA00 		lds r24,250
 4139               	.LVL251:
 765:main.c        **** 			switch(modeAddress)
 4140               		.loc 1 765 4 is_stmt 1 view .LVU1000
 4141 00bc 2130      		cpi r18,1
 4142 00be 3105      		cpc r19,__zero_reg__
 4143 00c0 01F4      		brne .L198
 766:main.c        **** 			{
 767:main.c        **** 				case 1:
 768:main.c        **** 					if(modeValue)
 4144               		.loc 1 768 6 view .LVU1001
 4145               		.loc 1 768 8 is_stmt 0 view .LVU1002
 4146 00c2 892B      		or r24,r25
 4147 00c4 01F0      		breq .L199
 769:main.c        **** 						STATUS_REG |= MODE_BALANCING;
 4148               		.loc 1 769 7 is_stmt 1 view .LVU1003
 4149               		.loc 1 769 18 is_stmt 0 view .LVU1004
 4150 00c6 F19A      		sbi 0x1e,1
 4151               	.LVL252:
 4152               	.L198:
 4153               		.loc 1 769 18 view .LVU1005
 4154               	.LBE189:
 770:main.c        **** 					else
 771:main.c        **** 						STATUS_REG &= ~MODE_BALANCING;
 772:main.c        **** 					break;
 773:main.c        **** 				case 2:
 774:main.c        **** 					break;
 775:main.c        **** 					//add functionality for changing scanning frequency
 776:main.c        **** 				default:
 777:main.c        **** 					break;
 778:main.c        **** 			}
 779:main.c        **** 
 780:main.c        **** 		}
 781:main.c        **** 		CAN_RXInit(5,0,CCmsk,CC);
 4155               		.loc 1 781 3 is_stmt 1 view .LVU1006
 4156 00c8 E12C      		mov r14,__zero_reg__
 4157 00ca F12C      		mov r15,__zero_reg__
 4158 00cc 00E0      		ldi r16,0
 4159 00ce 18E0      		ldi r17,lo8(8)
 4160 00d0 20E0      		ldi r18,0
 4161 00d2 30E0      		ldi r19,0
 4162 00d4 40E0      		ldi r20,0
 4163 00d6 58E0      		ldi r21,lo8(8)
 4164 00d8 60E0      		ldi r22,0
 4165 00da 85E0      		ldi r24,lo8(5)
 4166 00dc 0E94 0000 		call CAN_RXInit
 4167               	.LVL253:
 4168               	.L195:
 782:main.c        **** 
 783:main.c        **** 	}
 784:main.c        **** 	CANPAGE = (5 << 4);			//set the canpage to the receiver MOB
 4169               		.loc 1 784 2 view .LVU1007
 4170               		.loc 1 784 10 is_stmt 0 view .LVU1008
 4171 00e0 80E5      		ldi r24,lo8(80)
 4172 00e2 8093 ED00 		sts 237,r24
 785:main.c        **** 	CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 4173               		.loc 1 785 2 is_stmt 1 view .LVU1009
 4174               		.loc 1 785 11 is_stmt 0 view .LVU1010
 4175 00e6 8091 EE00 		lds r24,238
 4176 00ea 8F7D      		andi r24,lo8(-33)
 4177 00ec 8093 EE00 		sts 238,r24
 4178               	/* epilogue start */
 786:main.c        **** }
 4179               		.loc 1 786 1 view .LVU1011
 4180 00f0 FF91      		pop r31
 4181 00f2 EF91      		pop r30
 4182 00f4 BF91      		pop r27
 4183 00f6 AF91      		pop r26
 4184 00f8 9F91      		pop r25
 4185 00fa 8F91      		pop r24
 4186 00fc 7F91      		pop r23
 4187 00fe 6F91      		pop r22
 4188 0100 5F91      		pop r21
 4189 0102 4F91      		pop r20
 4190 0104 3F91      		pop r19
 4191 0106 2F91      		pop r18
 4192 0108 1F91      		pop r17
 4193 010a 0F91      		pop r16
 4194 010c FF90      		pop r15
 4195 010e EF90      		pop r14
 4196 0110 0F90      		pop r0
 4197 0112 0FBE      		out __SREG__,r0
 4198 0114 0F90      		pop r0
 4199 0116 1F90      		pop r1
 4200 0118 1895      		reti
 4201               	.L197:
 4202               	.LBB190:
 755:main.c        **** 			///considering we got a heartbeat, we will send voltages back here. TBA
 4203               		.loc 1 755 5 is_stmt 1 view .LVU1012
 755:main.c        **** 			///considering we got a heartbeat, we will send voltages back here. TBA
 4204               		.loc 1 755 16 is_stmt 0 view .LVU1013
 4205 011a F198      		cbi 0x1e,1
 4206 011c 00C0      		rjmp .L196
 4207               	.LVL254:
 4208               	.L199:
 755:main.c        **** 			///considering we got a heartbeat, we will send voltages back here. TBA
 4209               		.loc 1 755 16 view .LVU1014
 4210               	.LBE190:
 4211               	.LBB191:
 771:main.c        **** 					break;
 4212               		.loc 1 771 7 is_stmt 1 view .LVU1015
 771:main.c        **** 					break;
 4213               		.loc 1 771 18 is_stmt 0 view .LVU1016
 4214 011e F198      		cbi 0x1e,1
 4215 0120 00C0      		rjmp .L198
 4216               	.LBE191:
 4217               		.cfi_endproc
 4218               	.LFE39:
 4220               		.section	.text.__vector_17,"ax",@progbits
 4221               	.global	__vector_17
 4223               	__vector_17:
 4224               	.LFB40:
 787:main.c        **** 
 788:main.c        **** ISR(TIMER0_OVF_vect)
 789:main.c        **** {
 4225               		.loc 1 789 1 is_stmt 1 view -0
 4226               		.cfi_startproc
 4227 0000 1F92      		push r1
 4228               	.LCFI126:
 4229               		.cfi_def_cfa_offset 3
 4230               		.cfi_offset 1, -2
 4231 0002 0F92      		push r0
 4232               	.LCFI127:
 4233               		.cfi_def_cfa_offset 4
 4234               		.cfi_offset 0, -3
 4235 0004 0FB6      		in r0,__SREG__
 4236 0006 0F92      		push r0
 4237 0008 1124      		clr __zero_reg__
 4238 000a 2F93      		push r18
 4239               	.LCFI128:
 4240               		.cfi_def_cfa_offset 5
 4241               		.cfi_offset 18, -4
 4242 000c 3F93      		push r19
 4243               	.LCFI129:
 4244               		.cfi_def_cfa_offset 6
 4245               		.cfi_offset 19, -5
 4246 000e 4F93      		push r20
 4247               	.LCFI130:
 4248               		.cfi_def_cfa_offset 7
 4249               		.cfi_offset 20, -6
 4250 0010 5F93      		push r21
 4251               	.LCFI131:
 4252               		.cfi_def_cfa_offset 8
 4253               		.cfi_offset 21, -7
 4254 0012 6F93      		push r22
 4255               	.LCFI132:
 4256               		.cfi_def_cfa_offset 9
 4257               		.cfi_offset 22, -8
 4258 0014 7F93      		push r23
 4259               	.LCFI133:
 4260               		.cfi_def_cfa_offset 10
 4261               		.cfi_offset 23, -9
 4262 0016 8F93      		push r24
 4263               	.LCFI134:
 4264               		.cfi_def_cfa_offset 11
 4265               		.cfi_offset 24, -10
 4266 0018 9F93      		push r25
 4267               	.LCFI135:
 4268               		.cfi_def_cfa_offset 12
 4269               		.cfi_offset 25, -11
 4270 001a AF93      		push r26
 4271               	.LCFI136:
 4272               		.cfi_def_cfa_offset 13
 4273               		.cfi_offset 26, -12
 4274 001c BF93      		push r27
 4275               	.LCFI137:
 4276               		.cfi_def_cfa_offset 14
 4277               		.cfi_offset 27, -13
 4278 001e EF93      		push r30
 4279               	.LCFI138:
 4280               		.cfi_def_cfa_offset 15
 4281               		.cfi_offset 30, -14
 4282 0020 FF93      		push r31
 4283               	.LCFI139:
 4284               		.cfi_def_cfa_offset 16
 4285               		.cfi_offset 31, -15
 4286               	/* prologue: Signal */
 4287               	/* frame size = 0 */
 4288               	/* stack size = 15 */
 4289               	.L__stack_usage = 15
 790:main.c        **** 	timerCounter++;
 4290               		.loc 1 790 2 view .LVU1018
 4291               		.loc 1 790 14 is_stmt 0 view .LVU1019
 4292 0022 8091 0000 		lds r24,timerCounter
 4293 0026 9091 0000 		lds r25,timerCounter+1
 4294 002a 0196      		adiw r24,1
 4295 002c 9093 0000 		sts timerCounter+1,r25
 4296 0030 8093 0000 		sts timerCounter,r24
 791:main.c        **** 	HEARTBEATCOUNTER++;
 4297               		.loc 1 791 2 is_stmt 1 view .LVU1020
 4298 0034 8AB3      		in r24,0x1a
 4299               		.loc 1 791 18 is_stmt 0 view .LVU1021
 4300 0036 8F5F      		subi r24,lo8(-(1))
 4301 0038 8ABB      		out 0x1a,r24
 792:main.c        **** 	CMU_WAKE_TIMER++;
 4302               		.loc 1 792 2 is_stmt 1 view .LVU1022
 4303 003a 89B3      		in r24,0x19
 4304               		.loc 1 792 16 is_stmt 0 view .LVU1023
 4305 003c 8F5F      		subi r24,lo8(-(1))
 4306 003e 89BB      		out 0x19,r24
 793:main.c        **** 	if(HEARTBEATCOUNTER > TIM_4_SEC && !(STATUS_REG & MODE_HEARTBEATRECVD))
 4307               		.loc 1 793 2 is_stmt 1 view .LVU1024
 4308               		.loc 1 793 5 is_stmt 0 view .LVU1025
 4309 0040 8AB3      		in r24,0x1a
 4310               		.loc 1 793 4 view .LVU1026
 4311 0042 853F      		cpi r24,lo8(-11)
 4312 0044 00F0      		brlo .L204
 4313               		.loc 1 793 34 discriminator 1 view .LVU1027
 4314 0046 F299      		sbic 0x1e,2
 4315 0048 00C0      		rjmp .L204
 794:main.c        **** 	{
 795:main.c        **** 		error_state(ERROR_NO_HEARTBEAT);
 4316               		.loc 1 795 3 is_stmt 1 view .LVU1028
 4317 004a 84E0      		ldi r24,lo8(4)
 4318 004c 0E94 0000 		call error_state
 4319               	.LVL255:
 4320               	.L204:
 796:main.c        **** 	}
 797:main.c        **** 	if(!CMUAllRegistered && timerCounter >= CMUAuditTimeout*61)
 4321               		.loc 1 797 2 view .LVU1029
 4322               		.loc 1 797 4 is_stmt 0 view .LVU1030
 4323 0050 8091 0000 		lds r24,CMUAllRegistered
 4324 0054 8111      		cpse r24,__zero_reg__
 4325 0056 00C0      		rjmp .L205
 4326               		.loc 1 797 57 discriminator 1 view .LVU1031
 4327 0058 8091 0000 		lds r24,CMUAuditTimeout
 4328 005c 2DE3      		ldi r18,lo8(61)
 4329 005e 829F      		mul r24,r18
 4330 0060 C001      		movw r24,r0
 4331 0062 1124      		clr __zero_reg__
 4332               		.loc 1 797 23 discriminator 1 view .LVU1032
 4333 0064 2091 0000 		lds r18,timerCounter
 4334 0068 3091 0000 		lds r19,timerCounter+1
 4335 006c 2817      		cp r18,r24
 4336 006e 3907      		cpc r19,r25
 4337 0070 00F0      		brlo .L205
 798:main.c        **** 	{
 799:main.c        **** 		//using the timer, we will re-wake all the CMU's approximately every CMUAuditTimeout*1 seconds.
 800:main.c        **** 		timerCounter = 0;
 4338               		.loc 1 800 3 is_stmt 1 view .LVU1033
 4339               		.loc 1 800 16 is_stmt 0 view .LVU1034
 4340 0072 1092 0000 		sts timerCounter+1,__zero_reg__
 4341 0076 1092 0000 		sts timerCounter,__zero_reg__
 801:main.c        **** 		CMUTimeToScan = 1; //this actually only triggers a new scan when in auditing mode.
 4342               		.loc 1 801 3 is_stmt 1 view .LVU1035
 4343               		.loc 1 801 17 is_stmt 0 view .LVU1036
 4344 007a 81E0      		ldi r24,lo8(1)
 4345 007c 8093 0000 		sts CMUTimeToScan,r24
 4346               	.L205:
 802:main.c        **** 	}
 803:main.c        **** 	if (timerCounter >= CMUScanInterval*61) //CMUInterval seconds,
 4347               		.loc 1 803 2 is_stmt 1 view .LVU1037
 4348               		.loc 1 803 37 is_stmt 0 view .LVU1038
 4349 0080 8091 0000 		lds r24,CMUScanInterval
 4350 0084 2DE3      		ldi r18,lo8(61)
 4351 0086 829F      		mul r24,r18
 4352 0088 C001      		movw r24,r0
 4353 008a 1124      		clr __zero_reg__
 4354               		.loc 1 803 5 view .LVU1039
 4355 008c 2091 0000 		lds r18,timerCounter
 4356 0090 3091 0000 		lds r19,timerCounter+1
 4357 0094 2817      		cp r18,r24
 4358 0096 3907      		cpc r19,r25
 4359 0098 00F0      		brlo .L203
 804:main.c        **** 	{
 805:main.c        **** 		timerCounter = 0; //reset our counter
 4360               		.loc 1 805 3 is_stmt 1 view .LVU1040
 4361               		.loc 1 805 16 is_stmt 0 view .LVU1041
 4362 009a 1092 0000 		sts timerCounter+1,__zero_reg__
 4363 009e 1092 0000 		sts timerCounter,__zero_reg__
 806:main.c        **** 		CMUTimeToScan = 1; //set the flag that will trigger a scan routine on next flag.
 4364               		.loc 1 806 3 is_stmt 1 view .LVU1042
 4365               		.loc 1 806 17 is_stmt 0 view .LVU1043
 4366 00a2 81E0      		ldi r24,lo8(1)
 4367 00a4 8093 0000 		sts CMUTimeToScan,r24
 4368               	.L203:
 4369               	/* epilogue start */
 807:main.c        **** 	}
 808:main.c        **** }
 4370               		.loc 1 808 1 view .LVU1044
 4371 00a8 FF91      		pop r31
 4372 00aa EF91      		pop r30
 4373 00ac BF91      		pop r27
 4374 00ae AF91      		pop r26
 4375 00b0 9F91      		pop r25
 4376 00b2 8F91      		pop r24
 4377 00b4 7F91      		pop r23
 4378 00b6 6F91      		pop r22
 4379 00b8 5F91      		pop r21
 4380 00ba 4F91      		pop r20
 4381 00bc 3F91      		pop r19
 4382 00be 2F91      		pop r18
 4383 00c0 0F90      		pop r0
 4384 00c2 0FBE      		out __SREG__,r0
 4385 00c4 0F90      		pop r0
 4386 00c6 1F90      		pop r1
 4387 00c8 1895      		reti
 4388               		.cfi_endproc
 4389               	.LFE40:
 4391               	.global	voltage2SoC_Translation
 4392               		.data
 4395               	voltage2SoC_Translation:
 4396 0000 C0        		.byte	-64
 4397 0001 89        		.byte	-119
 4398 0002 01        		.byte	1
 4399 0003 00        		.byte	0
 4400 0004 A0        		.byte	-96
 4401 0005 85        		.byte	-123
 4402 0006 01        		.byte	1
 4403 0007 00        		.byte	0
 4404 0008 90        		.byte	-112
 4405 0009 83        		.byte	-125
 4406 000a 01        		.byte	1
 4407 000b 00        		.byte	0
 4408 000c 80        		.byte	-128
 4409 000d 81        		.byte	-127
 4410 000e 01        		.byte	1
 4411 000f 00        		.byte	0
 4412 0010 70        		.byte	112
 4413 0011 7F        		.byte	127
 4414 0012 01        		.byte	1
 4415 0013 00        		.byte	0
 4416 0014 80        		.byte	-128
 4417 0015 7E        		.byte	126
 4418 0016 01        		.byte	1
 4419 0017 00        		.byte	0
 4420 0018 90        		.byte	-112
 4421 0019 7D        		.byte	125
 4422 001a 01        		.byte	1
 4423 001b 00        		.byte	0
 4424 001c A0        		.byte	-96
 4425 001d 7C        		.byte	124
 4426 001e 01        		.byte	1
 4427 001f 00        		.byte	0
 4428 0020 B0        		.byte	-80
 4429 0021 7B        		.byte	123
 4430 0022 01        		.byte	1
 4431 0023 00        		.byte	0
 4432 0024 C0        		.byte	-64
 4433 0025 7A        		.byte	122
 4434 0026 01        		.byte	1
 4435 0027 00        		.byte	0
 4436 0028 A0        		.byte	-96
 4437 0029 79        		.byte	121
 4438 002a 01        		.byte	1
 4439 002b 00        		.byte	0
 4440 002c 80        		.byte	-128
 4441 002d 78        		.byte	120
 4442 002e 01        		.byte	1
 4443 002f 00        		.byte	0
 4444 0030 60        		.byte	96
 4445 0031 77        		.byte	119
 4446 0032 01        		.byte	1
 4447 0033 00        		.byte	0
 4448 0034 40        		.byte	64
 4449 0035 76        		.byte	118
 4450 0036 01        		.byte	1
 4451 0037 00        		.byte	0
 4452 0038 20        		.byte	32
 4453 0039 75        		.byte	117
 4454 003a 01        		.byte	1
 4455 003b 00        		.byte	0
 4456 003c 90        		.byte	-112
 4457 003d 74        		.byte	116
 4458 003e 01        		.byte	1
 4459 003f 00        		.byte	0
 4460 0040 00        		.byte	0
 4461 0041 74        		.byte	116
 4462 0042 01        		.byte	1
 4463 0043 00        		.byte	0
 4464 0044 70        		.byte	112
 4465 0045 73        		.byte	115
 4466 0046 01        		.byte	1
 4467 0047 00        		.byte	0
 4468 0048 E0        		.byte	-32
 4469 0049 72        		.byte	114
 4470 004a 01        		.byte	1
 4471 004b 00        		.byte	0
 4472 004c 50        		.byte	80
 4473 004d 72        		.byte	114
 4474 004e 01        		.byte	1
 4475 004f 00        		.byte	0
 4476 0050 60        		.byte	96
 4477 0051 71        		.byte	113
 4478 0052 01        		.byte	1
 4479 0053 00        		.byte	0
 4480 0054 70        		.byte	112
 4481 0055 70        		.byte	112
 4482 0056 01        		.byte	1
 4483 0057 00        		.byte	0
 4484 0058 80        		.byte	-128
 4485 0059 6F        		.byte	111
 4486 005a 01        		.byte	1
 4487 005b 00        		.byte	0
 4488 005c 90        		.byte	-112
 4489 005d 6E        		.byte	110
 4490 005e 01        		.byte	1
 4491 005f 00        		.byte	0
 4492 0060 A0        		.byte	-96
 4493 0061 6D        		.byte	109
 4494 0062 01        		.byte	1
 4495 0063 00        		.byte	0
 4496 0064 F8        		.byte	-8
 4497 0065 6C        		.byte	108
 4498 0066 01        		.byte	1
 4499 0067 00        		.byte	0
 4500 0068 50        		.byte	80
 4501 0069 6C        		.byte	108
 4502 006a 01        		.byte	1
 4503 006b 00        		.byte	0
 4504 006c A8        		.byte	-88
 4505 006d 6B        		.byte	107
 4506 006e 01        		.byte	1
 4507 006f 00        		.byte	0
 4508 0070 00        		.byte	0
 4509 0071 6B        		.byte	107
 4510 0072 01        		.byte	1
 4511 0073 00        		.byte	0
 4512 0074 58        		.byte	88
 4513 0075 6A        		.byte	106
 4514 0076 01        		.byte	1
 4515 0077 00        		.byte	0
 4516 0078 B0        		.byte	-80
 4517 0079 69        		.byte	105
 4518 007a 01        		.byte	1
 4519 007b 00        		.byte	0
 4520 007c 08        		.byte	8
 4521 007d 69        		.byte	105
 4522 007e 01        		.byte	1
 4523 007f 00        		.byte	0
 4524 0080 60        		.byte	96
 4525 0081 68        		.byte	104
 4526 0082 01        		.byte	1
 4527 0083 00        		.byte	0
 4528 0084 B8        		.byte	-72
 4529 0085 67        		.byte	103
 4530 0086 01        		.byte	1
 4531 0087 00        		.byte	0
 4532 0088 10        		.byte	16
 4533 0089 67        		.byte	103
 4534 008a 01        		.byte	1
 4535 008b 00        		.byte	0
 4536 008c B0        		.byte	-80
 4537 008d 66        		.byte	102
 4538 008e 01        		.byte	1
 4539 008f 00        		.byte	0
 4540 0090 50        		.byte	80
 4541 0091 66        		.byte	102
 4542 0092 01        		.byte	1
 4543 0093 00        		.byte	0
 4544 0094 F0        		.byte	-16
 4545 0095 65        		.byte	101
 4546 0096 01        		.byte	1
 4547 0097 00        		.byte	0
 4548 0098 90        		.byte	-112
 4549 0099 65        		.byte	101
 4550 009a 01        		.byte	1
 4551 009b 00        		.byte	0
 4552 009c 30        		.byte	48
 4553 009d 65        		.byte	101
 4554 009e 01        		.byte	1
 4555 009f 00        		.byte	0
 4556 00a0 A0        		.byte	-96
 4557 00a1 64        		.byte	100
 4558 00a2 01        		.byte	1
 4559 00a3 00        		.byte	0
 4560 00a4 10        		.byte	16
 4561 00a5 64        		.byte	100
 4562 00a6 01        		.byte	1
 4563 00a7 00        		.byte	0
 4564 00a8 80        		.byte	-128
 4565 00a9 63        		.byte	99
 4566 00aa 01        		.byte	1
 4567 00ab 00        		.byte	0
 4568 00ac F0        		.byte	-16
 4569 00ad 62        		.byte	98
 4570 00ae 01        		.byte	1
 4571 00af 00        		.byte	0
 4572 00b0 60        		.byte	96
 4573 00b1 62        		.byte	98
 4574 00b2 01        		.byte	1
 4575 00b3 00        		.byte	0
 4576 00b4 30        		.byte	48
 4577 00b5 62        		.byte	98
 4578 00b6 01        		.byte	1
 4579 00b7 00        		.byte	0
 4580 00b8 00        		.byte	0
 4581 00b9 62        		.byte	98
 4582 00ba 01        		.byte	1
 4583 00bb 00        		.byte	0
 4584 00bc D0        		.byte	-48
 4585 00bd 61        		.byte	97
 4586 00be 01        		.byte	1
 4587 00bf 00        		.byte	0
 4588 00c0 A0        		.byte	-96
 4589 00c1 61        		.byte	97
 4590 00c2 01        		.byte	1
 4591 00c3 00        		.byte	0
 4592 00c4 70        		.byte	112
 4593 00c5 61        		.byte	97
 4594 00c6 01        		.byte	1
 4595 00c7 00        		.byte	0
 4596 00c8 10        		.byte	16
 4597 00c9 61        		.byte	97
 4598 00ca 01        		.byte	1
 4599 00cb 00        		.byte	0
 4600 00cc B0        		.byte	-80
 4601 00cd 60        		.byte	96
 4602 00ce 01        		.byte	1
 4603 00cf 00        		.byte	0
 4604 00d0 50        		.byte	80
 4605 00d1 60        		.byte	96
 4606 00d2 01        		.byte	1
 4607 00d3 00        		.byte	0
 4608 00d4 F0        		.byte	-16
 4609 00d5 5F        		.byte	95
 4610 00d6 01        		.byte	1
 4611 00d7 00        		.byte	0
 4612 00d8 90        		.byte	-112
 4613 00d9 5F        		.byte	95
 4614 00da 01        		.byte	1
 4615 00db 00        		.byte	0
 4616 00dc 78        		.byte	120
 4617 00dd 5F        		.byte	95
 4618 00de 01        		.byte	1
 4619 00df 00        		.byte	0
 4620 00e0 60        		.byte	96
 4621 00e1 5F        		.byte	95
 4622 00e2 01        		.byte	1
 4623 00e3 00        		.byte	0
 4624 00e4 48        		.byte	72
 4625 00e5 5F        		.byte	95
 4626 00e6 01        		.byte	1
 4627 00e7 00        		.byte	0
 4628 00e8 30        		.byte	48
 4629 00e9 5F        		.byte	95
 4630 00ea 01        		.byte	1
 4631 00eb 00        		.byte	0
 4632 00ec 18        		.byte	24
 4633 00ed 5F        		.byte	95
 4634 00ee 01        		.byte	1
 4635 00ef 00        		.byte	0
 4636 00f0 E8        		.byte	-24
 4637 00f1 5E        		.byte	94
 4638 00f2 01        		.byte	1
 4639 00f3 00        		.byte	0
 4640 00f4 B8        		.byte	-72
 4641 00f5 5E        		.byte	94
 4642 00f6 01        		.byte	1
 4643 00f7 00        		.byte	0
 4644 00f8 88        		.byte	-120
 4645 00f9 5E        		.byte	94
 4646 00fa 01        		.byte	1
 4647 00fb 00        		.byte	0
 4648 00fc 58        		.byte	88
 4649 00fd 5E        		.byte	94
 4650 00fe 01        		.byte	1
 4651 00ff 00        		.byte	0
 4652 0100 28        		.byte	40
 4653 0101 5E        		.byte	94
 4654 0102 01        		.byte	1
 4655 0103 00        		.byte	0
 4656 0104 E0        		.byte	-32
 4657 0105 5D        		.byte	93
 4658 0106 01        		.byte	1
 4659 0107 00        		.byte	0
 4660 0108 98        		.byte	-104
 4661 0109 5D        		.byte	93
 4662 010a 01        		.byte	1
 4663 010b 00        		.byte	0
 4664 010c 50        		.byte	80
 4665 010d 5D        		.byte	93
 4666 010e 01        		.byte	1
 4667 010f 00        		.byte	0
 4668 0110 08        		.byte	8
 4669 0111 5D        		.byte	93
 4670 0112 01        		.byte	1
 4671 0113 00        		.byte	0
 4672 0114 C0        		.byte	-64
 4673 0115 5C        		.byte	92
 4674 0116 01        		.byte	1
 4675 0117 00        		.byte	0
 4676 0118 90        		.byte	-112
 4677 0119 5C        		.byte	92
 4678 011a 01        		.byte	1
 4679 011b 00        		.byte	0
 4680 011c 60        		.byte	96
 4681 011d 5C        		.byte	92
 4682 011e 01        		.byte	1
 4683 011f 00        		.byte	0
 4684 0120 30        		.byte	48
 4685 0121 5C        		.byte	92
 4686 0122 01        		.byte	1
 4687 0123 00        		.byte	0
 4688 0124 00        		.byte	0
 4689 0125 5C        		.byte	92
 4690 0126 01        		.byte	1
 4691 0127 00        		.byte	0
 4692 0128 D0        		.byte	-48
 4693 0129 5B        		.byte	91
 4694 012a 01        		.byte	1
 4695 012b 00        		.byte	0
 4696 012c 10        		.byte	16
 4697 012d 5B        		.byte	91
 4698 012e 01        		.byte	1
 4699 012f 00        		.byte	0
 4700 0130 50        		.byte	80
 4701 0131 5A        		.byte	90
 4702 0132 01        		.byte	1
 4703 0133 00        		.byte	0
 4704 0134 90        		.byte	-112
 4705 0135 59        		.byte	89
 4706 0136 01        		.byte	1
 4707 0137 00        		.byte	0
 4708 0138 D0        		.byte	-48
 4709 0139 58        		.byte	88
 4710 013a 01        		.byte	1
 4711 013b 00        		.byte	0
 4712 013c 10        		.byte	16
 4713 013d 58        		.byte	88
 4714 013e 01        		.byte	1
 4715 013f 00        		.byte	0
 4716 0140 80        		.byte	-128
 4717 0141 57        		.byte	87
 4718 0142 01        		.byte	1
 4719 0143 00        		.byte	0
 4720 0144 F0        		.byte	-16
 4721 0145 56        		.byte	86
 4722 0146 01        		.byte	1
 4723 0147 00        		.byte	0
 4724 0148 60        		.byte	96
 4725 0149 56        		.byte	86
 4726 014a 01        		.byte	1
 4727 014b 00        		.byte	0
 4728 014c D0        		.byte	-48
 4729 014d 55        		.byte	85
 4730 014e 01        		.byte	1
 4731 014f 00        		.byte	0
 4732 0150 40        		.byte	64
 4733 0151 55        		.byte	85
 4734 0152 01        		.byte	1
 4735 0153 00        		.byte	0
 4736 0154 80        		.byte	-128
 4737 0155 54        		.byte	84
 4738 0156 01        		.byte	1
 4739 0157 00        		.byte	0
 4740 0158 C0        		.byte	-64
 4741 0159 53        		.byte	83
 4742 015a 01        		.byte	1
 4743 015b 00        		.byte	0
 4744 015c 00        		.byte	0
 4745 015d 53        		.byte	83
 4746 015e 01        		.byte	1
 4747 015f 00        		.byte	0
 4748 0160 40        		.byte	64
 4749 0161 52        		.byte	82
 4750 0162 01        		.byte	1
 4751 0163 00        		.byte	0
 4752 0164 80        		.byte	-128
 4753 0165 51        		.byte	81
 4754 0166 01        		.byte	1
 4755 0167 00        		.byte	0
 4756 0168 B0        		.byte	-80
 4757 0169 4E        		.byte	78
 4758 016a 01        		.byte	1
 4759 016b 00        		.byte	0
 4760 016c E0        		.byte	-32
 4761 016d 4B        		.byte	75
 4762 016e 01        		.byte	1
 4763 016f 00        		.byte	0
 4764 0170 10        		.byte	16
 4765 0171 49        		.byte	73
 4766 0172 01        		.byte	1
 4767 0173 00        		.byte	0
 4768 0174 40        		.byte	64
 4769 0175 46        		.byte	70
 4770 0176 01        		.byte	1
 4771 0177 00        		.byte	0
 4772 0178 70        		.byte	112
 4773 0179 43        		.byte	67
 4774 017a 01        		.byte	1
 4775 017b 00        		.byte	0
 4776 017c 00        		.byte	0
 4777 017d 3B        		.byte	59
 4778 017e 01        		.byte	1
 4779 017f 00        		.byte	0
 4780 0180 90        		.byte	-112
 4781 0181 32        		.byte	50
 4782 0182 01        		.byte	1
 4783 0183 00        		.byte	0
 4784 0184 20        		.byte	32
 4785 0185 2A        		.byte	42
 4786 0186 01        		.byte	1
 4787 0187 00        		.byte	0
 4788 0188 B0        		.byte	-80
 4789 0189 21        		.byte	33
 4790 018a 01        		.byte	1
 4791 018b 00        		.byte	0
 4792 018c 40        		.byte	64
 4793 018d 19        		.byte	25
 4794 018e 01        		.byte	1
 4795 018f 00        		.byte	0
 4796               		.comm	cmuData,102,1
 4797               		.comm	MCP2515_retrievedData,8,1
 4798               	.global	MCP2515_InterruptWaiting
 4799               		.section .bss
 4802               	MCP2515_InterruptWaiting:
 4803 0000 00        		.zero	1
 4804               	.global	CMUHealthByte
 4807               	CMUHealthByte:
 4808 0001 00        		.zero	1
 4809               	.global	CMUAudit
 4812               	CMUAudit:
 4813 0002 00        		.zero	1
 4814               	.global	coulombCount
 4817               	coulombCount:
 4818 0003 0000      		.zero	2
 4819               	.global	CMU_data_count
 4822               	CMU_data_count:
 4823 0005 00        		.zero	1
 4824               	.global	globalTicks
 4827               	globalTicks:
 4828 0006 0000      		.zero	2
 4829               	.global	CMURegistrationCount
 4832               	CMURegistrationCount:
 4833 0008 00        		.zero	1
 4834               	.global	CMUAllRegistered
 4837               	CMUAllRegistered:
 4838 0009 00        		.zero	1
 4839               	.global	CMUTimeToScan
 4842               	CMUTimeToScan:
 4843 000a 00        		.zero	1
 4844               	.global	CMUAuditTimeout
 4845               		.data
 4848               	CMUAuditTimeout:
 4849 0190 02        		.byte	2
 4850               	.global	CMUScanInterval
 4853               	CMUScanInterval:
 4854 0191 0A        		.byte	10
 4855               	.global	timerCounter
 4856               		.section .bss
 4859               	timerCounter:
 4860 000b 0000      		.zero	2
 4861               	.global	CMURxPacketCount
 4864               	CMURxPacketCount:
 4865 000d 00        		.zero	1
 4866               		.comm	fw_version,2,1
 4867               		.comm	warningLight,1,1
 4868               		.comm	deviceID,2,1
 4869               		.text
 4870               	.Letext0:
 4871               		.file 3 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdint.h"
 4872               		.file 4 "main.h"
 4873               		.file 5 "AtmelCAN.h"
 4874               		.file 6 "MCP2515.h"
 4875               		.file 7 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4      *ABS*:000000000000003f __SREG__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:13     .text.AMU_eeprom_read:0000000000000000 AMU_eeprom_read
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:39     .text.AMU_eeprom_write:0000000000000000 AMU_eeprom_write
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:63     .text.Parameters_init:0000000000000000 Parameters_init
                            *COM*:0000000000000002 deviceID
                            *COM*:0000000000000002 fw_version
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:98     .text.PCINT_init:0000000000000000 PCINT_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:128    .text.init_cmuData:0000000000000000 init_cmuData
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:199    .text.IO_init:0000000000000000 IO_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:248    .text.timer_init:0000000000000000 timer_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:276    .text.ADC_init:0000000000000000 ADC_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:308    .text.ADC_read:0000000000000000 ADC_read
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:381    .text.CMU_send_read_receipt:0000000000000000 CMU_send_read_receipt
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:461    .text.CMU_Register.part.0:0000000000000000 CMU_Register.part.0
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4837   .bss:0000000000000009 CMUAllRegistered
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4812   .bss:0000000000000002 CMUAudit
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:567    .text.CoulombCount_init:0000000000000000 CoulombCount_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:587    .text.CoulombCount_instRead:0000000000000000 CoulombCount_instRead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:606    .text.CoulombCount_updateAndRead:0000000000000000 CoulombCount_updateAndRead
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4827   .bss:0000000000000006 globalTicks
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:668    .text.SoC_voltageTranslation:0000000000000000 SoC_voltageTranslation
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4395   .data:0000000000000000 voltage2SoC_Translation
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:731    .text.SoC_calculation:0000000000000000 SoC_calculation
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:764    .text.CMU_send_audit_request:0000000000000000 CMU_send_audit_request
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:795    .text.CMU_Check_Registration_Status:0000000000000000 CMU_Check_Registration_Status
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4832   .bss:0000000000000008 CMURegistrationCount
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:859    .text.CMU_Wake:0000000000000000 CMU_Wake
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4864   .bss:000000000000000d CMURxPacketCount
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:908    .text.CMU_Wake_set:0000000000000000 CMU_Wake_set
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:931    .text.CMU_Wake_reset:0000000000000000 CMU_Wake_reset
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:951    .text.CMU_Register:0000000000000000 CMU_Register
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:972    .text.CMU_Store_Data:0000000000000000 CMU_Store_Data
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4822   .bss:0000000000000005 CMU_data_count
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:1294   .text.TX_cellTemps:0000000000000000 TX_cellTemps
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:1669   .text.TX_cellVoltage:0000000000000000 TX_cellVoltage
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2043   .text.TX_globalData:0000000000000000 TX_globalData
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2357   .text.LED_on:0000000000000000 LED_on
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2399   .text.LED_off:0000000000000000 LED_off
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2441   .text.flash_LED:0000000000000000 flash_LED
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2682   .text.error_state:0000000000000000 error_state
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2781   .text.CMU_process_inbound_message:0000000000000000 CMU_process_inbound_message
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:2965   .text.CMU_PollandProcess_RxBuffers:0000000000000000 CMU_PollandProcess_RxBuffers
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:3069   .text.startup.main:0000000000000000 main
                            *COM*:0000000000000066 cmuData
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4842   .bss:000000000000000a CMUTimeToScan
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:3839   .text.__vector_22:0000000000000000 __vector_22
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:3949   .text.__vector_18:0000000000000000 __vector_18
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4223   .text.__vector_17:0000000000000000 __vector_17
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4859   .bss:000000000000000b timerCounter
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4848   .data:0000000000000190 CMUAuditTimeout
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4853   .data:0000000000000191 CMUScanInterval
                            *COM*:0000000000000008 MCP2515_retrievedData
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4802   .bss:0000000000000000 MCP2515_InterruptWaiting
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4807   .bss:0000000000000001 CMUHealthByte
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccwHpcEl.s:4817   .bss:0000000000000003 coulombCount
                            *COM*:0000000000000001 warningLight

UNDEFINED SYMBOLS
eeprom_read_word
eeprom_write_word
MCP2515_reg_write
MCP2515_findFreeTxBuffer
MCP2515_TX
__udivmodhi4
MCP2515_RxBufferRead
CAN_findFreeTXMOB
CAN_TXMOB
__udivmodsi4
MCP2515_reg_read
MCP2515_receive_status
MCP2515_bit_modify
SPI_init
CAN_init
MCP2515_init
CAN_RXInit
MCP2515_FilterInit
MCP2515_RXInit
__do_copy_data
__do_clear_bss
