   1               		.file	"AtmelCAN.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CAN_init,"ax",@progbits
  11               	.global	CAN_init
  13               	CAN_init:
  14               	.LFB7:
  15               		.file 1 "AtmelCAN.c"
   1:AtmelCAN.c    **** /*
   2:AtmelCAN.c    ****  * AtmelCAN.c
   3:AtmelCAN.c    ****  *
   4:AtmelCAN.c    ****  * Created: 12/5/2015 5:13:51 PM
   5:AtmelCAN.c    ****  *  Author: julius
   6:AtmelCAN.c    ****  */ 
   7:AtmelCAN.c    **** #include "AtmelCAN.h"
   8:AtmelCAN.c    **** 
   9:AtmelCAN.c    **** int8_t CAN_sendTest()
  10:AtmelCAN.c    **** {
  11:AtmelCAN.c    **** 
  12:AtmelCAN.c    **** 	uint8_t tData [2] = {111,111};
  13:AtmelCAN.c    **** 	uint8_t mob = CAN_findFreeTXMOB();
  14:AtmelCAN.c    **** 	if(mob>=0)CAN_TXMOB(mob, 2, tData, 0, 20); //transmit registration and do not wait for finish
  15:AtmelCAN.c    **** 	return mob;
  16:AtmelCAN.c    **** }
  17:AtmelCAN.c    **** 
  18:AtmelCAN.c    **** uint8_t CAN_init()
  19:AtmelCAN.c    **** {
  16               		.loc 1 19 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  20:AtmelCAN.c    **** 	
  21:AtmelCAN.c    **** 	CANGCON = (1 << SWRES);     // Reset the CAN controller hardware and general registers.
  22               		.loc 1 21 2 view .LVU1
  23               		.loc 1 21 10 is_stmt 0 view .LVU2
  24 0000 81E0      		ldi r24,lo8(1)
  25 0002 8093 D800 		sts 216,r24
  22:AtmelCAN.c    **** 	for(uint8_t mobCount = 0; mobCount <= 5; mobCount++)
  26               		.loc 1 22 2 is_stmt 1 view .LVU3
  27               	.LBB13:
  28               		.loc 1 22 6 view .LVU4
  29               	.LVL0:
  30               		.loc 1 22 6 is_stmt 0 view .LVU5
  31               	.LBE13:
  21:AtmelCAN.c    **** 	for(uint8_t mobCount = 0; mobCount <= 5; mobCount++)
  32               		.loc 1 21 10 view .LVU6
  33 0006 80E0      		ldi r24,0
  34               	.LVL1:
  35               	.L2:
  36               	.LBB14:
  23:AtmelCAN.c    **** 	{
  24:AtmelCAN.c    **** 		CANPAGE = (mobCount << 4);		//select the message object to modify
  37               		.loc 1 24 3 is_stmt 1 discriminator 3 view .LVU7
  38               		.loc 1 24 11 is_stmt 0 discriminator 3 view .LVU8
  39 0008 8093 ED00 		sts 237,r24
  25:AtmelCAN.c    **** 		CANCDMOB = 0;					//make sure we do not do any actions on this mob.
  40               		.loc 1 25 3 is_stmt 1 discriminator 3 view .LVU9
  41               		.loc 1 25 12 is_stmt 0 discriminator 3 view .LVU10
  42 000c 1092 EF00 		sts 239,__zero_reg__
  26:AtmelCAN.c    **** 		CANSTMOB = 0;					//make sure no interrupts are set.
  43               		.loc 1 26 3 is_stmt 1 discriminator 3 view .LVU11
  44               		.loc 1 26 12 is_stmt 0 discriminator 3 view .LVU12
  45 0010 1092 EE00 		sts 238,__zero_reg__
  27:AtmelCAN.c    **** 		CANIDM1 = 0;
  46               		.loc 1 27 3 is_stmt 1 discriminator 3 view .LVU13
  47               		.loc 1 27 11 is_stmt 0 discriminator 3 view .LVU14
  48 0014 1092 F700 		sts 247,__zero_reg__
  28:AtmelCAN.c    **** 		CANIDM2 = 0;
  49               		.loc 1 28 3 is_stmt 1 discriminator 3 view .LVU15
  50               		.loc 1 28 11 is_stmt 0 discriminator 3 view .LVU16
  51 0018 1092 F600 		sts 246,__zero_reg__
  29:AtmelCAN.c    **** 		CANIDM3 = 0;
  52               		.loc 1 29 3 is_stmt 1 discriminator 3 view .LVU17
  53               		.loc 1 29 11 is_stmt 0 discriminator 3 view .LVU18
  54 001c 1092 F500 		sts 245,__zero_reg__
  30:AtmelCAN.c    **** 		CANIDM4 = 0;					//these registers are used to control the mask which filters incoming messages
  55               		.loc 1 30 3 is_stmt 1 discriminator 3 view .LVU19
  56               		.loc 1 30 11 is_stmt 0 discriminator 3 view .LVU20
  57 0020 1092 F400 		sts 244,__zero_reg__
  58               		.loc 1 30 11 discriminator 3 view .LVU21
  59 0024 805F      		subi r24,lo8(-(16))
  22:AtmelCAN.c    **** 	{
  60               		.loc 1 22 2 discriminator 3 view .LVU22
  61 0026 8036      		cpi r24,lo8(96)
  62 0028 01F4      		brne .L2
  63               	.LBE14:
  31:AtmelCAN.c    **** 	}
  32:AtmelCAN.c    **** 	CANBT1 = 0x0E;		//these registers control speed of communication
  64               		.loc 1 32 2 is_stmt 1 view .LVU23
  65               		.loc 1 32 9 is_stmt 0 view .LVU24
  66 002a 8EE0      		ldi r24,lo8(14)
  67 002c 8093 E200 		sts 226,r24
  33:AtmelCAN.c    **** 	CANBT2 = 0x04;		//currently with these values, it is 250kbps
  68               		.loc 1 33 2 is_stmt 1 view .LVU25
  69               		.loc 1 33 9 is_stmt 0 view .LVU26
  70 0030 84E0      		ldi r24,lo8(4)
  71 0032 8093 E300 		sts 227,r24
  34:AtmelCAN.c    **** 	CANBT3 = 0x13;		//with 8 TQ per bit.
  72               		.loc 1 34 2 is_stmt 1 view .LVU27
  73               		.loc 1 34 9 is_stmt 0 view .LVU28
  74 0036 83E1      		ldi r24,lo8(19)
  75 0038 8093 E400 		sts 228,r24
  35:AtmelCAN.c    **** 
  36:AtmelCAN.c    **** 	CANIE2 = (1 << IEMOB4)|(1 << IEMOB5);		//enable interrupts on MOB 4 and 5 for receiving
  76               		.loc 1 36 2 is_stmt 1 view .LVU29
  77               		.loc 1 36 9 is_stmt 0 view .LVU30
  78 003c 80E3      		ldi r24,lo8(48)
  79 003e 8093 DE00 		sts 222,r24
  37:AtmelCAN.c    **** 	CANGIE = (1 << ENRX)|(1 << ENIT);		//enable receive interrupt; enable global CAN interrupt (all in
  80               		.loc 1 37 2 is_stmt 1 view .LVU31
  81               		.loc 1 37 9 is_stmt 0 view .LVU32
  82 0042 80EA      		ldi r24,lo8(-96)
  83 0044 8093 DB00 		sts 219,r24
  38:AtmelCAN.c    **** 	//put other initialisation functions here.
  39:AtmelCAN.c    **** 
  40:AtmelCAN.c    **** 	CANGCON = (1 << ENASTB);    // Enable the CAN.
  84               		.loc 1 40 2 is_stmt 1 view .LVU33
  85               		.loc 1 40 10 is_stmt 0 view .LVU34
  86 0048 82E0      		ldi r24,lo8(2)
  87 004a 8093 D800 		sts 216,r24
  41:AtmelCAN.c    **** 	_delay_ms(50);
  88               		.loc 1 41 2 is_stmt 1 view .LVU35
  89               	.LVL2:
  90               	.LBB15:
  91               	.LBI15:
  92               		.file 2 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_ms(double __ms)
  93               		.loc 2 166 1 view .LVU36
  94               	.LBB16:
 167:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
  95               		.loc 2 168 2 view .LVU37
 169:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
  96               		.loc 2 172 2 view .LVU38
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
  97               		.loc 2 173 2 view .LVU39
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
  98               		.loc 2 174 2 view .LVU40
 175:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
  99               		.loc 2 184 3 view .LVU41
 185:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 100               		.loc 2 187 2 view .LVU42
 101 004e 2FEF      		ldi r18,lo8(159999)
 102 0050 80E7      		ldi r24,hi8(159999)
 103 0052 92E0      		ldi r25,hlo8(159999)
 104 0054 2150      	1:	subi r18,1
 105 0056 8040      		sbci r24,0
 106 0058 9040      		sbci r25,0
 107 005a 01F4      		brne 1b
 108 005c 00C0      		rjmp .
 109 005e 0000      		nop
 110               	.LVL3:
 111               		.loc 2 187 2 is_stmt 0 view .LVU43
 112               	.LBE16:
 113               	.LBE15:
  42:AtmelCAN.c    **** 	if(!(CANGSTA & (1<<ENFG)))return 1;
 114               		.loc 1 42 2 is_stmt 1 view .LVU44
 115               		.loc 1 42 7 is_stmt 0 view .LVU45
 116 0060 8091 D900 		lds r24,217
 117               		.loc 1 42 4 view .LVU46
 118 0064 82FB      		bst r24,2
 119 0066 8827      		clr r24
 120 0068 80F9      		bld r24,0
  43:AtmelCAN.c    **** 	return 0;
  44:AtmelCAN.c    **** }
 121               		.loc 1 44 1 view .LVU47
 122 006a 91E0      		ldi r25,lo8(1)
 123 006c 8927      		eor r24,r25
 124               	/* epilogue start */
 125 006e 0895      		ret
 126               		.cfi_endproc
 127               	.LFE7:
 129               		.section	.text.CAN_RXInit,"ax",@progbits
 130               	.global	CAN_RXInit
 132               	CAN_RXInit:
 133               	.LVL4:
 134               	.LFB8:
  45:AtmelCAN.c    **** 
  46:AtmelCAN.c    **** void CAN_RXInit(int8_t mob, uint8_t numBytes, uint32_t IDmsk, uint32_t ID)
  47:AtmelCAN.c    **** {
 135               		.loc 1 47 1 is_stmt 1 view -0
 136               		.cfi_startproc
 137               		.loc 1 47 1 is_stmt 0 view .LVU49
 138 0000 EF92      		push r14
 139               	.LCFI0:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 14, -2
 142 0002 FF92      		push r15
 143               	.LCFI1:
 144               		.cfi_def_cfa_offset 4
 145               		.cfi_offset 15, -3
 146 0004 0F93      		push r16
 147               	.LCFI2:
 148               		.cfi_def_cfa_offset 5
 149               		.cfi_offset 16, -4
 150 0006 1F93      		push r17
 151               	.LCFI3:
 152               		.cfi_def_cfa_offset 6
 153               		.cfi_offset 17, -5
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 4 */
 157               	.L__stack_usage = 4
  48:AtmelCAN.c    **** 	CANPAGE = ( mob << 4);		//use the mobth mob for receiving.
 158               		.loc 1 48 2 is_stmt 1 view .LVU50
 159               		.loc 1 48 18 is_stmt 0 view .LVU51
 160 0008 8295      		swap r24
 161               	.LVL5:
 162               		.loc 1 48 18 view .LVU52
 163 000a 807F      		andi r24,lo8(-16)
 164               		.loc 1 48 10 view .LVU53
 165 000c 8093 ED00 		sts 237,r24
  49:AtmelCAN.c    **** 	//IDEMSK is sent with the CAN packet, we choose to not require that it be set, and instead focus o
  50:AtmelCAN.c    **** 	CANIDM4 = (IDmsk<<03) & 0xF8;	//shifts the value sets RTRMSK to zero and IDEMSK to 0
 166               		.loc 1 50 2 is_stmt 1 view .LVU54
 167               		.loc 1 50 18 is_stmt 0 view .LVU55
 168 0010 822F      		mov r24,r18
 169 0012 880F      		lsl r24
 170 0014 880F      		lsl r24
 171 0016 880F      		lsl r24
 172               		.loc 1 50 10 view .LVU56
 173 0018 8093 F400 		sts 244,r24
  51:AtmelCAN.c    **** 	CANIDM3 = (IDmsk>>05) & 0xFF;
 174               		.loc 1 51 2 is_stmt 1 view .LVU57
 175               		.loc 1 51 18 is_stmt 0 view .LVU58
 176 001c DA01      		movw r26,r20
 177 001e C901      		movw r24,r18
 178 0020 75E0      		ldi r23,5
 179               		1:
 180 0022 B695      		lsr r27
 181 0024 A795      		ror r26
 182 0026 9795      		ror r25
 183 0028 8795      		ror r24
 184 002a 7A95      		dec r23
 185 002c 01F4      		brne 1b
 186               		.loc 1 51 10 view .LVU59
 187 002e 8093 F500 		sts 245,r24
  52:AtmelCAN.c    **** 	CANIDM2 = (IDmsk>>13) & 0xFF;	
 188               		.loc 1 52 2 is_stmt 1 view .LVU60
 189               		.loc 1 52 18 is_stmt 0 view .LVU61
 190 0032 DA01      		movw r26,r20
 191 0034 C901      		movw r24,r18
 192 0036 EDE0      		ldi r30,13
 193               		1:
 194 0038 B695      		lsr r27
 195 003a A795      		ror r26
 196 003c 9795      		ror r25
 197 003e 8795      		ror r24
 198 0040 EA95      		dec r30
 199 0042 01F4      		brne 1b
 200               		.loc 1 52 10 view .LVU62
 201 0044 8093 F600 		sts 246,r24
  53:AtmelCAN.c    **** 	CANIDM1 = (IDmsk>>21) & 0xFF;
 202               		.loc 1 53 2 is_stmt 1 view .LVU63
 203               		.loc 1 53 18 is_stmt 0 view .LVU64
 204 0048 F5E1      		ldi r31,21
 205               		1:
 206 004a 5695      		lsr r21
 207 004c 4795      		ror r20
 208 004e 3795      		ror r19
 209 0050 2795      		ror r18
 210 0052 FA95      		dec r31
 211 0054 01F4      		brne 1b
 212               	.LVL6:
 213               		.loc 1 53 10 view .LVU65
 214 0056 2093 F700 		sts 247,r18
  54:AtmelCAN.c    **** 	
  55:AtmelCAN.c    **** 	CANIDT4 = (ID<<03) & 0xF8;	//shifts the value sets RTRTAG, RB1TAG and RB0TAG to 0
 215               		.loc 1 55 2 is_stmt 1 view .LVU66
 216               		.loc 1 55 15 is_stmt 0 view .LVU67
 217 005a 8E2D      		mov r24,r14
 218 005c 880F      		lsl r24
 219 005e 880F      		lsl r24
 220 0060 880F      		lsl r24
 221               		.loc 1 55 10 view .LVU68
 222 0062 8093 F000 		sts 240,r24
  56:AtmelCAN.c    **** 	CANIDT3 = (ID>>05) & 0xFF;
 223               		.loc 1 56 2 is_stmt 1 view .LVU69
 224               		.loc 1 56 15 is_stmt 0 view .LVU70
 225 0066 D801      		movw r26,r16
 226 0068 C701      		movw r24,r14
 227 006a 25E0      		ldi r18,5
 228               		1:
 229 006c B695      		lsr r27
 230 006e A795      		ror r26
 231 0070 9795      		ror r25
 232 0072 8795      		ror r24
 233 0074 2A95      		dec r18
 234 0076 01F4      		brne 1b
 235               		.loc 1 56 10 view .LVU71
 236 0078 8093 F100 		sts 241,r24
  57:AtmelCAN.c    **** 	CANIDT2 = (ID>>13) & 0xFF;
 237               		.loc 1 57 2 is_stmt 1 view .LVU72
 238               		.loc 1 57 15 is_stmt 0 view .LVU73
 239 007c D801      		movw r26,r16
 240 007e C701      		movw r24,r14
 241 0080 3DE0      		ldi r19,13
 242               		1:
 243 0082 B695      		lsr r27
 244 0084 A795      		ror r26
 245 0086 9795      		ror r25
 246 0088 8795      		ror r24
 247 008a 3A95      		dec r19
 248 008c 01F4      		brne 1b
 249               		.loc 1 57 10 view .LVU74
 250 008e 8093 F200 		sts 242,r24
  58:AtmelCAN.c    **** 	CANIDT1 = (ID>>21) & 0xFF;
 251               		.loc 1 58 2 is_stmt 1 view .LVU75
 252               		.loc 1 58 15 is_stmt 0 view .LVU76
 253 0092 45E1      		ldi r20,21
 254               		1:
 255 0094 1695      		lsr r17
 256 0096 0795      		ror r16
 257 0098 F794      		ror r15
 258 009a E794      		ror r14
 259 009c 4A95      		dec r20
 260 009e 01F4      		brne 1b
 261               	.LVL7:
 262               		.loc 1 58 10 view .LVU77
 263 00a0 E092 F300 		sts 243,r14
  59:AtmelCAN.c    **** 	
  60:AtmelCAN.c    **** 	CANCDMOB = (numBytes << DLC0)|(2<<CONMOB0)|(1 << IDE);		//we are expecting only numBytes bytes; al
 264               		.loc 1 60 2 is_stmt 1 view .LVU78
 265               		.loc 1 60 44 is_stmt 0 view .LVU79
 266 00a4 6069      		ori r22,lo8(-112)
 267               	.LVL8:
 268               		.loc 1 60 11 view .LVU80
 269 00a6 6093 EF00 		sts 239,r22
 270               	/* epilogue start */
  61:AtmelCAN.c    **** }
 271               		.loc 1 61 1 view .LVU81
 272 00aa 1F91      		pop r17
 273 00ac 0F91      		pop r16
 274 00ae FF90      		pop r15
 275 00b0 EF90      		pop r14
 276 00b2 0895      		ret
 277               		.cfi_endproc
 278               	.LFE8:
 280               		.section	.text.CAN_TXMOB,"ax",@progbits
 281               	.global	CAN_TXMOB
 283               	CAN_TXMOB:
 284               	.LVL9:
 285               	.LFB9:
  62:AtmelCAN.c    **** 
  63:AtmelCAN.c    **** void CAN_TXMOB(int8_t mob, uint8_t numBytes, uint8_t * data, uint32_t ID, uint8_t ms_loop_until_TXO
  64:AtmelCAN.c    **** {
 286               		.loc 1 64 1 is_stmt 1 view -0
 287               		.cfi_startproc
 288               		.loc 1 64 1 is_stmt 0 view .LVU83
 289 0000 EF92      		push r14
 290               	.LCFI4:
 291               		.cfi_def_cfa_offset 3
 292               		.cfi_offset 14, -2
 293 0002 0F93      		push r16
 294               	.LCFI5:
 295               		.cfi_def_cfa_offset 4
 296               		.cfi_offset 16, -3
 297 0004 1F93      		push r17
 298               	.LCFI6:
 299               		.cfi_def_cfa_offset 5
 300               		.cfi_offset 17, -4
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 303               	/* stack size = 3 */
 304               	.L__stack_usage = 3
  65:AtmelCAN.c    **** 	CANPAGE = ( mob << 4);		//use the mobth mob
 305               		.loc 1 65 2 is_stmt 1 view .LVU84
 306               		.loc 1 65 18 is_stmt 0 view .LVU85
 307 0006 8295      		swap r24
 308               	.LVL10:
 309               		.loc 1 65 18 view .LVU86
 310 0008 807F      		andi r24,lo8(-16)
 311               		.loc 1 65 10 view .LVU87
 312 000a 8093 ED00 		sts 237,r24
  66:AtmelCAN.c    **** 	//IDEMSK is sent with the CAN packet, we choose to not set it, and instead the receiver will focus
  67:AtmelCAN.c    **** 	CANSTMOB &= ~(1<<TXOK);
 313               		.loc 1 67 2 is_stmt 1 view .LVU88
 314               		.loc 1 67 11 is_stmt 0 view .LVU89
 315 000e 8091 EE00 		lds r24,238
 316 0012 8F7B      		andi r24,lo8(-65)
 317 0014 8093 EE00 		sts 238,r24
  68:AtmelCAN.c    **** 	CANIDM4 = 0;
 318               		.loc 1 68 2 is_stmt 1 view .LVU90
 319               		.loc 1 68 10 is_stmt 0 view .LVU91
 320 0018 1092 F400 		sts 244,__zero_reg__
  69:AtmelCAN.c    **** 	
  70:AtmelCAN.c    **** 	CANIDT4 = (ID<<03) & 0xF8;	//shifts the value sets RTRTAG, RB1TAG and RB0TAG
 321               		.loc 1 70 2 is_stmt 1 view .LVU92
 322               		.loc 1 70 15 is_stmt 0 view .LVU93
 323 001c 802F      		mov r24,r16
 324 001e 880F      		lsl r24
 325 0020 880F      		lsl r24
 326 0022 880F      		lsl r24
 327               		.loc 1 70 10 view .LVU94
 328 0024 8093 F000 		sts 240,r24
  71:AtmelCAN.c    **** 	CANIDT3 = (ID>>05) & 0xFF;
 329               		.loc 1 71 2 is_stmt 1 view .LVU95
 330               		.loc 1 71 15 is_stmt 0 view .LVU96
 331 0028 D901      		movw r26,r18
 332 002a C801      		movw r24,r16
 333 002c 75E0      		ldi r23,5
 334               		1:
 335 002e B695      		lsr r27
 336 0030 A795      		ror r26
 337 0032 9795      		ror r25
 338 0034 8795      		ror r24
 339 0036 7A95      		dec r23
 340 0038 01F4      		brne 1b
 341               		.loc 1 71 10 view .LVU97
 342 003a 8093 F100 		sts 241,r24
  72:AtmelCAN.c    **** 	CANIDT2 = (ID>>13) & 0xFF;
 343               		.loc 1 72 2 is_stmt 1 view .LVU98
 344               		.loc 1 72 15 is_stmt 0 view .LVU99
 345 003e D901      		movw r26,r18
 346 0040 C801      		movw r24,r16
 347 0042 EDE0      		ldi r30,13
 348               		1:
 349 0044 B695      		lsr r27
 350 0046 A795      		ror r26
 351 0048 9795      		ror r25
 352 004a 8795      		ror r24
 353 004c EA95      		dec r30
 354 004e 01F4      		brne 1b
 355               		.loc 1 72 10 view .LVU100
 356 0050 8093 F200 		sts 242,r24
  73:AtmelCAN.c    **** 	CANIDT1 = (ID>>21) & 0xFF;
 357               		.loc 1 73 2 is_stmt 1 view .LVU101
 358               		.loc 1 73 15 is_stmt 0 view .LVU102
 359 0054 F5E1      		ldi r31,21
 360               		1:
 361 0056 3695      		lsr r19
 362 0058 2795      		ror r18
 363 005a 1795      		ror r17
 364 005c 0795      		ror r16
 365 005e FA95      		dec r31
 366 0060 01F4      		brne 1b
 367               	.LVL11:
 368               		.loc 1 73 10 view .LVU103
 369 0062 0093 F300 		sts 243,r16
  74:AtmelCAN.c    **** 	for(uint8_t i = 0; i < numBytes; i++)
 370               		.loc 1 74 2 is_stmt 1 view .LVU104
 371               		.loc 1 74 6 view .LVU105
 372               	.LVL12:
 373               		.loc 1 74 6 is_stmt 0 view .LVU106
 374 0066 942F      		mov r25,r20
  73:AtmelCAN.c    **** 	CANIDT1 = (ID>>21) & 0xFF;
 375               		.loc 1 73 10 view .LVU107
 376 0068 FA01      		movw r30,r20
 377               	.L6:
 378               	.LVL13:
 379               	.LBB26:
 380               	.LBB27:
 381               	.LBB28:
 382               		.loc 1 74 2 view .LVU108
 383 006a 8E2F      		mov r24,r30
 384 006c 891B      		sub r24,r25
 385 006e 8617      		cp r24,r22
 386 0070 00F0      		brlo .L7
 387               	.LBE28:
  75:AtmelCAN.c    **** 	{
  76:AtmelCAN.c    **** 		CANMSG = data[i];
  77:AtmelCAN.c    **** 	}
  78:AtmelCAN.c    **** 	CANCDMOB = (numBytes << DLC0)|(1<<CONMOB0)|(1 << IDE);		//we are expecting only numBytes bytes; al
 388               		.loc 1 78 2 is_stmt 1 view .LVU109
 389               		.loc 1 78 44 is_stmt 0 view .LVU110
 390 0072 6065      		ori r22,lo8(80)
 391               	.LVL14:
 392               		.loc 1 78 11 view .LVU111
 393 0074 6093 EF00 		sts 239,r22
  79:AtmelCAN.c    **** 
  80:AtmelCAN.c    **** 	for(uint8_t i = 0; i < ms_loop_until_TXOK; i++)	//loop until specified wait time is up
 394               		.loc 1 80 2 is_stmt 1 view .LVU112
 395               	.LBB29:
 396               		.loc 1 80 6 view .LVU113
 397               	.LVL15:
 398               		.loc 1 80 14 is_stmt 0 view .LVU114
 399 0078 80E0      		ldi r24,0
 400               	.LVL16:
 401               	.L8:
 402               		.loc 1 80 2 view .LVU115
 403 007a E812      		cpse r14,r24
 404 007c 00C0      		rjmp .L10
 405               	.L5:
 406               	/* epilogue start */
 407               	.LBE29:
 408               	.LBE27:
 409               	.LBE26:
  81:AtmelCAN.c    **** 	{
  82:AtmelCAN.c    **** 		if((CANSTMOB & (1 << TXOK)))break;		//check for transmission complete
  83:AtmelCAN.c    **** 		_delay_ms(1);								//do nothing for 1 ms
  84:AtmelCAN.c    **** 	}
  85:AtmelCAN.c    **** }
 410               		.loc 1 85 1 view .LVU116
 411 007e 1F91      		pop r17
 412 0080 0F91      		pop r16
 413 0082 EF90      		pop r14
 414               	.LVL17:
 415               		.loc 1 85 1 view .LVU117
 416 0084 0895      		ret
 417               	.LVL18:
 418               	.L7:
 419               	.LBB35:
 420               	.LBB34:
 421               	.LBB32:
  76:AtmelCAN.c    **** 	}
 422               		.loc 1 76 3 is_stmt 1 view .LVU118
  76:AtmelCAN.c    **** 	}
 423               		.loc 1 76 16 is_stmt 0 view .LVU119
 424 0086 8191      		ld r24,Z+
 425               	.LVL19:
  76:AtmelCAN.c    **** 	}
 426               		.loc 1 76 10 view .LVU120
 427 0088 8093 FA00 		sts 250,r24
 428               	.LVL20:
  76:AtmelCAN.c    **** 	}
 429               		.loc 1 76 10 view .LVU121
 430 008c 00C0      		rjmp .L6
 431               	.LVL21:
 432               	.L10:
  76:AtmelCAN.c    **** 	}
 433               		.loc 1 76 10 view .LVU122
 434               	.LBE32:
 435               	.LBB33:
  82:AtmelCAN.c    **** 		_delay_ms(1);								//do nothing for 1 ms
 436               		.loc 1 82 3 is_stmt 1 view .LVU123
  82:AtmelCAN.c    **** 		_delay_ms(1);								//do nothing for 1 ms
 437               		.loc 1 82 7 is_stmt 0 view .LVU124
 438 008e 9091 EE00 		lds r25,238
  82:AtmelCAN.c    **** 		_delay_ms(1);								//do nothing for 1 ms
 439               		.loc 1 82 5 view .LVU125
 440 0092 96FD      		sbrc r25,6
 441 0094 00C0      		rjmp .L5
  83:AtmelCAN.c    **** 	}
 442               		.loc 1 83 3 is_stmt 1 view .LVU126
 443               	.LVL22:
 444               	.LBB30:
 445               	.LBI30:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 446               		.loc 2 166 1 view .LVU127
 447               	.LBB31:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 448               		.loc 2 168 2 view .LVU128
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 449               		.loc 2 172 2 view .LVU129
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 450               		.loc 2 173 2 view .LVU130
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 451               		.loc 2 174 2 view .LVU131
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 452               		.loc 2 184 3 view .LVU132
 453               		.loc 2 187 2 view .LVU133
 454 0096 EFE9      		ldi r30,lo8(3999)
 455 0098 FFE0      		ldi r31,hi8(3999)
 456 009a 3197      	1:	sbiw r30,1
 457 009c 01F4      		brne 1b
 458 009e 00C0      		rjmp .
 459 00a0 0000      		nop
 460               	.LVL23:
 461               		.loc 2 187 2 is_stmt 0 view .LVU134
 462               	.LBE31:
 463               	.LBE30:
  80:AtmelCAN.c    **** 	{
 464               		.loc 1 80 46 view .LVU135
 465 00a2 8F5F      		subi r24,lo8(-(1))
 466               	.LVL24:
  80:AtmelCAN.c    **** 	{
 467               		.loc 1 80 46 view .LVU136
 468 00a4 00C0      		rjmp .L8
 469               	.LBE33:
 470               	.LBE34:
 471               	.LBE35:
 472               		.cfi_endproc
 473               	.LFE9:
 475               		.section	.text.CAN_findFreeTXMOB,"ax",@progbits
 476               	.global	CAN_findFreeTXMOB
 478               	CAN_findFreeTXMOB:
 479               	.LFB10:
  86:AtmelCAN.c    **** 
  87:AtmelCAN.c    **** int8_t CAN_findFreeTXMOB()
  88:AtmelCAN.c    **** {
 480               		.loc 1 88 1 is_stmt 1 view -0
 481               		.cfi_startproc
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
  89:AtmelCAN.c    **** 	for(uint8_t i = 0; i < 4; i++) //tx mobs are 0 to 3 (<4)
 486               		.loc 1 89 2 view .LVU138
 487               	.LBB36:
 488               		.loc 1 89 6 view .LVU139
 489               	.LVL25:
 490               		.loc 1 89 6 is_stmt 0 view .LVU140
 491               	.LBE36:
  88:AtmelCAN.c    **** 	for(uint8_t i = 0; i < 4; i++) //tx mobs are 0 to 3 (<4)
 492               		.loc 1 88 1 view .LVU141
 493 0000 90E0      		ldi r25,0
 494               	.LBB37:
 495               		.loc 1 89 14 view .LVU142
 496 0002 80E0      		ldi r24,0
 497               	.LVL26:
 498               	.L15:
  90:AtmelCAN.c    **** 	{
  91:AtmelCAN.c    **** 		CANPAGE = ( i << 4);		//use the mobth mob
 499               		.loc 1 91 3 is_stmt 1 view .LVU143
 500               		.loc 1 91 11 is_stmt 0 view .LVU144
 501 0004 9093 ED00 		sts 237,r25
  92:AtmelCAN.c    **** 		if((CANSTMOB & ((1<<TXOK)|(1<<BERR)|(1<<SERR)|(1<<FERR)|(1<<CERR)) || !(CANCDMOB & (1<<CONMOB0)))
 502               		.loc 1 92 3 is_stmt 1 view .LVU145
 503               		.loc 1 92 7 is_stmt 0 view .LVU146
 504 0008 2091 EE00 		lds r18,238
 505               		.loc 1 92 5 view .LVU147
 506 000c 2E75      		andi r18,lo8(94)
 507 000e 01F4      		brne .L11
 508               		.loc 1 92 75 discriminator 1 view .LVU148
 509 0010 2091 EF00 		lds r18,239
 510               		.loc 1 92 70 discriminator 1 view .LVU149
 511 0014 26FF      		sbrs r18,6
 512 0016 00C0      		rjmp .L11
  89:AtmelCAN.c    **** 	{
 513               		.loc 1 89 29 discriminator 2 view .LVU150
 514 0018 8F5F      		subi r24,lo8(-(1))
 515               	.LVL27:
  89:AtmelCAN.c    **** 	{
 516               		.loc 1 89 29 discriminator 2 view .LVU151
 517 001a 905F      		subi r25,lo8(-(16))
  89:AtmelCAN.c    **** 	{
 518               		.loc 1 89 2 discriminator 2 view .LVU152
 519 001c 8430      		cpi r24,lo8(4)
 520 001e 01F4      		brne .L15
 521               	.LBE37:
  93:AtmelCAN.c    **** 		{
  94:AtmelCAN.c    **** 			return i;			//send back the free mob
  95:AtmelCAN.c    **** 		}
  96:AtmelCAN.c    **** 	}
  97:AtmelCAN.c    **** 	return -1;		//otherwise, none are free
 522               		.loc 1 97 9 view .LVU153
 523 0020 8FEF      		ldi r24,lo8(-1)
 524               	.LVL28:
 525               	.L11:
 526               	/* epilogue start */
  98:AtmelCAN.c    **** }...
 527               		.loc 1 98 1 view .LVU154
 528 0022 0895      		ret
 529               		.cfi_endproc
 530               	.LFE10:
 532               		.section	.text.CAN_sendTest,"ax",@progbits
 533               	.global	CAN_sendTest
 535               	CAN_sendTest:
 536               	.LFB6:
  10:AtmelCAN.c    **** {
 537               		.loc 1 10 1 is_stmt 1 view -0
 538               		.cfi_startproc
 539 0000 EF92      		push r14
 540               	.LCFI7:
 541               		.cfi_def_cfa_offset 3
 542               		.cfi_offset 14, -2
 543 0002 FF92      		push r15
 544               	.LCFI8:
 545               		.cfi_def_cfa_offset 4
 546               		.cfi_offset 15, -3
 547 0004 0F93      		push r16
 548               	.LCFI9:
 549               		.cfi_def_cfa_offset 5
 550               		.cfi_offset 16, -4
 551 0006 1F93      		push r17
 552               	.LCFI10:
 553               		.cfi_def_cfa_offset 6
 554               		.cfi_offset 17, -5
 555 0008 CF93      		push r28
 556               	.LCFI11:
 557               		.cfi_def_cfa_offset 7
 558               		.cfi_offset 28, -6
 559 000a DF93      		push r29
 560               	.LCFI12:
 561               		.cfi_def_cfa_offset 8
 562               		.cfi_offset 29, -7
 563 000c 00D0      		rcall .
 564               	.LCFI13:
 565               		.cfi_def_cfa_offset 10
 566 000e CDB7      		in r28,__SP_L__
 567 0010 DEB7      		in r29,__SP_H__
 568               	.LCFI14:
 569               		.cfi_def_cfa_register 28
 570               	/* prologue: function */
 571               	/* frame size = 2 */
 572               	/* stack size = 8 */
 573               	.L__stack_usage = 8
  12:AtmelCAN.c    **** 	uint8_t tData [2] = {111,111};
 574               		.loc 1 12 2 view .LVU156
  12:AtmelCAN.c    **** 	uint8_t tData [2] = {111,111};
 575               		.loc 1 12 10 is_stmt 0 view .LVU157
 576 0012 8FE6      		ldi r24,lo8(111)
 577 0014 8983      		std Y+1,r24
 578 0016 8A83      		std Y+2,r24
  13:AtmelCAN.c    **** 	uint8_t mob = CAN_findFreeTXMOB();
 579               		.loc 1 13 2 is_stmt 1 view .LVU158
  13:AtmelCAN.c    **** 	uint8_t mob = CAN_findFreeTXMOB();
 580               		.loc 1 13 16 is_stmt 0 view .LVU159
 581 0018 0E94 0000 		call CAN_findFreeTXMOB
 582               	.LVL29:
 583 001c F82E      		mov r15,r24
 584               	.LVL30:
  14:AtmelCAN.c    **** 	if(mob>=0)CAN_TXMOB(mob, 2, tData, 0, 20); //transmit registration and do not wait for finish
 585               		.loc 1 14 2 is_stmt 1 view .LVU160
  14:AtmelCAN.c    **** 	if(mob>=0)CAN_TXMOB(mob, 2, tData, 0, 20); //transmit registration and do not wait for finish
 586               		.loc 1 14 12 view .LVU161
 587 001e 84E1      		ldi r24,lo8(20)
 588 0020 E82E      		mov r14,r24
 589 0022 00E0      		ldi r16,0
 590 0024 10E0      		ldi r17,0
 591 0026 9801      		movw r18,r16
 592 0028 AE01      		movw r20,r28
 593 002a 4F5F      		subi r20,-1
 594 002c 5F4F      		sbci r21,-1
 595 002e 62E0      		ldi r22,lo8(2)
 596 0030 8F2D      		mov r24,r15
 597 0032 0E94 0000 		call CAN_TXMOB
 598               	.LVL31:
  15:AtmelCAN.c    **** 	return mob;
 599               		.loc 1 15 2 view .LVU162
  16:AtmelCAN.c    **** }
 600               		.loc 1 16 1 is_stmt 0 view .LVU163
 601 0036 8F2D      		mov r24,r15
 602               	/* epilogue start */
 603 0038 0F90      		pop __tmp_reg__
 604 003a 0F90      		pop __tmp_reg__
 605 003c DF91      		pop r29
 606 003e CF91      		pop r28
 607 0040 1F91      		pop r17
 608 0042 0F91      		pop r16
 609 0044 FF90      		pop r15
 610               	.LVL32:
  16:AtmelCAN.c    **** }
 611               		.loc 1 16 1 view .LVU164
 612 0046 EF90      		pop r14
 613 0048 0895      		ret
 614               		.cfi_endproc
 615               	.LFE6:
 617               		.text
 618               	.Letext0:
 619               		.file 3 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 AtmelCAN.c
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:4      *ABS*:000000000000003f __SREG__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:13     .text.CAN_init:0000000000000000 CAN_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:132    .text.CAN_RXInit:0000000000000000 CAN_RXInit
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:283    .text.CAN_TXMOB:0000000000000000 CAN_TXMOB
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:478    .text.CAN_findFreeTXMOB:0000000000000000 CAN_findFreeTXMOB
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccpaXKmv.s:535    .text.CAN_sendTest:0000000000000000 CAN_sendTest

NO UNDEFINED SYMBOLS
