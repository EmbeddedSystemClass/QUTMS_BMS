   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.IO_init,"ax",@progbits
  11               	.global	IO_init
  13               	IO_init:
  14               	.LFB11:
  15               		.file 1 "main.c"
   1:main.c        **** /*
   2:main.c        ****  * Atmel_QUTMS_CMU.c
   3:main.c        ****  *
   4:main.c        ****  * Created: 3/07/2016 10:41:03 AM
   5:main.c        ****  *  Author: julius
   6:main.c        ****  */ 
   7:main.c        **** 
   8:main.c        **** #include "main.h"
   9:main.c        **** 
  10:main.c        **** void IO_init()
  11:main.c        **** {
  16               		.loc 1 11 1 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  12:main.c        **** 
  13:main.c        **** 	DDRD = 0b10011111;		//7 for discharge cell 4; 2,3,4 for multiplex selector; 0 for wake out, 1 for 
  22               		.loc 1 13 2 view .LVU1
  23               		.loc 1 13 7 is_stmt 0 view .LVU2
  24 0000 8FE9      		ldi r24,lo8(-97)
  25 0002 8AB9      		out 0xa,r24
  14:main.c        **** 	DDRC = 0b10000110;		//7 and 1 for cell balancing; 6,5 and 4 for ADC in; 3 for CAN Rx; 2 for CAN Tx
  26               		.loc 1 14 2 is_stmt 1 view .LVU3
  27               		.loc 1 14 7 is_stmt 0 view .LVU4
  28 0004 86E8      		ldi r24,lo8(-122)
  29 0006 87B9      		out 0x7,r24
  15:main.c        **** 	DDRB = 0b00011011;		//7, 6, 5 and 2 for ADC in; 4, 3, 1 and 0 for cell balance.
  30               		.loc 1 15 2 is_stmt 1 view .LVU5
  31               		.loc 1 15 7 is_stmt 0 view .LVU6
  32 0008 8BE1      		ldi r24,lo8(27)
  33 000a 84B9      		out 0x4,r24
  16:main.c        **** 	
  17:main.c        **** 	EICRA = (1<<ISC31)|(1<<ISC30);	//0b11000000	//to enable rising edge of INT3 on PINC0 to cause an e
  34               		.loc 1 17 2 is_stmt 1 view .LVU7
  35               		.loc 1 17 8 is_stmt 0 view .LVU8
  36 000c 80EC      		ldi r24,lo8(-64)
  37 000e 8093 6900 		sts 105,r24
  18:main.c        **** 	EIMSK = (1<<INT3);				//this may not be legal, the data sheet said it was read only, otherwise it 
  38               		.loc 1 18 2 is_stmt 1 view .LVU9
  39               		.loc 1 18 8 is_stmt 0 view .LVU10
  40 0012 88E0      		ldi r24,lo8(8)
  41 0014 8DBB      		out 0x1d,r24
  19:main.c        **** 	//EIFR bits INTF3..0 hold information on whether the interrupt has occurred.
  20:main.c        **** 	//PCICR is useful when using the level change is being used to indicate the interrupt. hi-low or l
  21:main.c        **** 	sei();
  42               		.loc 1 21 2 is_stmt 1 view .LVU11
  43               	/* #APP */
  44               	 ;  21 "main.c" 1
  45 0016 7894      		sei
  46               	 ;  0 "" 2
  47               	/* #NOAPP */
  48               	/* epilogue start */
  22:main.c        **** }
  49               		.loc 1 22 1 is_stmt 0 view .LVU12
  50 0018 0895      		ret
  51               		.cfi_endproc
  52               	.LFE11:
  54               		.section	.text.ADC_init,"ax",@progbits
  55               	.global	ADC_init
  57               	ADC_init:
  58               	.LFB13:
  23:main.c        **** 
  24:main.c        **** void Parameters_init()
  25:main.c        **** {
  26:main.c        **** 	deviceID  = CMU_eeprom_read(EEPROM_DEVICE_ID);
  27:main.c        **** 	ADC_SAMPLES  = CMU_eeprom_read(EEPROM_ADC_SAMPLES);
  28:main.c        **** 	fw_version = CMU_eeprom_read(EEPROM_FW_VERSION);
  29:main.c        **** 	CELL_V_DIFF_MAX_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MAX_THRESHOLD);
  30:main.c        **** 	CELL_V_DIFF_MIN_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MIN_THRESHOLD);
  31:main.c        **** 	DISCHARGE_SCALE = CMU_eeprom_read(EEPROM_DISCHARGE_SCALE);
  32:main.c        **** 	EEPROMWriteComplete = 0;
  33:main.c        **** }
  34:main.c        **** 
  35:main.c        **** void ADC_init()
  36:main.c        **** {
  59               		.loc 1 36 1 is_stmt 1 view -0
  60               		.cfi_startproc
  61               	/* prologue: function */
  62               	/* frame size = 0 */
  63               	/* stack size = 0 */
  64               	.L__stack_usage = 0
  37:main.c        **** 	ADMUX=(1<<REFS0)|(1<<AREFEN);                      // For Aref=AVcc with external capacitor;
  65               		.loc 1 37 2 view .LVU14
  66               		.loc 1 37 7 is_stmt 0 view .LVU15
  67 0000 ECE7      		ldi r30,lo8(124)
  68 0002 F0E0      		ldi r31,0
  69 0004 80E6      		ldi r24,lo8(96)
  70 0006 8083      		st Z,r24
  38:main.c        **** 	ADMUX &= ~(1<<ADLAR);								//make sure adlar is not set.
  71               		.loc 1 38 2 is_stmt 1 view .LVU16
  72               		.loc 1 38 8 is_stmt 0 view .LVU17
  73 0008 8081      		ld r24,Z
  74 000a 8F7D      		andi r24,lo8(-33)
  75 000c 8083      		st Z,r24
  39:main.c        **** 	ADCSRA=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //Prescaler div factor = 128, 125kHz --> lowest
  76               		.loc 1 39 2 is_stmt 1 view .LVU18
  77               		.loc 1 39 8 is_stmt 0 view .LVU19
  78 000e 87E8      		ldi r24,lo8(-121)
  79 0010 8093 7A00 		sts 122,r24
  80               	/* epilogue start */
  40:main.c        **** }
  81               		.loc 1 40 1 view .LVU20
  82 0014 0895      		ret
  83               		.cfi_endproc
  84               	.LFE13:
  86               		.section	.rodata
  87               	.LC0:
  88 0000 07        		.byte	7
  89 0001 06        		.byte	6
  90 0002 03        		.byte	3
  91 0003 02        		.byte	2
  92 0004 05        		.byte	5
  93 0005 04        		.byte	4
  94 0006 01        		.byte	1
  95 0007 00        		.byte	0
  96               	.LC1:
  97 0008 01        		.byte	1
  98 0009 01        		.byte	1
  99 000a 00        		.byte	0
 100 000b 01        		.byte	1
 101 000c 07        		.byte	7
 102 000d 03        		.byte	3
 103 000e 04        		.byte	4
 104 000f 00        		.byte	0
 105               	.LC2:
 106 0010 04        		.byte	4
 107 0011 07        		.byte	7
 108 0012 03        		.byte	3
 109 0013 05        		.byte	5
 110 0014 08        		.byte	8
 111 0015 09        		.byte	9
 112 0016 06        		.byte	6
 113 0017 0A        		.byte	10
 114               		.section	.text.Cells_init,"ax",@progbits
 115               	.global	Cells_init
 117               	Cells_init:
 118               	.LVL0:
 119               	.LFB14:
  41:main.c        **** 
  42:main.c        **** void Cells_init(cell * _cells)
  43:main.c        **** {
 120               		.loc 1 43 1 is_stmt 1 view -0
 121               		.cfi_startproc
 122               		.loc 1 43 1 is_stmt 0 view .LVU22
 123 0000 CF93      		push r28
 124               	.LCFI0:
 125               		.cfi_def_cfa_offset 3
 126               		.cfi_offset 28, -2
 127 0002 DF93      		push r29
 128               	.LCFI1:
 129               		.cfi_def_cfa_offset 4
 130               		.cfi_offset 29, -3
 131 0004 CDB7      		in r28,__SP_L__
 132 0006 DEB7      		in r29,__SP_H__
 133               	.LCFI2:
 134               		.cfi_def_cfa_register 28
 135 0008 6897      		sbiw r28,24
 136               	.LCFI3:
 137               		.cfi_def_cfa_offset 28
 138 000a 0FB6      		in __tmp_reg__,__SREG__
 139 000c F894      		cli
 140 000e DEBF      		out __SP_H__,r29
 141 0010 0FBE      		out __SREG__,__tmp_reg__
 142 0012 CDBF      		out __SP_L__,r28
 143               	/* prologue: function */
 144               	/* frame size = 24 */
 145               	/* stack size = 26 */
 146               	.L__stack_usage = 26
  44:main.c        **** 	uint8_t cell_temp_config[] = {7,6,3,2,5,4,1,0};		//multiplexer number to use for each different ce
 147               		.loc 1 44 2 is_stmt 1 view .LVU23
 148               		.loc 1 44 10 is_stmt 0 view .LVU24
 149 0014 28E0      		ldi r18,lo8(8)
 150 0016 E0E0      		ldi r30,lo8(.LC0)
 151 0018 F0E0      		ldi r31,hi8(.LC0)
 152 001a DE01      		movw r26,r28
 153 001c 5196      		adiw r26,17
 154               		0:
 155 001e 0190      		ld r0,Z+
 156 0020 0D92      		st X+,r0
 157 0022 2A95      		dec r18
 158 0024 01F4      		brne 0b
  45:main.c        **** 	uint8_t cell_discharge_config[8] = {PIND1,PINC1,PINB0,PINB1,PIND7,PINB3,PINB4,PIND0};
 159               		.loc 1 45 2 is_stmt 1 view .LVU25
 160               		.loc 1 45 10 is_stmt 0 view .LVU26
 161 0026 28E0      		ldi r18,lo8(8)
 162 0028 E0E0      		ldi r30,lo8(.LC1)
 163 002a F0E0      		ldi r31,hi8(.LC1)
 164 002c DE01      		movw r26,r28
 165 002e 1996      		adiw r26,9
 166               		0:
 167 0030 0190      		ld r0,Z+
 168 0032 0D92      		st X+,r0
 169 0034 2A95      		dec r18
 170 0036 01F4      		brne 0b
  46:main.c        **** 	//uint8_t cell_vLevel_config[8] = {10,9,8,7,6,5,4,2};	//ADC Channels to use	
  47:main.c        **** 	uint8_t cell_vLevel_config[8] = {4,7,3,5,8,9,6,10};	//ADC Channels to use
 171               		.loc 1 47 2 is_stmt 1 view .LVU27
 172               		.loc 1 47 10 is_stmt 0 view .LVU28
 173 0038 28E0      		ldi r18,lo8(8)
 174 003a E0E0      		ldi r30,lo8(.LC2)
 175 003c F0E0      		ldi r31,hi8(.LC2)
 176 003e DE01      		movw r26,r28
 177 0040 1196      		adiw r26,1
 178               		0:
 179 0042 0190      		ld r0,Z+
 180 0044 0D92      		st X+,r0
 181 0046 2A95      		dec r18
 182 0048 01F4      		brne 0b
  48:main.c        **** 		
  49:main.c        **** 	
  50:main.c        **** 	for(uint8_t cParse = 0; cParse <=7; cParse++)
 183               		.loc 1 50 2 is_stmt 1 view .LVU29
 184               	.LBB34:
 185               		.loc 1 50 6 view .LVU30
 186               	.LVL1:
 187               		.loc 1 50 6 is_stmt 0 view .LVU31
 188 004a FC01      		movw r30,r24
 189 004c AE01      		movw r20,r28
 190 004e 4F5E      		subi r20,-17
 191 0050 5F4F      		sbci r21,-1
 192 0052 BE01      		movw r22,r28
 193 0054 6F5F      		subi r22,-1
 194 0056 7F4F      		sbci r23,-1
 195 0058 9E01      		movw r18,r28
 196 005a 275F      		subi r18,-9
 197 005c 3F4F      		sbci r19,-1
 198               		.loc 1 50 14 view .LVU32
 199 005e 80E0      		ldi r24,0
 200               	.LVL2:
 201               	.L4:
  51:main.c        **** 	{
  52:main.c        **** 		_cells[cParse].cell_num = cParse;								//assign our cell objects a local identifier number
 202               		.loc 1 52 3 is_stmt 1 discriminator 3 view .LVU33
 203               		.loc 1 52 27 is_stmt 0 discriminator 3 view .LVU34
 204 0060 8383      		std Z+3,r24
  53:main.c        **** 		_cells[cParse].temp_channel	= cell_temp_config[cParse];			//assign cell object the multiplexer va
 205               		.loc 1 53 3 is_stmt 1 discriminator 3 view .LVU35
 206               		.loc 1 53 49 is_stmt 0 discriminator 3 view .LVU36
 207 0062 DA01      		movw r26,r20
 208 0064 9D91      		ld r25,X+
 209 0066 AD01      		movw r20,r26
 210               		.loc 1 53 31 discriminator 3 view .LVU37
 211 0068 9083      		st Z,r25
  54:main.c        **** 		_cells[cParse].voltage_channel = cell_vLevel_config[cParse];		//assign cell ADC channel to use wh
 212               		.loc 1 54 3 is_stmt 1 discriminator 3 view .LVU38
 213               		.loc 1 54 54 is_stmt 0 discriminator 3 view .LVU39
 214 006a DB01      		movw r26,r22
 215 006c 9D91      		ld r25,X+
 216 006e BD01      		movw r22,r26
 217               		.loc 1 54 34 discriminator 3 view .LVU40
 218 0070 9183      		std Z+1,r25
  55:main.c        **** 		_cells[cParse].discharge_pin = cell_discharge_config[cParse];	//assign which pin to use to discha
 219               		.loc 1 55 3 is_stmt 1 discriminator 3 view .LVU41
 220               		.loc 1 55 55 is_stmt 0 discriminator 3 view .LVU42
 221 0072 D901      		movw r26,r18
 222 0074 9D91      		ld r25,X+
 223 0076 9D01      		movw r18,r26
 224               		.loc 1 55 32 discriminator 3 view .LVU43
 225 0078 9283      		std Z+2,r25
  50:main.c        **** 	{
 226               		.loc 1 50 44 discriminator 3 view .LVU44
 227 007a 8F5F      		subi r24,lo8(-(1))
 228               	.LVL3:
  50:main.c        **** 	{
 229               		.loc 1 50 44 discriminator 3 view .LVU45
 230 007c 7296      		adiw r30,18
  50:main.c        **** 	{
 231               		.loc 1 50 2 discriminator 3 view .LVU46
 232 007e 8830      		cpi r24,lo8(8)
 233 0080 01F4      		brne .L4
 234               	/* epilogue start */
 235               	.LBE34:
  56:main.c        **** 	}
  57:main.c        **** }
 236               		.loc 1 57 1 view .LVU47
 237 0082 6896      		adiw r28,24
 238 0084 0FB6      		in __tmp_reg__,__SREG__
 239 0086 F894      		cli
 240 0088 DEBF      		out __SP_H__,r29
 241 008a 0FBE      		out __SREG__,__tmp_reg__
 242 008c CDBF      		out __SP_L__,r28
 243 008e DF91      		pop r29
 244 0090 CF91      		pop r28
 245 0092 0895      		ret
 246               		.cfi_endproc
 247               	.LFE14:
 249               		.section	.text.CMU_eeprom_read,"ax",@progbits
 250               	.global	CMU_eeprom_read
 252               	CMU_eeprom_read:
 253               	.LFB15:
  58:main.c        **** 
  59:main.c        **** uint16_t CMU_eeprom_read(uint16_t address)
  60:main.c        **** {
 254               		.loc 1 60 1 is_stmt 1 view -0
 255               		.cfi_startproc
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 260               	.LVL4:
 261               	.L7:
  61:main.c        **** 	while(!eeprom_is_ready());
 262               		.loc 1 61 27 discriminator 1 view .LVU49
 263               		.loc 1 61 7 is_stmt 0 discriminator 1 view .LVU50
 264 0000 F999      		sbic 0x1f,1
 265 0002 00C0      		rjmp .L7
  62:main.c        **** 	return eeprom_read_word((const uint16_t *)address);
 266               		.loc 1 62 2 is_stmt 1 view .LVU51
 267               		.loc 1 62 9 is_stmt 0 view .LVU52
 268 0004 0C94 0000 		jmp eeprom_read_word
 269               	.LVL5:
 270               		.loc 1 62 9 view .LVU53
 271               		.cfi_endproc
 272               	.LFE15:
 274               		.section	.text.Parameters_init,"ax",@progbits
 275               	.global	Parameters_init
 277               	Parameters_init:
 278               	.LFB12:
  25:main.c        **** 	deviceID  = CMU_eeprom_read(EEPROM_DEVICE_ID);
 279               		.loc 1 25 1 is_stmt 1 view -0
 280               		.cfi_startproc
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 283               	/* stack size = 0 */
 284               	.L__stack_usage = 0
  26:main.c        **** 	ADC_SAMPLES  = CMU_eeprom_read(EEPROM_ADC_SAMPLES);
 285               		.loc 1 26 2 view .LVU55
  26:main.c        **** 	ADC_SAMPLES  = CMU_eeprom_read(EEPROM_ADC_SAMPLES);
 286               		.loc 1 26 14 is_stmt 0 view .LVU56
 287 0000 90E0      		ldi r25,0
 288 0002 80E0      		ldi r24,0
 289 0004 0E94 0000 		call CMU_eeprom_read
 290               	.LVL6:
  26:main.c        **** 	ADC_SAMPLES  = CMU_eeprom_read(EEPROM_ADC_SAMPLES);
 291               		.loc 1 26 12 view .LVU57
 292 0008 9093 0000 		sts deviceID+1,r25
 293 000c 8093 0000 		sts deviceID,r24
  27:main.c        **** 	fw_version = CMU_eeprom_read(EEPROM_FW_VERSION);
 294               		.loc 1 27 2 is_stmt 1 view .LVU58
  27:main.c        **** 	fw_version = CMU_eeprom_read(EEPROM_FW_VERSION);
 295               		.loc 1 27 17 is_stmt 0 view .LVU59
 296 0010 82E0      		ldi r24,lo8(2)
 297 0012 90E0      		ldi r25,0
 298 0014 0E94 0000 		call CMU_eeprom_read
 299               	.LVL7:
  27:main.c        **** 	fw_version = CMU_eeprom_read(EEPROM_FW_VERSION);
 300               		.loc 1 27 15 view .LVU60
 301 0018 9093 0000 		sts ADC_SAMPLES+1,r25
 302 001c 8093 0000 		sts ADC_SAMPLES,r24
  28:main.c        **** 	CELL_V_DIFF_MAX_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MAX_THRESHOLD);
 303               		.loc 1 28 2 is_stmt 1 view .LVU61
  28:main.c        **** 	CELL_V_DIFF_MAX_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MAX_THRESHOLD);
 304               		.loc 1 28 15 is_stmt 0 view .LVU62
 305 0020 84E0      		ldi r24,lo8(4)
 306 0022 90E0      		ldi r25,0
 307 0024 0E94 0000 		call CMU_eeprom_read
 308               	.LVL8:
  28:main.c        **** 	CELL_V_DIFF_MAX_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MAX_THRESHOLD);
 309               		.loc 1 28 13 view .LVU63
 310 0028 9093 0000 		sts fw_version+1,r25
 311 002c 8093 0000 		sts fw_version,r24
  29:main.c        **** 	CELL_V_DIFF_MIN_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MIN_THRESHOLD);
 312               		.loc 1 29 2 is_stmt 1 view .LVU64
  29:main.c        **** 	CELL_V_DIFF_MIN_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MIN_THRESHOLD);
 313               		.loc 1 29 30 is_stmt 0 view .LVU65
 314 0030 80E4      		ldi r24,lo8(64)
 315 0032 90E0      		ldi r25,0
 316 0034 0E94 0000 		call CMU_eeprom_read
 317               	.LVL9:
  29:main.c        **** 	CELL_V_DIFF_MIN_THRESHOLD = CMU_eeprom_read(EEPROM_CELL_V_DIFF_MIN_THRESHOLD);
 318               		.loc 1 29 28 view .LVU66
 319 0038 9093 0000 		sts CELL_V_DIFF_MAX_THRESHOLD+1,r25
 320 003c 8093 0000 		sts CELL_V_DIFF_MAX_THRESHOLD,r24
  30:main.c        **** 	DISCHARGE_SCALE = CMU_eeprom_read(EEPROM_DISCHARGE_SCALE);
 321               		.loc 1 30 2 is_stmt 1 view .LVU67
  30:main.c        **** 	DISCHARGE_SCALE = CMU_eeprom_read(EEPROM_DISCHARGE_SCALE);
 322               		.loc 1 30 30 is_stmt 0 view .LVU68
 323 0040 82E4      		ldi r24,lo8(66)
 324 0042 90E0      		ldi r25,0
 325 0044 0E94 0000 		call CMU_eeprom_read
 326               	.LVL10:
  30:main.c        **** 	DISCHARGE_SCALE = CMU_eeprom_read(EEPROM_DISCHARGE_SCALE);
 327               		.loc 1 30 28 view .LVU69
 328 0048 9093 0000 		sts CELL_V_DIFF_MIN_THRESHOLD+1,r25
 329 004c 8093 0000 		sts CELL_V_DIFF_MIN_THRESHOLD,r24
  31:main.c        **** 	EEPROMWriteComplete = 0;
 330               		.loc 1 31 2 is_stmt 1 view .LVU70
  31:main.c        **** 	EEPROMWriteComplete = 0;
 331               		.loc 1 31 20 is_stmt 0 view .LVU71
 332 0050 88E4      		ldi r24,lo8(72)
 333 0052 90E0      		ldi r25,0
 334 0054 0E94 0000 		call CMU_eeprom_read
 335               	.LVL11:
  31:main.c        **** 	EEPROMWriteComplete = 0;
 336               		.loc 1 31 18 view .LVU72
 337 0058 9093 0000 		sts DISCHARGE_SCALE+1,r25
 338 005c 8093 0000 		sts DISCHARGE_SCALE,r24
  32:main.c        **** }
 339               		.loc 1 32 2 is_stmt 1 view .LVU73
  32:main.c        **** }
 340               		.loc 1 32 22 is_stmt 0 view .LVU74
 341 0060 1092 0000 		sts EEPROMWriteComplete,__zero_reg__
 342               	/* epilogue start */
  33:main.c        **** 
 343               		.loc 1 33 1 view .LVU75
 344 0064 0895      		ret
 345               		.cfi_endproc
 346               	.LFE12:
 348               		.section	.text.CMU_eeprom_write,"ax",@progbits
 349               	.global	CMU_eeprom_write
 351               	CMU_eeprom_write:
 352               	.LFB16:
  63:main.c        **** }
  64:main.c        **** 
  65:main.c        **** void CMU_eeprom_write(uint16_t address, uint16_t value)
  66:main.c        **** {
 353               		.loc 1 66 1 is_stmt 1 view -0
 354               		.cfi_startproc
 355               	/* prologue: function */
 356               	/* frame size = 0 */
 357               	/* stack size = 0 */
 358               	.L__stack_usage = 0
 359               	.LVL12:
 360               	.L11:
  67:main.c        **** 	while(!eeprom_is_ready());
 361               		.loc 1 67 27 discriminator 1 view .LVU77
 362               		.loc 1 67 7 is_stmt 0 discriminator 1 view .LVU78
 363 0000 F999      		sbic 0x1f,1
 364 0002 00C0      		rjmp .L11
  68:main.c        **** 	eeprom_write_word((uint16_t *)address, value);
 365               		.loc 1 68 2 is_stmt 1 view .LVU79
 366 0004 0C94 0000 		jmp eeprom_write_word
 367               	.LVL13:
 368               		.loc 1 68 2 is_stmt 0 view .LVU80
 369               		.cfi_endproc
 370               	.LFE16:
 372               		.section	.text.ADC_read,"ax",@progbits
 373               	.global	ADC_read
 375               	ADC_read:
 376               	.LVL14:
 377               	.LFB17:
  69:main.c        **** }
  70:main.c        **** 
  71:main.c        **** uint16_t ADC_read(uint8_t channel)
  72:main.c        **** {
 378               		.loc 1 72 1 is_stmt 1 view -0
 379               		.cfi_startproc
 380               	/* prologue: function */
 381               	/* frame size = 0 */
 382               	/* stack size = 0 */
 383               	.L__stack_usage = 0
  73:main.c        **** 	channel = (ADMUX & 0xe0)|(channel & 0x1F); //ADMUX | 0b11100000 and channel | 0b00011111 --> this 
 384               		.loc 1 73 2 view .LVU82
 385               		.loc 1 73 13 is_stmt 0 view .LVU83
 386 0000 9091 7C00 		lds r25,124
 387               		.loc 1 73 19 view .LVU84
 388 0004 907E      		andi r25,lo8(-32)
 389               		.loc 1 73 36 view .LVU85
 390 0006 8F71      		andi r24,lo8(31)
 391               	.LVL15:
 392               		.loc 1 73 26 view .LVU86
 393 0008 982B      		or r25,r24
 394               	.LVL16:
  74:main.c        **** 	ADMUX = channel;
 395               		.loc 1 74 2 is_stmt 1 view .LVU87
 396               		.loc 1 74 8 is_stmt 0 view .LVU88
 397 000a 9093 7C00 		sts 124,r25
  75:main.c        **** 	ADCSRA |= (1<<ADSC);							//ADSC (single conversion bit) is set to 1 to start the conversion proc
 398               		.loc 1 75 2 is_stmt 1 view .LVU89
 399               		.loc 1 75 9 is_stmt 0 view .LVU90
 400 000e 8091 7A00 		lds r24,122
 401 0012 8064      		ori r24,lo8(64)
 402 0014 8093 7A00 		sts 122,r24
  76:main.c        **** 	while(!(ADCSRA & (1<<ADIF)));				//run a loop while the conversion is taking place.
 403               		.loc 1 76 2 is_stmt 1 view .LVU91
 404               	.L14:
 405               		.loc 1 76 30 discriminator 1 view .LVU92
 406               		.loc 1 76 10 is_stmt 0 discriminator 1 view .LVU93
 407 0018 8091 7A00 		lds r24,122
 408               		.loc 1 76 7 discriminator 1 view .LVU94
 409 001c 84FF      		sbrs r24,4
 410 001e 00C0      		rjmp .L14
  77:main.c        **** 	uint16_t result = 0;
 411               		.loc 1 77 2 is_stmt 1 view .LVU95
 412               	.LVL17:
  78:main.c        **** 	result = ADCL;								//read ADCL first, ADCH after --> order is important! --> also not sure if t
 413               		.loc 1 78 2 view .LVU96
 414               		.loc 1 78 11 is_stmt 0 view .LVU97
 415 0020 2091 7800 		lds r18,120
 416               	.LVL18:
  79:main.c        **** 	result |= ((3 & ADCH) << 8);
 417               		.loc 1 79 2 is_stmt 1 view .LVU98
 418               		.loc 1 79 18 is_stmt 0 view .LVU99
 419 0024 8091 7900 		lds r24,121
 420               	.LVL19:
  80:main.c        **** 	ADCSRA|=(1<<ADIF);							//once read and done, clear the 'complete' status by writing 1 to the ADI
 421               		.loc 1 80 2 is_stmt 1 view .LVU100
 422               		.loc 1 80 8 is_stmt 0 view .LVU101
 423 0028 9091 7A00 		lds r25,122
 424               	.LVL20:
 425               		.loc 1 80 8 view .LVU102
 426 002c 9061      		ori r25,lo8(16)
 427 002e 9093 7A00 		sts 122,r25
  81:main.c        **** 	return result;								//pass the 10 bit ADC number to requesting function.
 428               		.loc 1 81 2 is_stmt 1 view .LVU103
  79:main.c        **** 	result |= ((3 & ADCH) << 8);
 429               		.loc 1 79 16 is_stmt 0 view .LVU104
 430 0032 90E0      		ldi r25,0
  79:main.c        **** 	result |= ((3 & ADCH) << 8);
 431               		.loc 1 79 24 view .LVU105
 432 0034 982F      		mov r25,r24
 433 0036 8827      		clr r24
 434               	.LVL21:
  79:main.c        **** 	result |= ((3 & ADCH) << 8);
 435               		.loc 1 79 24 view .LVU106
 436 0038 8827      		clr r24
 437 003a 9370      		andi r25,3
  82:main.c        **** }
 438               		.loc 1 82 1 view .LVU107
 439 003c 822B      		or r24,r18
 440               	/* epilogue start */
 441 003e 0895      		ret
 442               		.cfi_endproc
 443               	.LFE17:
 445               		.section	.text.LED_flash,"ax",@progbits
 446               	.global	LED_flash
 448               	LED_flash:
 449               	.LVL22:
 450               	.LFB18:
  83:main.c        **** 
  84:main.c        **** void LED_flash(uint8_t duration)
  85:main.c        **** {
 451               		.loc 1 85 1 is_stmt 1 view -0
 452               		.cfi_startproc
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
  86:main.c        **** 	duration = duration/2;
 457               		.loc 1 86 2 view .LVU109
 458               		.loc 1 86 11 is_stmt 0 view .LVU110
 459 0000 8695      		lsr r24
 460               	.LVL23:
  87:main.c        **** 	DDRC |= 1<<PINC0;
 461               		.loc 1 87 2 is_stmt 1 view .LVU111
 462               		.loc 1 87 7 is_stmt 0 view .LVU112
 463 0002 389A      		sbi 0x7,0
  88:main.c        **** 	PORTC |= 1<<PINC0;
 464               		.loc 1 88 2 is_stmt 1 view .LVU113
 465               		.loc 1 88 8 is_stmt 0 view .LVU114
 466 0004 409A      		sbi 0x8,0
  89:main.c        **** 	for(uint8_t i = 0; i < duration; i++)
 467               		.loc 1 89 2 is_stmt 1 view .LVU115
 468               	.LBB35:
 469               		.loc 1 89 6 view .LVU116
 470               	.LVL24:
 471               		.loc 1 89 14 is_stmt 0 view .LVU117
 472 0006 90E0      		ldi r25,0
 473               	.LVL25:
 474               	.L18:
 475               		.loc 1 89 2 discriminator 1 view .LVU118
 476 0008 9813      		cpse r25,r24
 477 000a 00C0      		rjmp .L19
 478               	.LBE35:
  90:main.c        **** 	{
  91:main.c        **** 		_delay_us(995);
  92:main.c        **** 	}
  93:main.c        **** 	PORTC &= ~(1<<PINC0);
 479               		.loc 1 93 2 is_stmt 1 view .LVU119
 480               		.loc 1 93 8 is_stmt 0 view .LVU120
 481 000c 4098      		cbi 0x8,0
  94:main.c        **** 	DDRC &= ~(1<<PINC0);
 482               		.loc 1 94 2 is_stmt 1 view .LVU121
 483               		.loc 1 94 7 is_stmt 0 view .LVU122
 484 000e 3898      		cbi 0x7,0
  95:main.c        **** 	for(uint8_t i = 0; i < duration; i++)
 485               		.loc 1 95 2 is_stmt 1 view .LVU123
 486               	.LBB38:
 487               		.loc 1 95 6 view .LVU124
 488               	.LVL26:
 489               		.loc 1 95 14 is_stmt 0 view .LVU125
 490 0010 90E0      		ldi r25,0
 491               	.LVL27:
 492               	.L20:
 493               		.loc 1 95 2 discriminator 1 view .LVU126
 494 0012 9813      		cpse r25,r24
 495 0014 00C0      		rjmp .L21
 496               	/* epilogue start */
 497               	.LBE38:
  96:main.c        **** 	{
  97:main.c        **** 		_delay_us(995);
  98:main.c        **** 	}
  99:main.c        **** }
 498               		.loc 1 99 1 view .LVU127
 499 0016 0895      		ret
 500               	.LVL28:
 501               	.L19:
 502               	.LBB41:
  91:main.c        **** 	}
 503               		.loc 1 91 3 is_stmt 1 view .LVU128
 504               	.LBB36:
 505               	.LBI36:
 506               		.file 2 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** _delay_us(double __us)
 507               		.loc 2 255 1 view .LVU129
 508               	.LBB37:
 256:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	double __tmp ;
 509               		.loc 2 257 2 view .LVU130
 258:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 510               		.loc 2 261 2 view .LVU131
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 511               		.loc 2 262 2 view .LVU132
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 512               		.loc 2 263 2 view .LVU133
 264:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 513               		.loc 2 273 3 view .LVU134
 274:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 514               		.loc 2 276 2 view .LVU135
 515 0018 EBE8      		ldi r30,lo8(3979)
 516 001a FFE0      		ldi r31,hi8(3979)
 517 001c 3197      	1:	sbiw r30,1
 518 001e 01F4      		brne 1b
 519 0020 00C0      		rjmp .
 520 0022 0000      		nop
 521               	.LVL29:
 522               		.loc 2 276 2 is_stmt 0 view .LVU136
 523               	.LBE37:
 524               	.LBE36:
  89:main.c        **** 	{
 525               		.loc 1 89 36 view .LVU137
 526 0024 9F5F      		subi r25,lo8(-(1))
 527               	.LVL30:
  89:main.c        **** 	{
 528               		.loc 1 89 36 view .LVU138
 529 0026 00C0      		rjmp .L18
 530               	.LVL31:
 531               	.L21:
  89:main.c        **** 	{
 532               		.loc 1 89 36 view .LVU139
 533               	.LBE41:
 534               	.LBB42:
  97:main.c        **** 	}
 535               		.loc 1 97 3 is_stmt 1 view .LVU140
 536               	.LBB39:
 537               	.LBI39:
 255:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 538               		.loc 2 255 1 view .LVU141
 539               	.LBB40:
 257:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 540               		.loc 2 257 2 view .LVU142
 261:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 541               		.loc 2 261 2 view .LVU143
 262:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 542               		.loc 2 262 2 view .LVU144
 263:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 543               		.loc 2 263 2 view .LVU145
 273:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 544               		.loc 2 273 3 view .LVU146
 545               		.loc 2 276 2 view .LVU147
 546 0028 EBE8      		ldi r30,lo8(3979)
 547 002a FFE0      		ldi r31,hi8(3979)
 548 002c 3197      	1:	sbiw r30,1
 549 002e 01F4      		brne 1b
 550 0030 00C0      		rjmp .
 551 0032 0000      		nop
 552               	.LVL32:
 553               		.loc 2 276 2 is_stmt 0 view .LVU148
 554               	.LBE40:
 555               	.LBE39:
  95:main.c        **** 	{
 556               		.loc 1 95 36 view .LVU149
 557 0034 9F5F      		subi r25,lo8(-(1))
 558               	.LVL33:
  95:main.c        **** 	{
 559               		.loc 1 95 36 view .LVU150
 560 0036 00C0      		rjmp .L20
 561               	.LBE42:
 562               		.cfi_endproc
 563               	.LFE18:
 565               		.section	.text.LED_on,"ax",@progbits
 566               	.global	LED_on
 568               	LED_on:
 569               	.LFB19:
 100:main.c        **** void LED_on()
 101:main.c        **** {
 570               		.loc 1 101 1 is_stmt 1 view -0
 571               		.cfi_startproc
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 102:main.c        **** 	DDRC |= 1<<PINC0;
 576               		.loc 1 102 2 view .LVU152
 577               		.loc 1 102 7 is_stmt 0 view .LVU153
 578 0000 389A      		sbi 0x7,0
 103:main.c        **** 	PORTC |= 1<<PINC0;
 579               		.loc 1 103 2 is_stmt 1 view .LVU154
 580               		.loc 1 103 8 is_stmt 0 view .LVU155
 581 0002 409A      		sbi 0x8,0
 582               	/* epilogue start */
 104:main.c        **** }
 583               		.loc 1 104 1 view .LVU156
 584 0004 0895      		ret
 585               		.cfi_endproc
 586               	.LFE19:
 588               		.section	.text.LED_off,"ax",@progbits
 589               	.global	LED_off
 591               	LED_off:
 592               	.LFB20:
 105:main.c        **** void LED_off()
 106:main.c        **** {
 593               		.loc 1 106 1 is_stmt 1 view -0
 594               		.cfi_startproc
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 0 */
 598               	.L__stack_usage = 0
 107:main.c        **** 	PORTC &= ~(1<<PINC0);
 599               		.loc 1 107 2 view .LVU158
 600               		.loc 1 107 8 is_stmt 0 view .LVU159
 601 0000 4098      		cbi 0x8,0
 108:main.c        **** 	DDRC &= ~(1<<PINC0);
 602               		.loc 1 108 2 is_stmt 1 view .LVU160
 603               		.loc 1 108 7 is_stmt 0 view .LVU161
 604 0002 3898      		cbi 0x7,0
 605               	/* epilogue start */
 109:main.c        **** }
 606               		.loc 1 109 1 view .LVU162
 607 0004 0895      		ret
 608               		.cfi_endproc
 609               	.LFE20:
 611               	.global	__floatunsisf
 612               	.global	__mulsf3
 613               	.global	__subsf3
 614               	.global	__fixunssfsi
 615               		.section	.text.Convert_ADCtoMilliVolts,"ax",@progbits
 616               	.global	Convert_ADCtoMilliVolts
 618               	Convert_ADCtoMilliVolts:
 619               	.LVL34:
 620               	.LFB21:
 110:main.c        **** 
 111:main.c        **** uint16_t Convert_ADCtoMilliVolts(uint16_t ADCValue)
 112:main.c        **** {
 621               		.loc 1 112 1 is_stmt 1 view -0
 622               		.cfi_startproc
 623               	/* prologue: function */
 624               	/* frame size = 0 */
 625               	/* stack size = 0 */
 626               	.L__stack_usage = 0
 113:main.c        ****     //return as invalid;
 114:main.c        **** 	if(ADCValue >= 1023) return  65535;
 627               		.loc 1 114 2 view .LVU164
 115:main.c        ****     //finish the conversion with error if the value will be completely unreasonable.
 116:main.c        **** 	if(ADCValue <  20 ) return 65535;
 628               		.loc 1 116 2 view .LVU165
 629               		.loc 1 116 4 is_stmt 0 view .LVU166
 630 0000 9C01      		movw r18,r24
 631 0002 2451      		subi r18,20
 632 0004 3109      		sbc r19,__zero_reg__
 633 0006 2B3E      		cpi r18,-21
 634 0008 3340      		sbci r19,3
 635 000a 00F4      		brsh .L26
 636               	.LVL35:
 637               	.LBB45:
 638               	.LBB46:
 117:main.c        ****     //xxxxx.xxxxf results in the calculated value being a float, instead of an integer
 118:main.c        **** 	return (uint16_t)(((double)ADCValue*0.000977517f)*RAIL_V-MV_OFFSET);
 639               		.loc 1 118 2 is_stmt 1 view .LVU167
 640               		.loc 1 118 21 is_stmt 0 view .LVU168
 641 000c BC01      		movw r22,r24
 642 000e 90E0      		ldi r25,0
 643 0010 80E0      		ldi r24,0
 644               	.LVL36:
 645               		.loc 1 118 21 view .LVU169
 646 0012 0E94 0000 		call __floatunsisf
 647               	.LVL37:
 648               		.loc 1 118 37 view .LVU170
 649 0016 27E0      		ldi r18,lo8(7)
 650 0018 30E2      		ldi r19,lo8(32)
 651 001a 40E8      		ldi r20,lo8(-128)
 652 001c 5AE3      		ldi r21,lo8(58)
 653 001e 0E94 0000 		call __mulsf3
 654               	.LVL38:
 655               		.loc 1 118 51 view .LVU171
 656 0022 20E0      		ldi r18,0
 657 0024 30E4      		ldi r19,lo8(64)
 658 0026 4CE9      		ldi r20,lo8(-100)
 659 0028 55E4      		ldi r21,lo8(69)
 660 002a 0E94 0000 		call __mulsf3
 661               	.LVL39:
 662               		.loc 1 118 58 view .LVU172
 663 002e 20E0      		ldi r18,0
 664 0030 30E0      		ldi r19,0
 665 0032 48E7      		ldi r20,lo8(120)
 666 0034 52E4      		ldi r21,lo8(66)
 667 0036 0E94 0000 		call __subsf3
 668               	.LVL40:
 669               		.loc 1 118 9 view .LVU173
 670 003a 0E94 0000 		call __fixunssfsi
 671               	.LVL41:
 672 003e CB01      		movw r24,r22
 673               	.LVL42:
 674               		.loc 1 118 9 view .LVU174
 675 0040 0895      		ret
 676               	.LVL43:
 677               	.L26:
 678               		.loc 1 118 9 view .LVU175
 679               	.LBE46:
 680               	.LBE45:
 116:main.c        ****     //xxxxx.xxxxf results in the calculated value being a float, instead of an integer
 681               		.loc 1 116 29 view .LVU176
 682 0042 8FEF      		ldi r24,lo8(-1)
 683 0044 9FEF      		ldi r25,lo8(-1)
 684               	.LVL44:
 685               	/* epilogue start */
 119:main.c        **** 
 120:main.c        **** }
 686               		.loc 1 120 1 view .LVU177
 687 0046 0895      		ret
 688               		.cfi_endproc
 689               	.LFE21:
 691               		.section	.text.Read_voltage,"ax",@progbits
 692               	.global	Read_voltage
 694               	Read_voltage:
 695               	.LVL45:
 696               	.LFB22:
 121:main.c        **** 
 122:main.c        **** uint16_t Read_voltage(cell * _cell)
 123:main.c        **** {
 697               		.loc 1 123 1 is_stmt 1 view -0
 698               		.cfi_startproc
 699               		.loc 1 123 1 is_stmt 0 view .LVU179
 700 0000 CF92      		push r12
 701               	.LCFI4:
 702               		.cfi_def_cfa_offset 3
 703               		.cfi_offset 12, -2
 704 0002 DF92      		push r13
 705               	.LCFI5:
 706               		.cfi_def_cfa_offset 4
 707               		.cfi_offset 13, -3
 708 0004 EF92      		push r14
 709               	.LCFI6:
 710               		.cfi_def_cfa_offset 5
 711               		.cfi_offset 14, -4
 712 0006 FF92      		push r15
 713               	.LCFI7:
 714               		.cfi_def_cfa_offset 6
 715               		.cfi_offset 15, -5
 716 0008 0F93      		push r16
 717               	.LCFI8:
 718               		.cfi_def_cfa_offset 7
 719               		.cfi_offset 16, -6
 720 000a 1F93      		push r17
 721               	.LCFI9:
 722               		.cfi_def_cfa_offset 8
 723               		.cfi_offset 17, -7
 724 000c CF93      		push r28
 725               	.LCFI10:
 726               		.cfi_def_cfa_offset 9
 727               		.cfi_offset 28, -8
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 7 */
 731               	.L__stack_usage = 7
 732 000e 8C01      		movw r16,r24
 124:main.c        **** 	uint32_t sum = 0;
 733               		.loc 1 124 2 is_stmt 1 view .LVU180
 734               	.LVL46:
 125:main.c        **** 	for(uint8_t c = 0; c < AVG_V_SIZE; c++)
 735               		.loc 1 125 2 view .LVU181
 736               	.LBB47:
 737               		.loc 1 125 6 view .LVU182
 738               		.loc 1 125 6 is_stmt 0 view .LVU183
 739               	.LBE47:
 123:main.c        **** 	uint32_t sum = 0;
 740               		.loc 1 123 1 view .LVU184
 741 0010 C5E0      		ldi r28,lo8(5)
 124:main.c        **** 	uint32_t sum = 0;
 742               		.loc 1 124 11 view .LVU185
 743 0012 C12C      		mov r12,__zero_reg__
 744 0014 D12C      		mov r13,__zero_reg__
 745 0016 7601      		movw r14,r12
 746               	.LVL47:
 747               	.L28:
 748               	.LBB48:
 126:main.c        **** 	{
 127:main.c        **** 		//elementToUpdate = (rand() % AVG_V_SIZE);						//choose a random element to update
 128:main.c        **** 		sum += Convert_ADCtoMilliVolts(ADC_read(_cell->voltage_channel));			//read the voltage
 749               		.loc 1 128 3 is_stmt 1 discriminator 3 view .LVU186
 750               		.loc 1 128 10 is_stmt 0 discriminator 3 view .LVU187
 751 0018 F801      		movw r30,r16
 752 001a 8181      		ldd r24,Z+1
 753 001c 0E94 0000 		call ADC_read
 754               	.LVL48:
 755 0020 0E94 0000 		call Convert_ADCtoMilliVolts
 756               	.LVL49:
 757               		.loc 1 128 7 discriminator 3 view .LVU188
 758 0024 C80E      		add r12,r24
 759 0026 D91E      		adc r13,r25
 760 0028 E11C      		adc r14,__zero_reg__
 761 002a F11C      		adc r15,__zero_reg__
 762               	.LVL50:
 763               		.loc 1 128 7 discriminator 3 view .LVU189
 764 002c C150      		subi r28,lo8(-(-1))
 765               	.LVL51:
 125:main.c        **** 	{
 766               		.loc 1 125 2 discriminator 3 view .LVU190
 767 002e 01F4      		brne .L28
 768               	.LBE48:
 129:main.c        **** 		//if(elementToUpdate < AVG_V_SIZE)_cell->voltages[elementToUpdate] = tempVoltage;	//if the random
 130:main.c        **** 	}
 131:main.c        **** 	return (uint16_t)(sum/AVG_V_SIZE);	//return the average.
 769               		.loc 1 131 2 is_stmt 1 view .LVU191
 770               		.loc 1 131 23 is_stmt 0 view .LVU192
 771 0030 C701      		movw r24,r14
 772 0032 B601      		movw r22,r12
 773 0034 25E0      		ldi r18,lo8(5)
 774 0036 30E0      		ldi r19,0
 775 0038 40E0      		ldi r20,0
 776 003a 50E0      		ldi r21,0
 777 003c 0E94 0000 		call __udivmodsi4
 132:main.c        **** }
 778               		.loc 1 132 1 view .LVU193
 779 0040 C901      		movw r24,r18
 780               	/* epilogue start */
 781 0042 CF91      		pop r28
 782               	.LVL52:
 783               		.loc 1 132 1 view .LVU194
 784 0044 1F91      		pop r17
 785 0046 0F91      		pop r16
 786               	.LVL53:
 787               		.loc 1 132 1 view .LVU195
 788 0048 FF90      		pop r15
 789 004a EF90      		pop r14
 790 004c DF90      		pop r13
 791 004e CF90      		pop r12
 792               	.LVL54:
 793               		.loc 1 132 1 view .LVU196
 794 0050 0895      		ret
 795               		.cfi_endproc
 796               	.LFE22:
 798               		.section	.text.Read_all_voltages,"ax",@progbits
 799               	.global	Read_all_voltages
 801               	Read_all_voltages:
 802               	.LVL55:
 803               	.LFB23:
 133:main.c        **** 
 134:main.c        **** void Read_all_voltages(cell * _cells)
 135:main.c        **** {
 804               		.loc 1 135 1 is_stmt 1 view -0
 805               		.cfi_startproc
 806               		.loc 1 135 1 is_stmt 0 view .LVU198
 807 0000 0F93      		push r16
 808               	.LCFI11:
 809               		.cfi_def_cfa_offset 3
 810               		.cfi_offset 16, -2
 811 0002 1F93      		push r17
 812               	.LCFI12:
 813               		.cfi_def_cfa_offset 4
 814               		.cfi_offset 17, -3
 815 0004 CF93      		push r28
 816               	.LCFI13:
 817               		.cfi_def_cfa_offset 5
 818               		.cfi_offset 28, -4
 819 0006 DF93      		push r29
 820               	.LCFI14:
 821               		.cfi_def_cfa_offset 6
 822               		.cfi_offset 29, -5
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 4 */
 826               	.L__stack_usage = 4
 827 0008 EC01      		movw r28,r24
 136:main.c        **** 
 137:main.c        **** 	cell * t_cells = _cells;
 828               		.loc 1 137 2 is_stmt 1 view .LVU199
 138:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 7; cellCount++)
 829               		.loc 1 138 2 view .LVU200
 830               	.LBB49:
 831               		.loc 1 138 6 view .LVU201
 832               	.LVL56:
 833               		.loc 1 138 6 is_stmt 0 view .LVU202
 834 000a 8C01      		movw r16,r24
 835 000c 0057      		subi r16,112
 836 000e 1F4F      		sbci r17,-1
 837               	.LVL57:
 838               	.L31:
 139:main.c        **** 	{
 140:main.c        **** 		t_cells = _cells+cellCount;
 839               		.loc 1 140 3 is_stmt 1 discriminator 3 view .LVU203
 141:main.c        **** 		t_cells->voltage = Read_voltage(t_cells);	//move through all cells and assign voltage levels.
 840               		.loc 1 141 3 discriminator 3 view .LVU204
 841               		.loc 1 141 22 is_stmt 0 discriminator 3 view .LVU205
 842 0010 CE01      		movw r24,r28
 843 0012 0E94 0000 		call Read_voltage
 844               	.LVL58:
 845               		.loc 1 141 20 discriminator 3 view .LVU206
 846 0016 9F83      		std Y+7,r25
 847 0018 8E83      		std Y+6,r24
 848               		.loc 1 141 20 discriminator 3 view .LVU207
 849 001a 6296      		adiw r28,18
 850               	.LVL59:
 138:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 7; cellCount++)
 851               		.loc 1 138 2 discriminator 3 view .LVU208
 852 001c C017      		cp r28,r16
 853 001e D107      		cpc r29,r17
 854 0020 01F4      		brne .L31
 855               	/* epilogue start */
 856               	.LBE49:
 142:main.c        **** 	}
 143:main.c        **** 
 144:main.c        **** }
 857               		.loc 1 144 1 view .LVU209
 858 0022 DF91      		pop r29
 859 0024 CF91      		pop r28
 860               	.LVL60:
 861               		.loc 1 144 1 view .LVU210
 862 0026 1F91      		pop r17
 863 0028 0F91      		pop r16
 864               	.LVL61:
 865               		.loc 1 144 1 view .LVU211
 866 002a 0895      		ret
 867               		.cfi_endproc
 868               	.LFE23:
 870               		.section	.text.TX_cellVoltage,"ax",@progbits
 871               	.global	TX_cellVoltage
 873               	TX_cellVoltage:
 874               	.LVL62:
 875               	.LFB24:
 145:main.c        **** 
 146:main.c        **** uint8_t TX_cellVoltage(cell *_cells)
 147:main.c        **** {
 876               		.loc 1 147 1 is_stmt 1 view -0
 877               		.cfi_startproc
 878               		.loc 1 147 1 is_stmt 0 view .LVU213
 879 0000 AF92      		push r10
 880               	.LCFI15:
 881               		.cfi_def_cfa_offset 3
 882               		.cfi_offset 10, -2
 883 0002 BF92      		push r11
 884               	.LCFI16:
 885               		.cfi_def_cfa_offset 4
 886               		.cfi_offset 11, -3
 887 0004 DF92      		push r13
 888               	.LCFI17:
 889               		.cfi_def_cfa_offset 5
 890               		.cfi_offset 13, -4
 891 0006 EF92      		push r14
 892               	.LCFI18:
 893               		.cfi_def_cfa_offset 6
 894               		.cfi_offset 14, -5
 895 0008 FF92      		push r15
 896               	.LCFI19:
 897               		.cfi_def_cfa_offset 7
 898               		.cfi_offset 15, -6
 899 000a 0F93      		push r16
 900               	.LCFI20:
 901               		.cfi_def_cfa_offset 8
 902               		.cfi_offset 16, -7
 903 000c 1F93      		push r17
 904               	.LCFI21:
 905               		.cfi_def_cfa_offset 9
 906               		.cfi_offset 17, -8
 907 000e CF93      		push r28
 908               	.LCFI22:
 909               		.cfi_def_cfa_offset 10
 910               		.cfi_offset 28, -9
 911 0010 DF93      		push r29
 912               	.LCFI23:
 913               		.cfi_def_cfa_offset 11
 914               		.cfi_offset 29, -10
 915 0012 CDB7      		in r28,__SP_L__
 916 0014 DEB7      		in r29,__SP_H__
 917               	.LCFI24:
 918               		.cfi_def_cfa_register 28
 919 0016 2897      		sbiw r28,8
 920               	.LCFI25:
 921               		.cfi_def_cfa_offset 19
 922 0018 0FB6      		in __tmp_reg__,__SREG__
 923 001a F894      		cli
 924 001c DEBF      		out __SP_H__,r29
 925 001e 0FBE      		out __SREG__,__tmp_reg__
 926 0020 CDBF      		out __SP_L__,r28
 927               	/* prologue: function */
 928               	/* frame size = 8 */
 929               	/* stack size = 17 */
 930               	.L__stack_usage = 17
 931 0022 5C01      		movw r10,r24
 148:main.c        **** 	int8_t mob;
 932               		.loc 1 148 2 is_stmt 1 view .LVU214
 149:main.c        **** 	uint8_t tempData[8];
 933               		.loc 1 149 2 view .LVU215
 150:main.c        **** 	
 151:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 3; cellCount++)
 934               		.loc 1 151 2 view .LVU216
 935               	.LBB50:
 936               		.loc 1 151 6 view .LVU217
 937               	.LVL63:
 938               		.loc 1 151 6 is_stmt 0 view .LVU218
 939 0024 DC01      		movw r26,r24
 940 0026 FE01      		movw r30,r28
 941 0028 3196      		adiw r30,1
 942 002a CE01      		movw r24,r28
 943               	.LVL64:
 944               		.loc 1 151 6 view .LVU219
 945 002c 0996      		adiw r24,9
 946 002e DE2E      		mov r13,r30
 947 0030 FF2E      		mov r15,r31
 948               	.LVL65:
 949               	.L34:
 152:main.c        **** 	{
 153:main.c        **** 		tempData[cellCount*2]	= _cells[cellCount].voltage >> 8;
 950               		.loc 1 153 3 is_stmt 1 discriminator 3 view .LVU220
 951               		.loc 1 153 44 is_stmt 0 discriminator 3 view .LVU221
 952 0032 1696      		adiw r26,6
 953 0034 2C91      		ld r18,X
 954 0036 1697      		sbiw r26,6
 955 0038 1796      		adiw r26,7
 956 003a 3C91      		ld r19,X
 957 003c 1797      		sbiw r26,7
 958               		.loc 1 153 25 discriminator 3 view .LVU222
 959 003e 3083      		st Z,r19
 154:main.c        **** 		tempData[cellCount*2+1] = _cells[cellCount].voltage;
 960               		.loc 1 154 3 is_stmt 1 discriminator 3 view .LVU223
 961               		.loc 1 154 27 is_stmt 0 discriminator 3 view .LVU224
 962 0040 2183      		std Z+1,r18
 963               		.loc 1 154 27 discriminator 3 view .LVU225
 964 0042 5296      		adiw r26,18
 965 0044 3296      		adiw r30,2
 151:main.c        **** 	{
 966               		.loc 1 151 2 discriminator 3 view .LVU226
 967 0046 8E17      		cp r24,r30
 968 0048 9F07      		cpc r25,r31
 969 004a 01F4      		brne .L34
 970               	.LBE50:
 155:main.c        **** 	}
 156:main.c        **** 	mob = CAN_findFreeTXMOB();
 971               		.loc 1 156 2 is_stmt 1 view .LVU227
 972               		.loc 1 156 8 is_stmt 0 view .LVU228
 973 004c 0E94 0000 		call CAN_findFreeTXMOB
 974               	.LVL66:
 157:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|VOLT1_ID, 0); 
 975               		.loc 1 157 2 is_stmt 1 view .LVU229
 976               		.loc 1 157 4 is_stmt 0 view .LVU230
 977 0050 87FF      		sbrs r24,7
 978 0052 00C0      		rjmp .L35
 979               	.L37:
 158:main.c        **** 	else return 0;
 980               		.loc 1 158 14 view .LVU231
 981 0054 80E0      		ldi r24,0
 982               	.LVL67:
 983               	.L33:
 984               	/* epilogue start */
 159:main.c        **** 	_delay_ms(5);
 160:main.c        **** 	
 161:main.c        **** 	for(uint8_t cellCount = 4; cellCount <= 7; cellCount++)
 162:main.c        **** 	{
 163:main.c        **** 		tempData[(cellCount-4)*2]	= _cells[cellCount].voltage >> 8;
 164:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 165:main.c        **** 	}
 166:main.c        **** 	mob = CAN_findFreeTXMOB();
 167:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|VOLT2_ID, 0); 
 168:main.c        **** 	else return 0;
 169:main.c        **** 	_delay_ms(5);
 170:main.c        **** 	
 171:main.c        **** 	return 1;
 172:main.c        **** }
 985               		.loc 1 172 1 view .LVU232
 986 0056 2896      		adiw r28,8
 987 0058 0FB6      		in __tmp_reg__,__SREG__
 988 005a F894      		cli
 989 005c DEBF      		out __SP_H__,r29
 990 005e 0FBE      		out __SREG__,__tmp_reg__
 991 0060 CDBF      		out __SP_L__,r28
 992 0062 DF91      		pop r29
 993 0064 CF91      		pop r28
 994 0066 1F91      		pop r17
 995 0068 0F91      		pop r16
 996 006a FF90      		pop r15
 997 006c EF90      		pop r14
 998 006e DF90      		pop r13
 999 0070 BF90      		pop r11
 1000 0072 AF90      		pop r10
 1001               	.LVL68:
 1002               		.loc 1 172 1 view .LVU233
 1003 0074 0895      		ret
 1004               	.LVL69:
 1005               	.L35:
 157:main.c        **** 	else return 0;
 1006               		.loc 1 157 12 is_stmt 1 discriminator 1 view .LVU234
 157:main.c        **** 	else return 0;
 1007               		.loc 1 157 41 is_stmt 0 discriminator 1 view .LVU235
 1008 0076 0091 0000 		lds r16,deviceID
 1009 007a 1091 0000 		lds r17,deviceID+1
 1010 007e 30E0      		ldi r19,0
 1011 0080 20E0      		ldi r18,0
 157:main.c        **** 	else return 0;
 1012               		.loc 1 157 59 discriminator 1 view .LVU236
 1013 0082 42E1      		ldi r20,18
 1014               		1:
 1015 0084 000F      		lsl r16
 1016 0086 111F      		rol r17
 1017 0088 221F      		rol r18
 1018 008a 331F      		rol r19
 1019 008c 4A95      		dec r20
 1020 008e 01F4      		brne 1b
 157:main.c        **** 	else return 0;
 1021               		.loc 1 157 66 discriminator 1 view .LVU237
 1022 0090 9091 0000 		lds r25,AMUID
 157:main.c        **** 	else return 0;
 1023               		.loc 1 157 64 discriminator 1 view .LVU238
 1024 0094 192B      		or r17,r25
 157:main.c        **** 	else return 0;
 1025               		.loc 1 157 12 discriminator 1 view .LVU239
 1026 0096 0160      		ori r16,1
 1027 0098 E12C      		mov r14,__zero_reg__
 1028 009a 4D2D      		mov r20,r13
 1029 009c 5F2D      		mov r21,r15
 1030 009e 68E0      		ldi r22,lo8(8)
 1031 00a0 0E94 0000 		call CAN_TXMOB
 1032               	.LVL70:
 159:main.c        **** 	_delay_ms(5);
 1033               		.loc 1 159 2 is_stmt 1 discriminator 1 view .LVU240
 1034               	.LBB51:
 1035               	.LBI51:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1036               		.loc 2 166 1 discriminator 1 view .LVU241
 1037               	.LBB52:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1038               		.loc 2 168 2 discriminator 1 view .LVU242
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1039               		.loc 2 172 2 discriminator 1 view .LVU243
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1040               		.loc 2 173 2 discriminator 1 view .LVU244
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1041               		.loc 2 174 2 discriminator 1 view .LVU245
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1042               		.loc 2 184 3 discriminator 1 view .LVU246
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1043               		.loc 2 187 2 discriminator 1 view .LVU247
 1044 00a4 8FE1      		ldi r24,lo8(19999)
 1045 00a6 9EE4      		ldi r25,hi8(19999)
 1046 00a8 0197      	1:	sbiw r24,1
 1047 00aa 01F4      		brne 1b
 1048 00ac 00C0      		rjmp .
 1049 00ae 0000      		nop
 1050               	.LVL71:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1051               		.loc 2 187 2 is_stmt 0 discriminator 1 view .LVU248
 1052               	.LBE52:
 1053               	.LBE51:
 161:main.c        **** 	{
 1054               		.loc 1 161 2 is_stmt 1 discriminator 1 view .LVU249
 1055               	.LBB53:
 161:main.c        **** 	{
 1056               		.loc 1 161 6 discriminator 1 view .LVU250
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1057               		.loc 1 163 3 discriminator 1 view .LVU251
 164:main.c        **** 	}
 1058               		.loc 1 164 3 discriminator 1 view .LVU252
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1059               		.loc 1 163 29 is_stmt 0 discriminator 1 view .LVU253
 1060 00b0 F501      		movw r30,r10
 1061 00b2 E25B      		subi r30,-78
 1062 00b4 FF4F      		sbci r31,-1
 1063 00b6 8081      		ld r24,Z
 1064 00b8 9181      		ldd r25,Z+1
 1065 00ba 9827      		eor r25,r24
 1066 00bc 8927      		eor r24,r25
 1067 00be 9827      		eor r25,r24
 1068 00c0 9A83      		std Y+2,r25
 1069 00c2 8983      		std Y+1,r24
 1070               	.LVL72:
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1071               		.loc 1 163 3 is_stmt 1 discriminator 1 view .LVU254
 164:main.c        **** 	}
 1072               		.loc 1 164 3 discriminator 1 view .LVU255
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1073               		.loc 1 163 29 is_stmt 0 discriminator 1 view .LVU256
 1074 00c4 7296      		adiw r30,18
 1075 00c6 8081      		ld r24,Z
 1076 00c8 9181      		ldd r25,Z+1
 1077 00ca 9827      		eor r25,r24
 1078 00cc 8927      		eor r24,r25
 1079 00ce 9827      		eor r25,r24
 1080 00d0 9C83      		std Y+4,r25
 1081 00d2 8B83      		std Y+3,r24
 1082               	.LVL73:
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1083               		.loc 1 163 3 is_stmt 1 discriminator 1 view .LVU257
 164:main.c        **** 	}
 1084               		.loc 1 164 3 discriminator 1 view .LVU258
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1085               		.loc 1 163 29 is_stmt 0 discriminator 1 view .LVU259
 1086 00d4 7296      		adiw r30,18
 1087 00d6 8081      		ld r24,Z
 1088 00d8 9181      		ldd r25,Z+1
 1089 00da 9827      		eor r25,r24
 1090 00dc 8927      		eor r24,r25
 1091 00de 9827      		eor r25,r24
 1092 00e0 9E83      		std Y+6,r25
 1093 00e2 8D83      		std Y+5,r24
 1094               	.LVL74:
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1095               		.loc 1 163 3 is_stmt 1 discriminator 1 view .LVU260
 164:main.c        **** 	}
 1096               		.loc 1 164 3 discriminator 1 view .LVU261
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1097               		.loc 1 163 29 is_stmt 0 discriminator 1 view .LVU262
 1098 00e4 7296      		adiw r30,18
 1099 00e6 8081      		ld r24,Z
 1100 00e8 9181      		ldd r25,Z+1
 1101 00ea 9827      		eor r25,r24
 1102 00ec 8927      		eor r24,r25
 1103 00ee 9827      		eor r25,r24
 1104 00f0 9887      		std Y+8,r25
 1105 00f2 8F83      		std Y+7,r24
 1106               	.LVL75:
 163:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].voltage;
 1107               		.loc 1 163 29 discriminator 1 view .LVU263
 1108               	.LBE53:
 166:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|VOLT2_ID, 0); 
 1109               		.loc 1 166 2 is_stmt 1 discriminator 1 view .LVU264
 166:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|VOLT2_ID, 0); 
 1110               		.loc 1 166 8 is_stmt 0 discriminator 1 view .LVU265
 1111 00f4 0E94 0000 		call CAN_findFreeTXMOB
 1112               	.LVL76:
 167:main.c        **** 	else return 0;
 1113               		.loc 1 167 2 is_stmt 1 discriminator 1 view .LVU266
 167:main.c        **** 	else return 0;
 1114               		.loc 1 167 4 is_stmt 0 discriminator 1 view .LVU267
 1115 00f8 87FD      		sbrc r24,7
 1116 00fa 00C0      		rjmp .L37
 167:main.c        **** 	else return 0;
 1117               		.loc 1 167 12 is_stmt 1 discriminator 1 view .LVU268
 167:main.c        **** 	else return 0;
 1118               		.loc 1 167 41 is_stmt 0 discriminator 1 view .LVU269
 1119 00fc 0091 0000 		lds r16,deviceID
 1120 0100 1091 0000 		lds r17,deviceID+1
 1121 0104 30E0      		ldi r19,0
 1122 0106 20E0      		ldi r18,0
 167:main.c        **** 	else return 0;
 1123               		.loc 1 167 59 discriminator 1 view .LVU270
 1124 0108 92E1      		ldi r25,18
 1125               		1:
 1126 010a 000F      		lsl r16
 1127 010c 111F      		rol r17
 1128 010e 221F      		rol r18
 1129 0110 331F      		rol r19
 1130 0112 9A95      		dec r25
 1131 0114 01F4      		brne 1b
 167:main.c        **** 	else return 0;
 1132               		.loc 1 167 66 discriminator 1 view .LVU271
 1133 0116 9091 0000 		lds r25,AMUID
 167:main.c        **** 	else return 0;
 1134               		.loc 1 167 64 discriminator 1 view .LVU272
 1135 011a 192B      		or r17,r25
 167:main.c        **** 	else return 0;
 1136               		.loc 1 167 12 discriminator 1 view .LVU273
 1137 011c 0260      		ori r16,2
 1138 011e 4D2D      		mov r20,r13
 1139 0120 5F2D      		mov r21,r15
 1140 0122 68E0      		ldi r22,lo8(8)
 1141 0124 0E94 0000 		call CAN_TXMOB
 1142               	.LVL77:
 169:main.c        **** 	
 1143               		.loc 1 169 2 is_stmt 1 discriminator 1 view .LVU274
 1144               	.LBB54:
 1145               	.LBI54:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1146               		.loc 2 166 1 discriminator 1 view .LVU275
 1147               	.LBB55:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1148               		.loc 2 168 2 discriminator 1 view .LVU276
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1149               		.loc 2 172 2 discriminator 1 view .LVU277
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1150               		.loc 2 173 2 discriminator 1 view .LVU278
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1151               		.loc 2 174 2 discriminator 1 view .LVU279
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1152               		.loc 2 184 3 discriminator 1 view .LVU280
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1153               		.loc 2 187 2 discriminator 1 view .LVU281
 1154 0128 8FE1      		ldi r24,lo8(19999)
 1155 012a 9EE4      		ldi r25,hi8(19999)
 1156 012c 0197      	1:	sbiw r24,1
 1157 012e 01F4      		brne 1b
 1158 0130 00C0      		rjmp .
 1159 0132 0000      		nop
 1160               	.LVL78:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1161               		.loc 2 187 2 is_stmt 0 discriminator 1 view .LVU282
 1162               	.LBE55:
 1163               	.LBE54:
 171:main.c        **** }
 1164               		.loc 1 171 2 is_stmt 1 discriminator 1 view .LVU283
 171:main.c        **** }
 1165               		.loc 1 171 9 is_stmt 0 discriminator 1 view .LVU284
 1166 0134 81E0      		ldi r24,lo8(1)
 1167 0136 00C0      		rjmp .L33
 1168               		.cfi_endproc
 1169               	.LFE24:
 1171               		.section	.text.Convert_ADCtoCelsius,"ax",@progbits
 1172               	.global	Convert_ADCtoCelsius
 1174               	Convert_ADCtoCelsius:
 1175               	.LVL79:
 1176               	.LFB25:
 173:main.c        **** 
 174:main.c        **** 
 175:main.c        **** uint16_t Convert_ADCtoCelsius(uint16_t ADCValue)		//will spit out a value from 0 to 140  (ADC 10 bi
 176:main.c        **** {
 1177               		.loc 1 176 1 is_stmt 1 view -0
 1178               		.cfi_startproc
 1179               	/* prologue: function */
 1180               	/* frame size = 0 */
 1181               	/* stack size = 0 */
 1182               	.L__stack_usage = 0
 1183               		.loc 1 176 1 is_stmt 0 view .LVU286
 1184 0000 AC01      		movw r20,r24
 177:main.c        **** 	if(ADCValue >= 1023)return 255;				//this indicates the sensor has failed, perhaps a short somewhe
 1185               		.loc 1 177 2 is_stmt 1 view .LVU287
 178:main.c        **** 	if(ADCValue < 187 )return 255;				//finish the conversion with error if the value will be invalid.
 1186               		.loc 1 178 2 view .LVU288
 1187               		.loc 1 178 4 is_stmt 0 view .LVU289
 1188 0002 8B5B      		subi r24,-69
 1189 0004 9109      		sbc r25,__zero_reg__
 1190               	.LVL80:
 1191               		.loc 1 178 4 view .LVU290
 1192 0006 8434      		cpi r24,68
 1193 0008 9340      		sbci r25,3
 1194 000a 00F4      		brsh .L43
 1195               	.LBB58:
 1196               	.LBB59:
 179:main.c        **** 	uint8_t i = 0;
 1197               		.loc 1 179 10 view .LVU291
 1198 000c 90E0      		ldi r25,0
 1199               	.L41:
 1200               	.LVL81:
 180:main.c        **** 	while(TEMP_Celsius_pos[i] > ADCValue) i++;	//move through the array until values position is found
 1201               		.loc 1 180 24 view .LVU292
 1202 000e 292F      		mov r18,r25
 1203 0010 30E0      		ldi r19,0
 1204 0012 F901      		movw r30,r18
 1205 0014 EE0F      		lsl r30
 1206 0016 FF1F      		rol r31
 1207 0018 E050      		subi r30,lo8(-(TEMP_Celsius_pos))
 1208 001a F040      		sbci r31,hi8(-(TEMP_Celsius_pos))
 1209               		.loc 1 180 7 view .LVU293
 1210 001c 6081      		ld r22,Z
 1211 001e 7181      		ldd r23,Z+1
 1212 0020 4617      		cp r20,r22
 1213 0022 5707      		cpc r21,r23
 1214 0024 00F0      		brlo .L42
 181:main.c        **** 	return i;
 1215               		.loc 1 181 2 is_stmt 1 view .LVU294
 1216               		.loc 1 181 9 is_stmt 0 view .LVU295
 1217 0026 C901      		movw r24,r18
 1218               	.LVL82:
 1219               		.loc 1 181 9 view .LVU296
 1220 0028 0895      		ret
 1221               	.LVL83:
 1222               	.L42:
 180:main.c        **** 	while(TEMP_Celsius_pos[i] > ADCValue) i++;	//move through the array until values position is found
 1223               		.loc 1 180 40 is_stmt 1 view .LVU297
 180:main.c        **** 	while(TEMP_Celsius_pos[i] > ADCValue) i++;	//move through the array until values position is found
 1224               		.loc 1 180 41 is_stmt 0 view .LVU298
 1225 002a 9F5F      		subi r25,lo8(-(1))
 1226               	.LVL84:
 180:main.c        **** 	while(TEMP_Celsius_pos[i] > ADCValue) i++;	//move through the array until values position is found
 1227               		.loc 1 180 41 view .LVU299
 1228 002c 00C0      		rjmp .L41
 1229               	.LVL85:
 1230               	.L43:
 180:main.c        **** 	while(TEMP_Celsius_pos[i] > ADCValue) i++;	//move through the array until values position is found
 1231               		.loc 1 180 41 view .LVU300
 1232               	.LBE59:
 1233               	.LBE58:
 178:main.c        **** 	uint8_t i = 0;
 1234               		.loc 1 178 28 view .LVU301
 1235 002e 8FEF      		ldi r24,lo8(-1)
 1236 0030 90E0      		ldi r25,0
 1237               	/* epilogue start */
 182:main.c        **** }
 1238               		.loc 1 182 1 view .LVU302
 1239 0032 0895      		ret
 1240               		.cfi_endproc
 1241               	.LFE25:
 1243               		.section	.text.Read_temp,"ax",@progbits
 1244               	.global	Read_temp
 1246               	Read_temp:
 1247               	.LVL86:
 1248               	.LFB26:
 183:main.c        **** 
 184:main.c        **** uint16_t Read_temp(cell * _cell)
 185:main.c        **** {
 1249               		.loc 1 185 1 is_stmt 1 view -0
 1250               		.cfi_startproc
 1251               		.loc 1 185 1 is_stmt 0 view .LVU304
 1252 0000 CF92      		push r12
 1253               	.LCFI26:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 12, -2
 1256 0002 DF92      		push r13
 1257               	.LCFI27:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 13, -3
 1260 0004 EF92      		push r14
 1261               	.LCFI28:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 14, -4
 1264 0006 FF92      		push r15
 1265               	.LCFI29:
 1266               		.cfi_def_cfa_offset 6
 1267               		.cfi_offset 15, -5
 1268 0008 CF93      		push r28
 1269               	.LCFI30:
 1270               		.cfi_def_cfa_offset 7
 1271               		.cfi_offset 28, -6
 1272               	/* prologue: function */
 1273               	/* frame size = 0 */
 1274               	/* stack size = 5 */
 1275               	.L__stack_usage = 5
 186:main.c        **** 
 187:main.c        **** 
 188:main.c        **** 	uint32_t sum = 0;
 1276               		.loc 1 188 2 is_stmt 1 view .LVU305
 1277               	.LVL87:
 189:main.c        **** 	PORTD = (PORTD & 0xe3)|((_cell->temp_channel<<2) & 0x1c);		//so as to not change the rest of PORTD
 1278               		.loc 1 189 2 view .LVU306
 1279               		.loc 1 189 11 is_stmt 0 view .LVU307
 1280 000a 2BB1      		in r18,0xb
 1281               		.loc 1 189 32 view .LVU308
 1282 000c FC01      		movw r30,r24
 1283 000e 9081      		ld r25,Z
 1284               		.loc 1 189 46 view .LVU309
 1285 0010 F4E0      		ldi r31,lo8(4)
 1286 0012 9F9F      		mul r25,r31
 1287 0014 C001      		movw r24,r0
 1288 0016 1124      		clr __zero_reg__
 1289               	.LVL88:
 1290               		.loc 1 189 51 view .LVU310
 1291 0018 8C71      		andi r24,lo8(28)
 1292               		.loc 1 189 17 view .LVU311
 1293 001a 237E      		andi r18,lo8(-29)
 1294               		.loc 1 189 24 view .LVU312
 1295 001c 822B      		or r24,r18
 1296               		.loc 1 189 8 view .LVU313
 1297 001e 8BB9      		out 0xb,r24
 190:main.c        **** 	for(uint8_t c = 0; c < ADC_SAMPLES; c++)
 1298               		.loc 1 190 2 is_stmt 1 view .LVU314
 1299               	.LBB60:
 1300               		.loc 1 190 6 view .LVU315
 1301               	.LVL89:
 1302               		.loc 1 190 14 is_stmt 0 view .LVU316
 1303 0020 C0E0      		ldi r28,0
 1304               	.LBE60:
 188:main.c        **** 	PORTD = (PORTD & 0xe3)|((_cell->temp_channel<<2) & 0x1c);		//so as to not change the rest of PORTD
 1305               		.loc 1 188 11 view .LVU317
 1306 0022 C12C      		mov r12,__zero_reg__
 1307 0024 D12C      		mov r13,__zero_reg__
 1308 0026 7601      		movw r14,r12
 1309               	.LVL90:
 1310               	.L45:
 1311               	.LBB61:
 1312               		.loc 1 190 2 discriminator 1 view .LVU318
 1313 0028 8091 0000 		lds r24,ADC_SAMPLES
 1314 002c 9091 0000 		lds r25,ADC_SAMPLES+1
 1315 0030 C817      		cp r28,r24
 1316 0032 1906      		cpc __zero_reg__,r25
 1317 0034 00F0      		brlo .L46
 1318               	.LBE61:
 191:main.c        **** 	{
 192:main.c        **** 		//elementToUpdate = (rand() % AVG_V_SIZE);						//choose a random element to update
 193:main.c        **** 		sum += Convert_ADCtoCelsius(ADC_read(TEMP_MULTIPLEX_CH));			//read the voltage
 194:main.c        **** 		//if(elementToUpdate < AVG_V_SIZE)_cell->voltages[elementToUpdate] = tempVoltage;	//if the random
 195:main.c        **** 	}
 196:main.c        **** 	return (uint16_t)(sum/AVG_V_SIZE);	//return the average.
 1319               		.loc 1 196 2 is_stmt 1 view .LVU319
 1320               		.loc 1 196 23 is_stmt 0 view .LVU320
 1321 0036 C701      		movw r24,r14
 1322 0038 B601      		movw r22,r12
 1323 003a 25E0      		ldi r18,lo8(5)
 1324 003c 30E0      		ldi r19,0
 1325 003e 40E0      		ldi r20,0
 1326 0040 50E0      		ldi r21,0
 1327 0042 0E94 0000 		call __udivmodsi4
 197:main.c        **** 	
 198:main.c        **** 	/*
 199:main.c        **** 	uint16_t tempTemp[ADC_SAMPLES-1];
 200:main.c        **** 	uint8_t count = 0;
 201:main.c        **** 	uint16_t sum = 0, avgTemp = 0;
 202:main.c        **** 	PORTD = (PORTD & 0xe3)|((_cell.temp_channel & 0x1c)<<2);		//so as to not change the rest of PORTD,
 203:main.c        **** 	for(uint8_t i = 0; i < ADC_SAMPLES; i++)
 204:main.c        **** 	{
 205:main.c        **** 		tempTemp[i] = Convert_ADCtoCelsius(ADC_read(TEMP_MULTIPLEX_CH));	//retrieve ADC reading from our 
 206:main.c        **** 		if (tempTemp[i] != 255)
 207:main.c        **** 		{
 208:main.c        **** 			sum+= tempTemp[i];		//add the temp to the sum if it's valid
 209:main.c        **** 			count++;				//increment the counter of valid values.
 210:main.c        **** 		}
 211:main.c        **** 	}
 212:main.c        **** 	avgTemp = sum/count;
 213:main.c        **** 	if(!count)return 255;			//if there were no valid values, return error value;
 214:main.c        **** 	else return avgTemp;			//otherwise return the average of the ADC_SAMPLES taken
 215:main.c        **** 	*/
 216:main.c        **** }
 1328               		.loc 1 216 1 view .LVU321
 1329 0046 C901      		movw r24,r18
 1330               	/* epilogue start */
 1331 0048 CF91      		pop r28
 1332               	.LVL91:
 1333               		.loc 1 216 1 view .LVU322
 1334 004a FF90      		pop r15
 1335 004c EF90      		pop r14
 1336 004e DF90      		pop r13
 1337 0050 CF90      		pop r12
 1338               	.LVL92:
 1339               		.loc 1 216 1 view .LVU323
 1340 0052 0895      		ret
 1341               	.LVL93:
 1342               	.L46:
 1343               	.LBB62:
 193:main.c        **** 		//if(elementToUpdate < AVG_V_SIZE)_cell->voltages[elementToUpdate] = tempVoltage;	//if the random
 1344               		.loc 1 193 3 is_stmt 1 discriminator 3 view .LVU324
 193:main.c        **** 		//if(elementToUpdate < AVG_V_SIZE)_cell->voltages[elementToUpdate] = tempVoltage;	//if the random
 1345               		.loc 1 193 10 is_stmt 0 discriminator 3 view .LVU325
 1346 0054 82E0      		ldi r24,lo8(2)
 1347 0056 0E94 0000 		call ADC_read
 1348               	.LVL94:
 1349 005a 0E94 0000 		call Convert_ADCtoCelsius
 1350               	.LVL95:
 193:main.c        **** 		//if(elementToUpdate < AVG_V_SIZE)_cell->voltages[elementToUpdate] = tempVoltage;	//if the random
 1351               		.loc 1 193 7 discriminator 3 view .LVU326
 1352 005e C80E      		add r12,r24
 1353 0060 D91E      		adc r13,r25
 1354 0062 E11C      		adc r14,__zero_reg__
 1355 0064 F11C      		adc r15,__zero_reg__
 1356               	.LVL96:
 190:main.c        **** 	{
 1357               		.loc 1 190 39 discriminator 3 view .LVU327
 1358 0066 CF5F      		subi r28,lo8(-(1))
 1359               	.LVL97:
 190:main.c        **** 	{
 1360               		.loc 1 190 39 discriminator 3 view .LVU328
 1361 0068 00C0      		rjmp .L45
 1362               	.LBE62:
 1363               		.cfi_endproc
 1364               	.LFE26:
 1366               		.section	.text.Read_all_temps,"ax",@progbits
 1367               	.global	Read_all_temps
 1369               	Read_all_temps:
 1370               	.LVL98:
 1371               	.LFB27:
 217:main.c        **** 
 218:main.c        **** void Read_all_temps(cell *_cells)
 219:main.c        **** {
 1372               		.loc 1 219 1 is_stmt 1 view -0
 1373               		.cfi_startproc
 1374               		.loc 1 219 1 is_stmt 0 view .LVU330
 1375 0000 0F93      		push r16
 1376               	.LCFI31:
 1377               		.cfi_def_cfa_offset 3
 1378               		.cfi_offset 16, -2
 1379 0002 1F93      		push r17
 1380               	.LCFI32:
 1381               		.cfi_def_cfa_offset 4
 1382               		.cfi_offset 17, -3
 1383 0004 CF93      		push r28
 1384               	.LCFI33:
 1385               		.cfi_def_cfa_offset 5
 1386               		.cfi_offset 28, -4
 1387 0006 DF93      		push r29
 1388               	.LCFI34:
 1389               		.cfi_def_cfa_offset 6
 1390               		.cfi_offset 29, -5
 1391               	/* prologue: function */
 1392               	/* frame size = 0 */
 1393               	/* stack size = 4 */
 1394               	.L__stack_usage = 4
 1395 0008 EC01      		movw r28,r24
 220:main.c        **** 	cell * t_cells = _cells;
 1396               		.loc 1 220 2 is_stmt 1 view .LVU331
 221:main.c        **** 	for (uint8_t cellCount = 0; cellCount <= 7; cellCount++)
 1397               		.loc 1 221 2 view .LVU332
 1398               	.LBB63:
 1399               		.loc 1 221 7 view .LVU333
 1400               	.LVL99:
 1401               		.loc 1 221 7 is_stmt 0 view .LVU334
 1402 000a 8C01      		movw r16,r24
 1403 000c 0057      		subi r16,112
 1404 000e 1F4F      		sbci r17,-1
 1405               	.LVL100:
 1406               	.L48:
 222:main.c        **** 	{
 223:main.c        **** 		t_cells = _cells+cellCount;									//our address must increment to modify/use the next value in 
 1407               		.loc 1 223 3 is_stmt 1 discriminator 3 view .LVU335
 224:main.c        **** 		t_cells->temperature = Read_temp(t_cells);		//move through all the cells and assign temperatures.
 1408               		.loc 1 224 3 discriminator 3 view .LVU336
 1409               		.loc 1 224 26 is_stmt 0 discriminator 3 view .LVU337
 1410 0010 CE01      		movw r24,r28
 1411 0012 0E94 0000 		call Read_temp
 1412               	.LVL101:
 1413               		.loc 1 224 24 discriminator 3 view .LVU338
 1414 0016 9D83      		std Y+5,r25
 1415 0018 8C83      		std Y+4,r24
 1416               		.loc 1 224 24 discriminator 3 view .LVU339
 1417 001a 6296      		adiw r28,18
 1418               	.LVL102:
 221:main.c        **** 	for (uint8_t cellCount = 0; cellCount <= 7; cellCount++)
 1419               		.loc 1 221 2 discriminator 3 view .LVU340
 1420 001c C017      		cp r28,r16
 1421 001e D107      		cpc r29,r17
 1422 0020 01F4      		brne .L48
 1423               	/* epilogue start */
 1424               	.LBE63:
 225:main.c        **** 	}
 226:main.c        **** }
 1425               		.loc 1 226 1 view .LVU341
 1426 0022 DF91      		pop r29
 1427 0024 CF91      		pop r28
 1428               	.LVL103:
 1429               		.loc 1 226 1 view .LVU342
 1430 0026 1F91      		pop r17
 1431 0028 0F91      		pop r16
 1432               	.LVL104:
 1433               		.loc 1 226 1 view .LVU343
 1434 002a 0895      		ret
 1435               		.cfi_endproc
 1436               	.LFE27:
 1438               		.section	.text.TX_cellTemps,"ax",@progbits
 1439               	.global	TX_cellTemps
 1441               	TX_cellTemps:
 1442               	.LVL105:
 1443               	.LFB28:
 227:main.c        **** 
 228:main.c        **** uint8_t TX_cellTemps(cell *_cells)
 229:main.c        **** {
 1444               		.loc 1 229 1 is_stmt 1 view -0
 1445               		.cfi_startproc
 1446               		.loc 1 229 1 is_stmt 0 view .LVU345
 1447 0000 AF92      		push r10
 1448               	.LCFI35:
 1449               		.cfi_def_cfa_offset 3
 1450               		.cfi_offset 10, -2
 1451 0002 BF92      		push r11
 1452               	.LCFI36:
 1453               		.cfi_def_cfa_offset 4
 1454               		.cfi_offset 11, -3
 1455 0004 DF92      		push r13
 1456               	.LCFI37:
 1457               		.cfi_def_cfa_offset 5
 1458               		.cfi_offset 13, -4
 1459 0006 EF92      		push r14
 1460               	.LCFI38:
 1461               		.cfi_def_cfa_offset 6
 1462               		.cfi_offset 14, -5
 1463 0008 FF92      		push r15
 1464               	.LCFI39:
 1465               		.cfi_def_cfa_offset 7
 1466               		.cfi_offset 15, -6
 1467 000a 0F93      		push r16
 1468               	.LCFI40:
 1469               		.cfi_def_cfa_offset 8
 1470               		.cfi_offset 16, -7
 1471 000c 1F93      		push r17
 1472               	.LCFI41:
 1473               		.cfi_def_cfa_offset 9
 1474               		.cfi_offset 17, -8
 1475 000e CF93      		push r28
 1476               	.LCFI42:
 1477               		.cfi_def_cfa_offset 10
 1478               		.cfi_offset 28, -9
 1479 0010 DF93      		push r29
 1480               	.LCFI43:
 1481               		.cfi_def_cfa_offset 11
 1482               		.cfi_offset 29, -10
 1483 0012 CDB7      		in r28,__SP_L__
 1484 0014 DEB7      		in r29,__SP_H__
 1485               	.LCFI44:
 1486               		.cfi_def_cfa_register 28
 1487 0016 2897      		sbiw r28,8
 1488               	.LCFI45:
 1489               		.cfi_def_cfa_offset 19
 1490 0018 0FB6      		in __tmp_reg__,__SREG__
 1491 001a F894      		cli
 1492 001c DEBF      		out __SP_H__,r29
 1493 001e 0FBE      		out __SREG__,__tmp_reg__
 1494 0020 CDBF      		out __SP_L__,r28
 1495               	/* prologue: function */
 1496               	/* frame size = 8 */
 1497               	/* stack size = 17 */
 1498               	.L__stack_usage = 17
 1499 0022 5C01      		movw r10,r24
 230:main.c        **** 	int8_t mob;
 1500               		.loc 1 230 2 is_stmt 1 view .LVU346
 231:main.c        **** 	uint8_t tempData[8];
 1501               		.loc 1 231 2 view .LVU347
 232:main.c        **** 	
 233:main.c        **** 	for(uint8_t cellCount = 0; cellCount <= 3; cellCount++)
 1502               		.loc 1 233 2 view .LVU348
 1503               	.LBB64:
 1504               		.loc 1 233 6 view .LVU349
 1505               	.LVL106:
 1506               		.loc 1 233 6 is_stmt 0 view .LVU350
 1507 0024 DC01      		movw r26,r24
 1508 0026 FE01      		movw r30,r28
 1509 0028 3196      		adiw r30,1
 1510 002a CE01      		movw r24,r28
 1511               	.LVL107:
 1512               		.loc 1 233 6 view .LVU351
 1513 002c 0996      		adiw r24,9
 1514 002e DE2E      		mov r13,r30
 1515 0030 FF2E      		mov r15,r31
 1516               	.LVL108:
 1517               	.L51:
 234:main.c        **** 	{
 235:main.c        **** 		tempData[cellCount*2]	= _cells[cellCount].temperature >> 8;
 1518               		.loc 1 235 3 is_stmt 1 discriminator 3 view .LVU352
 1519               		.loc 1 235 44 is_stmt 0 discriminator 3 view .LVU353
 1520 0032 1496      		adiw r26,4
 1521 0034 2C91      		ld r18,X
 1522 0036 1497      		sbiw r26,4
 1523 0038 1596      		adiw r26,5
 1524 003a 3C91      		ld r19,X
 1525 003c 1597      		sbiw r26,5
 1526               		.loc 1 235 25 discriminator 3 view .LVU354
 1527 003e 3083      		st Z,r19
 236:main.c        **** 		tempData[cellCount*2+1] = _cells[cellCount].temperature;
 1528               		.loc 1 236 3 is_stmt 1 discriminator 3 view .LVU355
 1529               		.loc 1 236 27 is_stmt 0 discriminator 3 view .LVU356
 1530 0040 2183      		std Z+1,r18
 1531               		.loc 1 236 27 discriminator 3 view .LVU357
 1532 0042 5296      		adiw r26,18
 1533 0044 3296      		adiw r30,2
 233:main.c        **** 	{
 1534               		.loc 1 233 2 discriminator 3 view .LVU358
 1535 0046 8E17      		cp r24,r30
 1536 0048 9F07      		cpc r25,r31
 1537 004a 01F4      		brne .L51
 1538               	.LBE64:
 237:main.c        **** 	}
 238:main.c        **** 	mob = CAN_findFreeTXMOB();
 1539               		.loc 1 238 2 is_stmt 1 view .LVU359
 1540               		.loc 1 238 8 is_stmt 0 view .LVU360
 1541 004c 0E94 0000 		call CAN_findFreeTXMOB
 1542               	.LVL109:
 239:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|TEMP1_ID, 0); 
 1543               		.loc 1 239 2 is_stmt 1 view .LVU361
 1544               		.loc 1 239 4 is_stmt 0 view .LVU362
 1545 0050 87FF      		sbrs r24,7
 1546 0052 00C0      		rjmp .L52
 1547               	.L54:
 240:main.c        **** 	else return 0;
 1548               		.loc 1 240 14 view .LVU363
 1549 0054 80E0      		ldi r24,0
 1550               	.LVL110:
 1551               	.L50:
 1552               	/* epilogue start */
 241:main.c        **** 	_delay_ms(5);
 242:main.c        **** 	for(uint8_t cellCount = 4; cellCount <= 7; cellCount++)
 243:main.c        **** 	{
 244:main.c        **** 		tempData[(cellCount-4)*2]	= _cells[cellCount].temperature >> 8;
 245:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 246:main.c        **** 	}
 247:main.c        **** 	mob = CAN_findFreeTXMOB();
 248:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|TEMP2_ID, 0); 
 249:main.c        **** 	else return 0;
 250:main.c        **** 	_delay_ms(5);
 251:main.c        **** 	return 1;
 252:main.c        **** }
 1553               		.loc 1 252 1 view .LVU364
 1554 0056 2896      		adiw r28,8
 1555 0058 0FB6      		in __tmp_reg__,__SREG__
 1556 005a F894      		cli
 1557 005c DEBF      		out __SP_H__,r29
 1558 005e 0FBE      		out __SREG__,__tmp_reg__
 1559 0060 CDBF      		out __SP_L__,r28
 1560 0062 DF91      		pop r29
 1561 0064 CF91      		pop r28
 1562 0066 1F91      		pop r17
 1563 0068 0F91      		pop r16
 1564 006a FF90      		pop r15
 1565 006c EF90      		pop r14
 1566 006e DF90      		pop r13
 1567 0070 BF90      		pop r11
 1568 0072 AF90      		pop r10
 1569               	.LVL111:
 1570               		.loc 1 252 1 view .LVU365
 1571 0074 0895      		ret
 1572               	.LVL112:
 1573               	.L52:
 239:main.c        **** 	else return 0;
 1574               		.loc 1 239 12 is_stmt 1 discriminator 1 view .LVU366
 239:main.c        **** 	else return 0;
 1575               		.loc 1 239 41 is_stmt 0 discriminator 1 view .LVU367
 1576 0076 0091 0000 		lds r16,deviceID
 1577 007a 1091 0000 		lds r17,deviceID+1
 1578 007e 30E0      		ldi r19,0
 1579 0080 20E0      		ldi r18,0
 239:main.c        **** 	else return 0;
 1580               		.loc 1 239 59 discriminator 1 view .LVU368
 1581 0082 42E1      		ldi r20,18
 1582               		1:
 1583 0084 000F      		lsl r16
 1584 0086 111F      		rol r17
 1585 0088 221F      		rol r18
 1586 008a 331F      		rol r19
 1587 008c 4A95      		dec r20
 1588 008e 01F4      		brne 1b
 239:main.c        **** 	else return 0;
 1589               		.loc 1 239 66 discriminator 1 view .LVU369
 1590 0090 9091 0000 		lds r25,AMUID
 239:main.c        **** 	else return 0;
 1591               		.loc 1 239 64 discriminator 1 view .LVU370
 1592 0094 192B      		or r17,r25
 239:main.c        **** 	else return 0;
 1593               		.loc 1 239 12 discriminator 1 view .LVU371
 1594 0096 0460      		ori r16,4
 1595 0098 E12C      		mov r14,__zero_reg__
 1596 009a 4D2D      		mov r20,r13
 1597 009c 5F2D      		mov r21,r15
 1598 009e 68E0      		ldi r22,lo8(8)
 1599 00a0 0E94 0000 		call CAN_TXMOB
 1600               	.LVL113:
 241:main.c        **** 	_delay_ms(5);
 1601               		.loc 1 241 2 is_stmt 1 discriminator 1 view .LVU372
 1602               	.LBB65:
 1603               	.LBI65:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1604               		.loc 2 166 1 discriminator 1 view .LVU373
 1605               	.LBB66:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1606               		.loc 2 168 2 discriminator 1 view .LVU374
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1607               		.loc 2 172 2 discriminator 1 view .LVU375
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1608               		.loc 2 173 2 discriminator 1 view .LVU376
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1609               		.loc 2 174 2 discriminator 1 view .LVU377
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1610               		.loc 2 184 3 discriminator 1 view .LVU378
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1611               		.loc 2 187 2 discriminator 1 view .LVU379
 1612 00a4 8FE1      		ldi r24,lo8(19999)
 1613 00a6 9EE4      		ldi r25,hi8(19999)
 1614 00a8 0197      	1:	sbiw r24,1
 1615 00aa 01F4      		brne 1b
 1616 00ac 00C0      		rjmp .
 1617 00ae 0000      		nop
 1618               	.LVL114:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1619               		.loc 2 187 2 is_stmt 0 discriminator 1 view .LVU380
 1620               	.LBE66:
 1621               	.LBE65:
 242:main.c        **** 	{
 1622               		.loc 1 242 2 is_stmt 1 discriminator 1 view .LVU381
 1623               	.LBB67:
 242:main.c        **** 	{
 1624               		.loc 1 242 6 discriminator 1 view .LVU382
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1625               		.loc 1 244 3 discriminator 1 view .LVU383
 245:main.c        **** 	}
 1626               		.loc 1 245 3 discriminator 1 view .LVU384
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1627               		.loc 1 244 29 is_stmt 0 discriminator 1 view .LVU385
 1628 00b0 F501      		movw r30,r10
 1629 00b2 E45B      		subi r30,-76
 1630 00b4 FF4F      		sbci r31,-1
 1631 00b6 8081      		ld r24,Z
 1632 00b8 9181      		ldd r25,Z+1
 1633 00ba 9827      		eor r25,r24
 1634 00bc 8927      		eor r24,r25
 1635 00be 9827      		eor r25,r24
 1636 00c0 9A83      		std Y+2,r25
 1637 00c2 8983      		std Y+1,r24
 1638               	.LVL115:
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1639               		.loc 1 244 3 is_stmt 1 discriminator 1 view .LVU386
 245:main.c        **** 	}
 1640               		.loc 1 245 3 discriminator 1 view .LVU387
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1641               		.loc 1 244 29 is_stmt 0 discriminator 1 view .LVU388
 1642 00c4 7296      		adiw r30,18
 1643 00c6 8081      		ld r24,Z
 1644 00c8 9181      		ldd r25,Z+1
 1645 00ca 9827      		eor r25,r24
 1646 00cc 8927      		eor r24,r25
 1647 00ce 9827      		eor r25,r24
 1648 00d0 9C83      		std Y+4,r25
 1649 00d2 8B83      		std Y+3,r24
 1650               	.LVL116:
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1651               		.loc 1 244 3 is_stmt 1 discriminator 1 view .LVU389
 245:main.c        **** 	}
 1652               		.loc 1 245 3 discriminator 1 view .LVU390
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1653               		.loc 1 244 29 is_stmt 0 discriminator 1 view .LVU391
 1654 00d4 7296      		adiw r30,18
 1655 00d6 8081      		ld r24,Z
 1656 00d8 9181      		ldd r25,Z+1
 1657 00da 9827      		eor r25,r24
 1658 00dc 8927      		eor r24,r25
 1659 00de 9827      		eor r25,r24
 1660 00e0 9E83      		std Y+6,r25
 1661 00e2 8D83      		std Y+5,r24
 1662               	.LVL117:
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1663               		.loc 1 244 3 is_stmt 1 discriminator 1 view .LVU392
 245:main.c        **** 	}
 1664               		.loc 1 245 3 discriminator 1 view .LVU393
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1665               		.loc 1 244 29 is_stmt 0 discriminator 1 view .LVU394
 1666 00e4 7296      		adiw r30,18
 1667 00e6 8081      		ld r24,Z
 1668 00e8 9181      		ldd r25,Z+1
 1669 00ea 9827      		eor r25,r24
 1670 00ec 8927      		eor r24,r25
 1671 00ee 9827      		eor r25,r24
 1672 00f0 9887      		std Y+8,r25
 1673 00f2 8F83      		std Y+7,r24
 1674               	.LVL118:
 244:main.c        **** 		tempData[(cellCount-4)*2+1] = _cells[cellCount].temperature;
 1675               		.loc 1 244 29 discriminator 1 view .LVU395
 1676               	.LBE67:
 247:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|TEMP2_ID, 0); 
 1677               		.loc 1 247 2 is_stmt 1 discriminator 1 view .LVU396
 247:main.c        **** 	if(mob>=0)CAN_TXMOB(mob, 8, tempData, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|TEMP2_ID, 0); 
 1678               		.loc 1 247 8 is_stmt 0 discriminator 1 view .LVU397
 1679 00f4 0E94 0000 		call CAN_findFreeTXMOB
 1680               	.LVL119:
 248:main.c        **** 	else return 0;
 1681               		.loc 1 248 2 is_stmt 1 discriminator 1 view .LVU398
 248:main.c        **** 	else return 0;
 1682               		.loc 1 248 4 is_stmt 0 discriminator 1 view .LVU399
 1683 00f8 87FD      		sbrc r24,7
 1684 00fa 00C0      		rjmp .L54
 248:main.c        **** 	else return 0;
 1685               		.loc 1 248 12 is_stmt 1 discriminator 1 view .LVU400
 248:main.c        **** 	else return 0;
 1686               		.loc 1 248 41 is_stmt 0 discriminator 1 view .LVU401
 1687 00fc 0091 0000 		lds r16,deviceID
 1688 0100 1091 0000 		lds r17,deviceID+1
 1689 0104 30E0      		ldi r19,0
 1690 0106 20E0      		ldi r18,0
 248:main.c        **** 	else return 0;
 1691               		.loc 1 248 59 discriminator 1 view .LVU402
 1692 0108 92E1      		ldi r25,18
 1693               		1:
 1694 010a 000F      		lsl r16
 1695 010c 111F      		rol r17
 1696 010e 221F      		rol r18
 1697 0110 331F      		rol r19
 1698 0112 9A95      		dec r25
 1699 0114 01F4      		brne 1b
 248:main.c        **** 	else return 0;
 1700               		.loc 1 248 66 discriminator 1 view .LVU403
 1701 0116 9091 0000 		lds r25,AMUID
 248:main.c        **** 	else return 0;
 1702               		.loc 1 248 64 discriminator 1 view .LVU404
 1703 011a 192B      		or r17,r25
 248:main.c        **** 	else return 0;
 1704               		.loc 1 248 12 discriminator 1 view .LVU405
 1705 011c 0560      		ori r16,5
 1706 011e 4D2D      		mov r20,r13
 1707 0120 5F2D      		mov r21,r15
 1708 0122 68E0      		ldi r22,lo8(8)
 1709 0124 0E94 0000 		call CAN_TXMOB
 1710               	.LVL120:
 250:main.c        **** 	return 1;
 1711               		.loc 1 250 2 is_stmt 1 discriminator 1 view .LVU406
 1712               	.LBB68:
 1713               	.LBI68:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 1714               		.loc 2 166 1 discriminator 1 view .LVU407
 1715               	.LBB69:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1716               		.loc 2 168 2 discriminator 1 view .LVU408
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1717               		.loc 2 172 2 discriminator 1 view .LVU409
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1718               		.loc 2 173 2 discriminator 1 view .LVU410
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1719               		.loc 2 174 2 discriminator 1 view .LVU411
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 1720               		.loc 2 184 3 discriminator 1 view .LVU412
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1721               		.loc 2 187 2 discriminator 1 view .LVU413
 1722 0128 8FE1      		ldi r24,lo8(19999)
 1723 012a 9EE4      		ldi r25,hi8(19999)
 1724 012c 0197      	1:	sbiw r24,1
 1725 012e 01F4      		brne 1b
 1726 0130 00C0      		rjmp .
 1727 0132 0000      		nop
 1728               	.LVL121:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 1729               		.loc 2 187 2 is_stmt 0 discriminator 1 view .LVU414
 1730               	.LBE69:
 1731               	.LBE68:
 251:main.c        **** }
 1732               		.loc 1 251 2 is_stmt 1 discriminator 1 view .LVU415
 251:main.c        **** }
 1733               		.loc 1 251 9 is_stmt 0 discriminator 1 view .LVU416
 1734 0134 81E0      		ldi r24,lo8(1)
 1735 0136 00C0      		rjmp .L50
 1736               		.cfi_endproc
 1737               	.LFE28:
 1739               		.section	.text.Discharge_cells,"ax",@progbits
 1740               	.global	Discharge_cells
 1742               	Discharge_cells:
 1743               	.LFB29:
 253:main.c        **** 
 254:main.c        **** void Discharge_cells(cell high_1, cell high_2, cell high_3, cell lowest)					//parameters: cell to 
 255:main.c        **** {
 1744               		.loc 1 255 1 is_stmt 1 view -0
 1745               		.cfi_startproc
 1746 0000 8F92      		push r8
 1747               	.LCFI46:
 1748               		.cfi_def_cfa_offset 3
 1749               		.cfi_offset 8, -2
 1750 0002 9F92      		push r9
 1751               	.LCFI47:
 1752               		.cfi_def_cfa_offset 4
 1753               		.cfi_offset 9, -3
 1754 0004 AF92      		push r10
 1755               	.LCFI48:
 1756               		.cfi_def_cfa_offset 5
 1757               		.cfi_offset 10, -4
 1758 0006 BF92      		push r11
 1759               	.LCFI49:
 1760               		.cfi_def_cfa_offset 6
 1761               		.cfi_offset 11, -5
 1762 0008 CF92      		push r12
 1763               	.LCFI50:
 1764               		.cfi_def_cfa_offset 7
 1765               		.cfi_offset 12, -6
 1766 000a DF92      		push r13
 1767               	.LCFI51:
 1768               		.cfi_def_cfa_offset 8
 1769               		.cfi_offset 13, -7
 1770 000c EF92      		push r14
 1771               	.LCFI52:
 1772               		.cfi_def_cfa_offset 9
 1773               		.cfi_offset 14, -8
 1774 000e FF92      		push r15
 1775               	.LCFI53:
 1776               		.cfi_def_cfa_offset 10
 1777               		.cfi_offset 15, -9
 1778 0010 0F93      		push r16
 1779               	.LCFI54:
 1780               		.cfi_def_cfa_offset 11
 1781               		.cfi_offset 16, -10
 1782 0012 1F93      		push r17
 1783               	.LCFI55:
 1784               		.cfi_def_cfa_offset 12
 1785               		.cfi_offset 17, -11
 1786 0014 CF93      		push r28
 1787               	.LCFI56:
 1788               		.cfi_def_cfa_offset 13
 1789               		.cfi_offset 28, -12
 1790 0016 DF93      		push r29
 1791               	.LCFI57:
 1792               		.cfi_def_cfa_offset 14
 1793               		.cfi_offset 29, -13
 1794 0018 CDB7      		in r28,__SP_L__
 1795 001a DEB7      		in r29,__SP_H__
 1796               	.LCFI58:
 1797               		.cfi_def_cfa_register 28
 1798 001c 6397      		sbiw r28,19
 1799               	.LCFI59:
 1800               		.cfi_def_cfa_offset 33
 1801 001e 0FB6      		in __tmp_reg__,__SREG__
 1802 0020 F894      		cli
 1803 0022 DEBF      		out __SP_H__,r29
 1804 0024 0FBE      		out __SREG__,__tmp_reg__
 1805 0026 CDBF      		out __SP_L__,r28
 1806               	/* prologue: function */
 1807               	/* frame size = 19 */
 1808               	/* stack size = 31 */
 1809               	.L__stack_usage = 31
 1810 0028 8A82      		std Y+2,r8
 1811 002a 9B82      		std Y+3,r9
 1812 002c AC82      		std Y+4,r10
 1813 002e EB2D      		mov r30,r11
 1814 0030 BD82      		std Y+5,r11
 1815 0032 CE82      		std Y+6,r12
 1816 0034 DF82      		std Y+7,r13
 1817 0036 E886      		std Y+8,r14
 1818 0038 F986      		std Y+9,r15
 1819 003a 0A87      		std Y+10,r16
 1820 003c 1B87      		std Y+11,r17
 1821 003e 2C87      		std Y+12,r18
 1822 0040 3D87      		std Y+13,r19
 1823 0042 4E87      		std Y+14,r20
 1824 0044 5F87      		std Y+15,r21
 1825 0046 688B      		std Y+16,r22
 1826 0048 798B      		std Y+17,r23
 1827 004a 8A8B      		std Y+18,r24
 1828 004c 9B8B      		std Y+19,r25
 1829               	.LVL122:
 256:main.c        **** 
 257:main.c        **** 	uint16_t duration_high_1 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the duratio
 1830               		.loc 1 257 2 view .LVU418
 258:main.c        **** 	uint16_t duration_high_2 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the duratio
 1831               		.loc 1 258 2 view .LVU419
 259:main.c        **** 	uint16_t duration_high_3 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the duratio
 1832               		.loc 1 259 2 view .LVU420
 260:main.c        **** 
 261:main.c        **** 	uint8_t _cells = ( CellNum[high_1.cell_num] | CellNum[high_2.cell_num] | CellNum[high_3.cell_num])
 1833               		.loc 1 261 2 view .LVU421
 1834               		.loc 1 261 35 is_stmt 0 view .LVU422
 1835 004e F0E0      		ldi r31,0
 1836               		.loc 1 261 28 view .LVU423
 1837 0050 E050      		subi r30,lo8(-(CellNum))
 1838 0052 F040      		sbci r31,hi8(-(CellNum))
 1839 0054 8081      		ld r24,Z
 1840               		.loc 1 261 62 view .LVU424
 1841 0056 EDA1      		ldd r30,Y+37
 1842 0058 F0E0      		ldi r31,0
 1843               		.loc 1 261 55 view .LVU425
 1844 005a E050      		subi r30,lo8(-(CellNum))
 1845 005c F040      		sbci r31,hi8(-(CellNum))
 1846 005e 2081      		ld r18,Z
 1847               		.loc 1 261 89 view .LVU426
 1848 0060 EFA9      		ldd r30,Y+55
 1849 0062 F0E0      		ldi r31,0
 1850               		.loc 1 261 82 view .LVU427
 1851 0064 E050      		subi r30,lo8(-(CellNum))
 1852 0066 F040      		sbci r31,hi8(-(CellNum))
 1853 0068 9081      		ld r25,Z
 1854               		.loc 1 261 10 view .LVU428
 1855 006a 822B      		or r24,r18
 1856 006c 892B      		or r24,r25
 1857 006e 8983      		std Y+1,r24
 262:main.c        **** 	int8_t mob = CAN_findFreeTXMOB();
 1858               		.loc 1 262 2 is_stmt 1 view .LVU429
 1859               		.loc 1 262 15 is_stmt 0 view .LVU430
 1860 0070 0E94 0000 		call CAN_findFreeTXMOB
 1861               	.LVL123:
 263:main.c        **** 	CAN_TXMOB(mob, 1, &_cells, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|15, 0); //transmit cells 
 1862               		.loc 1 263 2 is_stmt 1 view .LVU431
 1863               		.loc 1 263 30 is_stmt 0 view .LVU432
 1864 0074 0091 0000 		lds r16,deviceID
 1865 0078 1091 0000 		lds r17,deviceID+1
 1866 007c 30E0      		ldi r19,0
 1867 007e 20E0      		ldi r18,0
 1868               		.loc 1 263 48 view .LVU433
 1869 0080 92E1      		ldi r25,18
 1870               		1:
 1871 0082 000F      		lsl r16
 1872 0084 111F      		rol r17
 1873 0086 221F      		rol r18
 1874 0088 331F      		rol r19
 1875 008a 9A95      		dec r25
 1876 008c 01F4      		brne 1b
 1877               		.loc 1 263 55 view .LVU434
 1878 008e 9091 0000 		lds r25,AMUID
 1879               		.loc 1 263 53 view .LVU435
 1880 0092 192B      		or r17,r25
 1881               		.loc 1 263 2 view .LVU436
 1882 0094 0F60      		ori r16,15
 1883 0096 E12C      		mov r14,__zero_reg__
 1884 0098 AE01      		movw r20,r28
 1885 009a 4F5F      		subi r20,-1
 1886 009c 5F4F      		sbci r21,-1
 1887 009e 61E0      		ldi r22,lo8(1)
 1888 00a0 0E94 0000 		call CAN_TXMOB
 1889               	.LVL124:
 1890               	/* epilogue start */
 264:main.c        **** 	
 265:main.c        **** 	
 266:main.c        **** 	/*for(uint16_t count = 0; count < duration_high_1; count++)
 267:main.c        **** 	{
 268:main.c        **** 		PORTB |= ((_cells&CELL7)>>7)|((_cells&CELL6)>>5)|((_cells&CELL5)>>2)|(_cells&CELL4);					//turn o
 269:main.c        **** 		PORTC |= (((_cells&CELL3)<<4)|((_cells&CELL0)<<1));														//turn on discharge for cells 3 
 270:main.c        **** 		PORTD |= ((_cells&CELL1)>>1|(_cells&CELL2)>>1);															//turn on discharge for cells 2 and
 271:main.c        **** 
 272:main.c        **** 		_delay_us(1);				//~50% duty cycle, ~2us pulse width.
 273:main.c        **** 
 274:main.c        **** 		PORTB &= ~(((_cells&CELL7)>>7)|((_cells&CELL6)>>5)|((_cells&CELL5)>>2)|(_cells&CELL4));					//tur
 275:main.c        **** 		PORTC &= ~(((_cells&CELL3)<<4)|((_cells&CELL0)<<1));
 276:main.c        **** 		PORTD &= ~(((_cells&CELL1)>>1|(_cells&CELL2)>>1));
 277:main.c        **** 
 278:main.c        **** 		if(count >= duration_high_3 && (_cells & CellNum[high_3.cell_num])) _cells &= ~(CellNum[high_3.ce
 279:main.c        **** 		if(count >= duration_high_2 && (_cells & CellNum[high_2.cell_num])) _cells &= ~(CellNum[high_2.ce
 280:main.c        **** 
 281:main.c        **** 	}*/
 282:main.c        **** }
 1891               		.loc 1 282 1 view .LVU437
 1892 00a4 6396      		adiw r28,19
 1893 00a6 0FB6      		in __tmp_reg__,__SREG__
 1894 00a8 F894      		cli
 1895 00aa DEBF      		out __SP_H__,r29
 1896 00ac 0FBE      		out __SREG__,__tmp_reg__
 1897 00ae CDBF      		out __SP_L__,r28
 1898 00b0 DF91      		pop r29
 1899 00b2 CF91      		pop r28
 1900 00b4 1F91      		pop r17
 1901 00b6 0F91      		pop r16
 1902 00b8 FF90      		pop r15
 1903 00ba EF90      		pop r14
 1904 00bc DF90      		pop r13
 1905 00be CF90      		pop r12
 1906 00c0 BF90      		pop r11
 1907 00c2 AF90      		pop r10
 1908 00c4 9F90      		pop r9
 1909 00c6 8F90      		pop r8
 1910 00c8 0895      		ret
 1911               		.cfi_endproc
 1912               	.LFE29:
 1914               		.section	.text.Balance_on,"ax",@progbits
 1915               	.global	Balance_on
 1917               	Balance_on:
 1918               	.LFB30:
 283:main.c        **** 
 284:main.c        **** void Balance_on()
 285:main.c        **** {
 1919               		.loc 1 285 1 is_stmt 1 view -0
 1920               		.cfi_startproc
 1921               	/* prologue: function */
 1922               	/* frame size = 0 */
 1923               	/* stack size = 0 */
 1924               	.L__stack_usage = 0
 286:main.c        **** 	TCCR0A = 0;
 1925               		.loc 1 286 2 view .LVU439
 1926               		.loc 1 286 9 is_stmt 0 view .LVU440
 1927 0000 14BC      		out 0x24,__zero_reg__
 287:main.c        **** 	TCCR0B = (1<<CS01);
 1928               		.loc 1 287 2 is_stmt 1 view .LVU441
 1929               		.loc 1 287 9 is_stmt 0 view .LVU442
 1930 0002 82E0      		ldi r24,lo8(2)
 1931 0004 85BD      		out 0x25,r24
 288:main.c        **** 	//TCNT0 = 0;
 289:main.c        **** 	OCR0A = 200;
 1932               		.loc 1 289 2 is_stmt 1 view .LVU443
 1933               		.loc 1 289 8 is_stmt 0 view .LVU444
 1934 0006 98EC      		ldi r25,lo8(-56)
 1935 0008 97BD      		out 0x27,r25
 290:main.c        **** 	TIMSK0 = (1<<OCIE0A);
 1936               		.loc 1 290 2 is_stmt 1 view .LVU445
 1937               		.loc 1 290 9 is_stmt 0 view .LVU446
 1938 000a 8093 6E00 		sts 110,r24
 1939               	/* epilogue start */
 291:main.c        **** 	
 292:main.c        **** }
 1940               		.loc 1 292 1 view .LVU447
 1941 000e 0895      		ret
 1942               		.cfi_endproc
 1943               	.LFE30:
 1945               		.section	.text.Balance_off,"ax",@progbits
 1946               	.global	Balance_off
 1948               	Balance_off:
 1949               	.LFB31:
 293:main.c        **** 
 294:main.c        **** void Balance_off()
 295:main.c        **** {
 1950               		.loc 1 295 1 is_stmt 1 view -0
 1951               		.cfi_startproc
 1952               	/* prologue: function */
 1953               	/* frame size = 0 */
 1954               	/* stack size = 0 */
 1955               	.L__stack_usage = 0
 296:main.c        **** 	//TCCR0B = 0;
 297:main.c        **** 	TIMSK0 = 0;
 1956               		.loc 1 297 2 view .LVU449
 1957               		.loc 1 297 9 is_stmt 0 view .LVU450
 1958 0000 1092 6E00 		sts 110,__zero_reg__
 298:main.c        **** 	PORTB &= ~((CELL2>>2)|(CELL3>>2)|(CELL5>>2)|(CELL6>>2)); //turn off discharge for cells 7..4, if t
 1959               		.loc 1 298 2 is_stmt 1 view .LVU451
 1960               		.loc 1 298 8 is_stmt 0 view .LVU452
 1961 0004 85B1      		in r24,0x5
 1962 0006 847E      		andi r24,lo8(-28)
 1963 0008 85B9      		out 0x5,r24
 299:main.c        **** 	PORTC &= ~((CELL1)|(CELL7)); //turn off discharge for cells 3 and 0, if their corresponding bits a
 1964               		.loc 1 299 2 is_stmt 1 view .LVU453
 1965               		.loc 1 299 8 is_stmt 0 view .LVU454
 1966 000a 88B1      		in r24,0x8
 1967 000c 8D77      		andi r24,lo8(125)
 1968 000e 88B9      		out 0x8,r24
 300:main.c        **** 	PORTD &= ~((CELL0<<1)|(CELL4<<3)); //turn off discharge for cells 2 and 1, if their corresponding 
 1969               		.loc 1 300 2 is_stmt 1 view .LVU455
 1970               		.loc 1 300 8 is_stmt 0 view .LVU456
 1971 0010 8BB1      		in r24,0xb
 1972 0012 8D77      		andi r24,lo8(125)
 1973 0014 8BB9      		out 0xb,r24
 301:main.c        **** 	LED_off();
 1974               		.loc 1 301 2 is_stmt 1 view .LVU457
 1975 0016 0C94 0000 		jmp LED_off
 1976               	.LVL125:
 1977               		.cfi_endproc
 1978               	.LFE31:
 1980               		.section	.text.Balance_init,"ax",@progbits
 1981               	.global	Balance_init
 1983               	Balance_init:
 1984               	.LVL126:
 1985               	.LFB32:
 302:main.c        **** }
 303:main.c        **** void Balance_init(cell * _cells)
 304:main.c        **** {
 1986               		.loc 1 304 1 view -0
 1987               		.cfi_startproc
 1988               		.loc 1 304 1 is_stmt 0 view .LVU459
 1989 0000 0F93      		push r16
 1990               	.LCFI60:
 1991               		.cfi_def_cfa_offset 3
 1992               		.cfi_offset 16, -2
 1993 0002 1F93      		push r17
 1994               	.LCFI61:
 1995               		.cfi_def_cfa_offset 4
 1996               		.cfi_offset 17, -3
 1997 0004 CF93      		push r28
 1998               	.LCFI62:
 1999               		.cfi_def_cfa_offset 5
 2000               		.cfi_offset 28, -4
 2001 0006 DF93      		push r29
 2002               	.LCFI63:
 2003               		.cfi_def_cfa_offset 6
 2004               		.cfi_offset 29, -5
 2005               	/* prologue: function */
 2006               	/* frame size = 0 */
 2007               	/* stack size = 4 */
 2008               	.L__stack_usage = 4
 305:main.c        **** 	//this function finds the cells with the top 3 voltage levels, and the cell with the lowest voltag
 306:main.c        **** 	cell * t_cells = _cells;
 2009               		.loc 1 306 2 is_stmt 1 view .LVU460
 2010               	.LVL127:
 307:main.c        **** 
 308:main.c        **** 	//Analyse cell data in this section
 309:main.c        **** 	cell lowest = *_cells;				//assign an arbitrary cell to the lowest, for comparison
 2011               		.loc 1 309 2 view .LVU461
 2012               		.loc 1 309 7 is_stmt 0 view .LVU462
 2013 0008 EC01      		movw r28,r24
 2014 000a 2E81      		ldd r18,Y+6
 2015 000c 3F81      		ldd r19,Y+7
 2016               	.LVL128:
 310:main.c        **** 	cell high_1 = *_cells;				//assign an arbitrary cell to the highest, for comparison.
 2017               		.loc 1 310 2 is_stmt 1 view .LVU463
 311:main.c        **** 
 312:main.c        **** 	uint8_t iscan = 0;
 2018               		.loc 1 312 2 view .LVU464
 313:main.c        **** 	for(iscan = 0; iscan <= 7; iscan++ )	//Analyse cell values 1st run, checking for invalid values an
 2019               		.loc 1 313 2 view .LVU465
 314:main.c        **** 	{
 315:main.c        **** 		t_cells = _cells+iscan;
 316:main.c        **** 		if (t_cells->voltage >= CELL_V_ERR_MAX || t_cells->voltage <= CELL_V_ERR_MIN) return;	//if any ce
 2020               		.loc 1 316 24 is_stmt 0 view .LVU466
 2021 000e C091 0000 		lds r28,CELL_V_ERR_MAX
 2022 0012 D091 0000 		lds r29,CELL_V_ERR_MAX+1
 2023               		.loc 1 316 62 view .LVU467
 2024 0016 0091 0000 		lds r16,CELL_V_ERR_MIN
 2025 001a 1091 0000 		lds r17,CELL_V_ERR_MIN+1
 2026 001e FC01      		movw r30,r24
 2027 0020 AC01      		movw r20,r24
 2028 0022 4057      		subi r20,112
 2029 0024 5F4F      		sbci r21,-1
 2030 0026 DC01      		movw r26,r24
 2031               	.LVL129:
 2032               	.L62:
 315:main.c        **** 		if (t_cells->voltage >= CELL_V_ERR_MAX || t_cells->voltage <= CELL_V_ERR_MIN) return;	//if any ce
 2033               		.loc 1 315 3 is_stmt 1 view .LVU468
 2034               		.loc 1 316 3 view .LVU469
 2035               		.loc 1 316 14 is_stmt 0 view .LVU470
 2036 0028 1696      		adiw r26,6
 2037 002a 6D91      		ld r22,X+
 2038 002c 7C91      		ld r23,X
 2039 002e 1797      		sbiw r26,6+1
 2040               		.loc 1 316 6 view .LVU471
 2041 0030 6C17      		cp r22,r28
 2042 0032 7D07      		cpc r23,r29
 2043 0034 00F4      		brsh .L59
 2044               		.loc 1 316 42 discriminator 2 view .LVU472
 2045 0036 0617      		cp r16,r22
 2046 0038 1707      		cpc r17,r23
 2047 003a 00F4      		brsh .L59
 317:main.c        **** 		if (t_cells->voltage <= lowest.voltage)lowest	= *t_cells;				//find the cell with lowest voltage
 2048               		.loc 1 317 3 is_stmt 1 view .LVU473
 2049 003c 6217      		cp r22,r18
 2050 003e 7307      		cpc r23,r19
 2051 0040 00F4      		brsh .L61
 2052 0042 9B01      		movw r18,r22
 2053               	.LVL130:
 2054               	.L61:
 318:main.c        **** 		if (t_cells->voltage > high_1.voltage)high_1	= *t_cells;				//find the cell with highest voltage
 2055               		.loc 1 318 3 view .LVU474
 2056               		.loc 1 318 3 is_stmt 0 view .LVU475
 2057 0044 5296      		adiw r26,18
 2058               	.LVL131:
 313:main.c        **** 	{
 2059               		.loc 1 313 2 view .LVU476
 2060 0046 A417      		cp r26,r20
 2061 0048 B507      		cpc r27,r21
 2062 004a 01F4      		brne .L62
 319:main.c        **** 	}
 320:main.c        **** 	cell high_2 = lowest;			//assign lowest cell to the second highest.
 321:main.c        **** 	cell high_3 = lowest;			//and again assign lowest cell to the third highest.
 322:main.c        **** 
 323:main.c        **** 	for(iscan = 0; iscan <= 7; iscan++)		//analyse cell values 2nd run, checking for large differences
 324:main.c        **** 	{
 325:main.c        **** 		t_cells = _cells+iscan;
 326:main.c        **** 		if (t_cells->voltage > lowest.voltage+CELL_V_DIFF_MAX_THRESHOLD || t_cells->voltage < lowest.volt
 2063               		.loc 1 326 40 view .LVU477
 2064 004c 6091 0000 		lds r22,CELL_V_DIFF_MAX_THRESHOLD
 2065 0050 7091 0000 		lds r23,CELL_V_DIFF_MAX_THRESHOLD+1
 2066 0054 DB01      		movw r26,r22
 2067               	.LVL132:
 2068               		.loc 1 326 40 view .LVU478
 2069 0056 A20F      		add r26,r18
 2070 0058 B31F      		adc r27,r19
 2071               		.loc 1 326 103 view .LVU479
 2072 005a 261B      		sub r18,r22
 2073 005c 370B      		sbc r19,r23
 2074               	.LVL133:
 2075               	.L63:
 325:main.c        **** 		if (t_cells->voltage > lowest.voltage+CELL_V_DIFF_MAX_THRESHOLD || t_cells->voltage < lowest.volt
 2076               		.loc 1 325 3 is_stmt 1 view .LVU480
 2077               		.loc 1 326 3 view .LVU481
 2078               		.loc 1 326 14 is_stmt 0 view .LVU482
 2079 005e EC01      		movw r28,r24
 2080 0060 6E81      		ldd r22,Y+6
 2081 0062 7F81      		ldd r23,Y+7
 2082               		.loc 1 326 6 view .LVU483
 2083 0064 A617      		cp r26,r22
 2084 0066 B707      		cpc r27,r23
 2085 0068 00F0      		brlo .L59
 2086               		.loc 1 326 67 discriminator 2 view .LVU484
 2087 006a 6217      		cp r22,r18
 2088 006c 7307      		cpc r23,r19
 2089 006e 00F0      		brlo .L59
 327:main.c        **** 		if (t_cells->voltage >= high_2.voltage && t_cells->cell_num != high_1.cell_num )high_2 = *t_cells
 2090               		.loc 1 327 3 is_stmt 1 discriminator 2 view .LVU485
 2091               		.loc 1 327 3 is_stmt 0 discriminator 2 view .LVU486
 2092 0070 4296      		adiw r24,18
 2093               	.LVL134:
 323:main.c        **** 	{
 2094               		.loc 1 323 2 discriminator 2 view .LVU487
 2095 0072 8417      		cp r24,r20
 2096 0074 9507      		cpc r25,r21
 2097 0076 01F4      		brne .L63
 2098               	.LVL135:
 2099               	.L65:
 2100               	.LBB72:
 2101               	.LBB73:
 328:main.c        **** 	}
 329:main.c        **** 	for(iscan = 0; iscan <= 7; iscan++)		//3rd run, assign third highest cell value
 330:main.c        **** 	{
 331:main.c        **** 		t_cells = _cells+iscan;
 332:main.c        **** 		if (t_cells->voltage >= high_3.voltage && t_cells->cell_num != high_1.cell_num && t_cells->cell_n
 333:main.c        **** 	}
 334:main.c        **** 	//IGNORE THE PREVIOUS PART OF THIS FUNCTION
 335:main.c        **** 	//THIS IS THE LATEST PART OF THE algorithm... is that how you spell algorithm?
 336:main.c        **** 	for(iscan = 0; iscan <= 7; iscan++)
 337:main.c        **** 	{
 338:main.c        **** 		t_cells = _cells+iscan;
 2102               		.loc 1 338 3 is_stmt 1 view .LVU488
 339:main.c        **** 		if(t_cells->voltage > BALANCE_TARGET_VOLTAGE)_cellsToBalance |= CellNum[t_cells->cell_num];
 2103               		.loc 1 339 3 view .LVU489
 2104               		.loc 1 339 5 is_stmt 0 view .LVU490
 2105 0078 2681      		ldd r18,Z+6
 2106 007a 3781      		ldd r19,Z+7
 2107 007c 8091 0000 		lds r24,BALANCE_TARGET_VOLTAGE
 2108 0080 9091 0000 		lds r25,BALANCE_TARGET_VOLTAGE+1
 2109 0084 8217      		cp r24,r18
 2110 0086 9307      		cpc r25,r19
 2111 0088 00F4      		brsh .L64
 2112               		.loc 1 339 48 is_stmt 1 view .LVU491
 2113               		.loc 1 339 82 is_stmt 0 view .LVU492
 2114 008a A381      		ldd r26,Z+3
 2115 008c B0E0      		ldi r27,0
 2116               		.loc 1 339 74 view .LVU493
 2117 008e A050      		subi r26,lo8(-(CellNum))
 2118 0090 B040      		sbci r27,hi8(-(CellNum))
 2119 0092 8C91      		ld r24,X
 2120               		.loc 1 339 64 view .LVU494
 2121 0094 9EB3      		in r25,0x1e
 2122 0096 892B      		or r24,r25
 2123 0098 8EBB      		out 0x1e,r24
 2124               	.L64:
 2125               	.LVL136:
 2126               		.loc 1 339 64 view .LVU495
 2127 009a 7296      		adiw r30,18
 2128               	.LVL137:
 336:main.c        **** 	{
 2129               		.loc 1 336 2 view .LVU496
 2130 009c E417      		cp r30,r20
 2131 009e F507      		cpc r31,r21
 2132 00a0 01F4      		brne .L65
 2133               	.LVL138:
 2134               	.L59:
 2135               	/* epilogue start */
 336:main.c        **** 	{
 2136               		.loc 1 336 2 view .LVU497
 2137               	.LBE73:
 2138               	.LBE72:
 340:main.c        **** 	}
 341:main.c        **** 
 342:main.c        **** 	//Discharge_cells( high_1, high_2, high_3, lowest);			//now discharge the top three cells, to bala
 343:main.c        **** 	//uint16_t duration_high_1 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the durat
 344:main.c        **** 	//uint16_t duration_high_2 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the durat
 345:main.c        **** 	//uint16_t duration_high_3 = (high_1.voltage - lowest.voltage)*DISCHARGE_SCALE;			//sets the durat
 346:main.c        **** 	
 347:main.c        **** 	//OLD_cellsToBalance = ( CellNum[high_1.cell_num] | CellNum[high_2.cell_num] | CellNum[high_3.cell
 348:main.c        **** 	//OLD DEBUGGING_cellsToBalance = 0xff;
 349:main.c        **** 	//OLDint8_t mob = CAN_findFreeTXMOB();
 350:main.c        **** 	//OLD CAUSING POTENTIAL BROADCAST STORMS... CAN_TXMOB(mob, 1, &_cellsToBalance, ((uint32_t)deviceI
 351:main.c        **** 
 352:main.c        **** 
 353:main.c        **** }
 2139               		.loc 1 353 1 view .LVU498
 2140 00a2 DF91      		pop r29
 2141 00a4 CF91      		pop r28
 2142 00a6 1F91      		pop r17
 2143 00a8 0F91      		pop r16
 2144 00aa 0895      		ret
 2145               		.cfi_endproc
 2146               	.LFE32:
 2148               		.section	.text.Wake_Next_CMU,"ax",@progbits
 2149               	.global	Wake_Next_CMU
 2151               	Wake_Next_CMU:
 2152               	.LFB33:
 354:main.c        **** 
 355:main.c        **** void Wake_Next_CMU()
 356:main.c        **** {
 2153               		.loc 1 356 1 is_stmt 1 view -0
 2154               		.cfi_startproc
 2155               	/* prologue: function */
 2156               	/* frame size = 0 */
 2157               	/* stack size = 0 */
 2158               	.L__stack_usage = 0
 357:main.c        **** 
 358:main.c        **** 	PORTD |= (1<<PIND0);		//send wake out, halfway through sending our data back to the AMU.
 2159               		.loc 1 358 2 view .LVU500
 2160               		.loc 1 358 8 is_stmt 0 view .LVU501
 2161 0000 589A      		sbi 0xb,0
 359:main.c        **** 	LED_flash(10);
 2162               		.loc 1 359 2 is_stmt 1 view .LVU502
 2163 0002 8AE0      		ldi r24,lo8(10)
 2164 0004 0E94 0000 		call LED_flash
 2165               	.LVL139:
 360:main.c        **** 	PORTD &= ~(1<<PIND0);
 2166               		.loc 1 360 2 view .LVU503
 2167               		.loc 1 360 8 is_stmt 0 view .LVU504
 2168 0008 5898      		cbi 0xb,0
 2169               	/* epilogue start */
 361:main.c        **** 
 362:main.c        **** }
 2170               		.loc 1 362 1 view .LVU505
 2171 000a 0895      		ret
 2172               		.cfi_endproc
 2173               	.LFE33:
 2175               		.section	.text.Wake_Set,"ax",@progbits
 2176               	.global	Wake_Set
 2178               	Wake_Set:
 2179               	.LFB34:
 363:main.c        **** void Wake_Set()
 364:main.c        **** {
 2180               		.loc 1 364 1 is_stmt 1 view -0
 2181               		.cfi_startproc
 2182               	/* prologue: function */
 2183               	/* frame size = 0 */
 2184               	/* stack size = 0 */
 2185               	.L__stack_usage = 0
 365:main.c        **** 	PORTD |= (1<<PIND0);		//turn wake pin on, to wake up the next CMU
 2186               		.loc 1 365 2 view .LVU507
 2187               		.loc 1 365 8 is_stmt 0 view .LVU508
 2188 0000 589A      		sbi 0xb,0
 2189               	/* epilogue start */
 366:main.c        **** }
 2190               		.loc 1 366 1 view .LVU509
 2191 0002 0895      		ret
 2192               		.cfi_endproc
 2193               	.LFE34:
 2195               		.section	.text.Wake_Unset,"ax",@progbits
 2196               	.global	Wake_Unset
 2198               	Wake_Unset:
 2199               	.LFB35:
 367:main.c        **** void Wake_Unset()
 368:main.c        **** {
 2200               		.loc 1 368 1 is_stmt 1 view -0
 2201               		.cfi_startproc
 2202               	/* prologue: function */
 2203               	/* frame size = 0 */
 2204               	/* stack size = 0 */
 2205               	.L__stack_usage = 0
 369:main.c        **** 	PORTD &= ~(1<<PIND0);		//turn wake off. our job is done.
 2206               		.loc 1 369 2 view .LVU511
 2207               		.loc 1 369 8 is_stmt 0 view .LVU512
 2208 0000 5898      		cbi 0xb,0
 2209               	/* epilogue start */
 370:main.c        **** }
 2210               		.loc 1 370 1 view .LVU513
 2211 0002 0895      		ret
 2212               		.cfi_endproc
 2213               	.LFE35:
 2215               		.section	.text.INT3_init,"ax",@progbits
 2216               	.global	INT3_init
 2218               	INT3_init:
 2219               	.LFB36:
 371:main.c        **** void INT3_init()	//pinc0
 372:main.c        **** {
 2220               		.loc 1 372 1 is_stmt 1 view -0
 2221               		.cfi_startproc
 2222               	/* prologue: function */
 2223               	/* frame size = 0 */
 2224               	/* stack size = 0 */
 2225               	.L__stack_usage = 0
 373:main.c        **** 	cli();		//disable global interrupt
 2226               		.loc 1 373 2 view .LVU515
 2227               	/* #APP */
 2228               	 ;  373 "main.c" 1
 2229 0000 F894      		cli
 2230               	 ;  0 "" 2
 374:main.c        **** 	EICRA = (1<<ISC31)|(1<<ISC30);	//0b11000000	//to enable rising edge of INT3 on PINC0 to cause an e
 2231               		.loc 1 374 2 view .LVU516
 2232               		.loc 1 374 8 is_stmt 0 view .LVU517
 2233               	/* #NOAPP */
 2234 0002 80EC      		ldi r24,lo8(-64)
 2235 0004 8093 6900 		sts 105,r24
 375:main.c        **** 	EIMSK = (1<<INT3);				//this may not be legal, the data sheet said it was read only, otherwise it 
 2236               		.loc 1 375 2 is_stmt 1 view .LVU518
 2237               		.loc 1 375 8 is_stmt 0 view .LVU519
 2238 0008 88E0      		ldi r24,lo8(8)
 2239 000a 8DBB      		out 0x1d,r24
 376:main.c        **** 	//EIFR bits INTF3..0 hold information on whether the interrupt has occurred.
 377:main.c        **** 	//PCICR is useful when using the level change is being used to indicate the interrupt. hi-low or l
 378:main.c        **** 	sei();		//re-enable global interrupt.
 2240               		.loc 1 378 2 is_stmt 1 view .LVU520
 2241               	/* #APP */
 2242               	 ;  378 "main.c" 1
 2243 000c 7894      		sei
 2244               	 ;  0 "" 2
 2245               	/* #NOAPP */
 2246               	/* epilogue start */
 379:main.c        **** 
 380:main.c        **** }
 2247               		.loc 1 380 1 is_stmt 0 view .LVU521
 2248 000e 0895      		ret
 2249               		.cfi_endproc
 2250               	.LFE36:
 2252               		.section	.text.PowerDown,"ax",@progbits
 2253               	.global	PowerDown
 2255               	PowerDown:
 2256               	.LFB37:
 381:main.c        **** 
 382:main.c        **** void PowerDown()
 383:main.c        **** {
 2257               		.loc 1 383 1 is_stmt 1 view -0
 2258               		.cfi_startproc
 2259               	/* prologue: function */
 2260               	/* frame size = 0 */
 2261               	/* stack size = 0 */
 2262               	.L__stack_usage = 0
 384:main.c        **** 
 385:main.c        **** 	//SMCR = (1<<SM1)|(1<<SE);	//0b00000101	//power down mode //also known as SLEEP_MODE_PWR_DOWN. Thi
 386:main.c        **** 	set_sleep_mode(SLEEP_MODE_PWR_DOWN);		//power down shuts the main clock down.
 2263               		.loc 1 386 2 view .LVU523
 2264               		.loc 1 386 2 view .LVU524
 2265 0000 83B7      		in r24,0x33
 2266 0002 817F      		andi r24,lo8(-15)
 2267 0004 8460      		ori r24,lo8(4)
 2268 0006 83BF      		out 0x33,r24
 387:main.c        **** 	sleep_enable();
 2269               		.loc 1 387 2 view .LVU525
 2270               		.loc 1 387 2 view .LVU526
 2271 0008 83B7      		in r24,0x33
 2272 000a 8160      		ori r24,lo8(1)
 2273 000c 83BF      		out 0x33,r24
 388:main.c        **** 	sleep_cpu();				//enter the sleep state.
 2274               		.loc 1 388 2 view .LVU527
 2275               		.loc 1 388 2 view .LVU528
 2276               	/* #APP */
 2277               	 ;  388 "main.c" 1
 2278 000e 8895      		sleep
 2279               		
 2280               	 ;  0 "" 2
 2281               	/* #NOAPP */
 2282               	/* epilogue start */
 389:main.c        **** 
 390:main.c        **** }
 2283               		.loc 1 390 1 is_stmt 0 view .LVU529
 2284 0010 0895      		ret
 2285               		.cfi_endproc
 2286               	.LFE37:
 2288               		.section	.text.startup.main,"ax",@progbits
 2289               	.global	main
 2291               	main:
 2292               	.LFB38:
 391:main.c        **** 
 392:main.c        **** int main(void)
 393:main.c        **** {
 2293               		.loc 1 393 1 is_stmt 1 view -0
 2294               		.cfi_startproc
 2295 0000 CDB7      		in r28,__SP_L__
 2296 0002 DEB7      		in r29,__SP_H__
 2297               	.LCFI64:
 2298               		.cfi_def_cfa_register 28
 2299 0004 C059      		subi r28,-112
 2300 0006 D109      		sbc r29,__zero_reg__
 2301               	.LCFI65:
 2302               		.cfi_def_cfa_offset 146
 2303 0008 0FB6      		in __tmp_reg__,__SREG__
 2304 000a F894      		cli
 2305 000c DEBF      		out __SP_H__,r29
 2306 000e 0FBE      		out __SREG__,__tmp_reg__
 2307 0010 CDBF      		out __SP_L__,r28
 2308               	/* prologue: function */
 2309               	/* frame size = 144 */
 2310               	/* stack size = 144 */
 2311               	.L__stack_usage = 144
 394:main.c        **** 	_delay_ms(10);
 2312               		.loc 1 394 2 view .LVU531
 2313               	.LVL140:
 2314               	.LBB74:
 2315               	.LBI74:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2316               		.loc 2 166 1 view .LVU532
 2317               	.LBB75:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2318               		.loc 2 168 2 view .LVU533
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2319               		.loc 2 172 2 view .LVU534
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2320               		.loc 2 173 2 view .LVU535
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2321               		.loc 2 174 2 view .LVU536
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2322               		.loc 2 184 3 view .LVU537
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2323               		.loc 2 187 2 view .LVU538
 2324 0012 8FE3      		ldi r24,lo8(-25537)
 2325 0014 9CE9      		ldi r25,hi8(-25537)
 2326 0016 0197      	1:	sbiw r24,1
 2327 0018 01F4      		brne 1b
 2328 001a 00C0      		rjmp .
 2329 001c 0000      		nop
 2330               	.LVL141:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2331               		.loc 2 187 2 is_stmt 0 view .LVU539
 2332               	.LBE75:
 2333               	.LBE74:
 395:main.c        **** 	
 396:main.c        **** 	
 397:main.c        **** 	CMU_eeprom_write(EEPROM_DEVICE_ID, 6);
 2334               		.loc 1 397 2 is_stmt 1 view .LVU540
 2335 001e 66E0      		ldi r22,lo8(6)
 2336 0020 70E0      		ldi r23,0
 2337 0022 90E0      		ldi r25,0
 2338 0024 80E0      		ldi r24,0
 2339 0026 0E94 0000 		call CMU_eeprom_write
 2340               	.LVL142:
 398:main.c        **** 	CMU_eeprom_write(EEPROM_ADC_SAMPLES, 3);
 2341               		.loc 1 398 2 view .LVU541
 2342 002a 63E0      		ldi r22,lo8(3)
 2343 002c 70E0      		ldi r23,0
 2344 002e 82E0      		ldi r24,lo8(2)
 2345 0030 90E0      		ldi r25,0
 2346 0032 0E94 0000 		call CMU_eeprom_write
 2347               	.LVL143:
 399:main.c        **** 	CMU_eeprom_write(EEPROM_FW_VERSION, 1003);
 2348               		.loc 1 399 2 view .LVU542
 2349 0036 6BEE      		ldi r22,lo8(-21)
 2350 0038 73E0      		ldi r23,lo8(3)
 2351 003a 84E0      		ldi r24,lo8(4)
 2352 003c 90E0      		ldi r25,0
 2353 003e 0E94 0000 		call CMU_eeprom_write
 2354               	.LVL144:
 400:main.c        **** 	CMU_eeprom_write(EEPROM_CELL_V_DIFF_MAX_THRESHOLD, 500);
 2355               		.loc 1 400 2 view .LVU543
 2356 0042 64EF      		ldi r22,lo8(-12)
 2357 0044 71E0      		ldi r23,lo8(1)
 2358 0046 80E4      		ldi r24,lo8(64)
 2359 0048 90E0      		ldi r25,0
 2360 004a 0E94 0000 		call CMU_eeprom_write
 2361               	.LVL145:
 401:main.c        **** 	CMU_eeprom_write(EEPROM_CELL_V_DIFF_MIN_THRESHOLD, 500);
 2362               		.loc 1 401 2 view .LVU544
 2363 004e 64EF      		ldi r22,lo8(-12)
 2364 0050 71E0      		ldi r23,lo8(1)
 2365 0052 82E4      		ldi r24,lo8(66)
 2366 0054 90E0      		ldi r25,0
 2367 0056 0E94 0000 		call CMU_eeprom_write
 2368               	.LVL146:
 402:main.c        **** 	CMU_eeprom_write(EEPROM_DISCHARGE_SCALE, 200);
 2369               		.loc 1 402 2 view .LVU545
 2370 005a 68EC      		ldi r22,lo8(-56)
 2371 005c 70E0      		ldi r23,0
 2372 005e 88E4      		ldi r24,lo8(72)
 2373 0060 90E0      		ldi r25,0
 2374 0062 0E94 0000 		call CMU_eeprom_write
 2375               	.LVL147:
 403:main.c        **** 	
 404:main.c        **** 	EEPROMWriteComplete = 0;
 2376               		.loc 1 404 2 view .LVU546
 2377               		.loc 1 404 22 is_stmt 0 view .LVU547
 2378 0066 1092 0000 		sts EEPROMWriteComplete,__zero_reg__
 405:main.c        **** 	
 406:main.c        **** 	IO_init();		//initialise IO and INT3 for waking up from power down mode
 2379               		.loc 1 406 2 is_stmt 1 view .LVU548
 2380 006a 0E94 0000 		call IO_init
 2381               	.LVL148:
 407:main.c        **** 	//Wake_Set();
 408:main.c        **** 	ADC_init();		//initialises ADC
 2382               		.loc 1 408 2 view .LVU549
 2383 006e 0E94 0000 		call ADC_init
 2384               	.LVL149:
 409:main.c        **** 	CAN_init();		//initialises CAN, without enabling any receive MOBs
 2385               		.loc 1 409 2 view .LVU550
 2386 0072 0E94 0000 		call CAN_init
 2387               	.LVL150:
 410:main.c        **** 	CAN_RXInit(4, 0, 0, 0);	//set mob up for listening to audit requests
 2388               		.loc 1 410 2 view .LVU551
 2389 0076 E12C      		mov r14,__zero_reg__
 2390 0078 F12C      		mov r15,__zero_reg__
 2391 007a 8701      		movw r16,r14
 2392 007c 20E0      		ldi r18,0
 2393 007e 30E0      		ldi r19,0
 2394 0080 A901      		movw r20,r18
 2395 0082 60E0      		ldi r22,0
 2396 0084 84E0      		ldi r24,lo8(4)
 2397 0086 0E94 0000 		call CAN_RXInit
 2398               	.LVL151:
 411:main.c        **** 	
 412:main.c        **** 	//srand(ADC_read(0));
 413:main.c        **** 	Parameters_init();	//disable this until we have the parameters on the eeprom
 2399               		.loc 1 413 2 view .LVU552
 2400 008a 0E94 0000 		call Parameters_init
 2401               	.LVL152:
 414:main.c        **** 	PowerDown();		//shutdown until woken for the first time
 2402               		.loc 1 414 2 view .LVU553
 2403 008e 0E94 0000 		call PowerDown
 2404               	.LVL153:
 415:main.c        **** 	_delay_ms(200);	//await registration messages which will be automatically handled in interrupts
 2405               		.loc 1 415 2 view .LVU554
 2406               	.LBB76:
 2407               	.LBI76:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2408               		.loc 2 166 1 view .LVU555
 2409               	.LBB77:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2410               		.loc 2 168 2 view .LVU556
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2411               		.loc 2 172 2 view .LVU557
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2412               		.loc 2 173 2 view .LVU558
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2413               		.loc 2 174 2 view .LVU559
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2414               		.loc 2 184 3 view .LVU560
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2415               		.loc 2 187 2 view .LVU561
 2416 0092 9FEF      		ldi r25,lo8(639999)
 2417 0094 23EC      		ldi r18,hi8(639999)
 2418 0096 89E0      		ldi r24,hlo8(639999)
 2419 0098 9150      	1:	subi r25,1
 2420 009a 2040      		sbci r18,0
 2421 009c 8040      		sbci r24,0
 2422 009e 01F4      		brne 1b
 2423 00a0 00C0      		rjmp .
 2424 00a2 0000      		nop
 2425               	.LVL154:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2426               		.loc 2 187 2 is_stmt 0 view .LVU562
 2427               	.LBE77:
 2428               	.LBE76:
 416:main.c        **** 	
 417:main.c        **** 	if(!registered)_delay_ms(800);
 2429               		.loc 1 417 2 is_stmt 1 view .LVU563
 2430               		.loc 1 417 4 is_stmt 0 view .LVU564
 2431 00a4 8091 0000 		lds r24,registered
 2432 00a8 8111      		cpse r24,__zero_reg__
 2433 00aa 00C0      		rjmp .L75
 2434               		.loc 1 417 17 is_stmt 1 view .LVU565
 2435               	.LVL155:
 2436               	.LBB78:
 2437               	.LBI78:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2438               		.loc 2 166 1 view .LVU566
 2439               	.LBB79:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2440               		.loc 2 168 2 view .LVU567
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2441               		.loc 2 172 2 view .LVU568
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2442               		.loc 2 173 2 view .LVU569
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2443               		.loc 2 174 2 view .LVU570
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2444               		.loc 2 184 3 view .LVU571
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2445               		.loc 2 187 2 view .LVU572
 2446 00ac 9FEF      		ldi r25,lo8(2559999)
 2447 00ae 2FE0      		ldi r18,hi8(2559999)
 2448 00b0 87E2      		ldi r24,hlo8(2559999)
 2449 00b2 9150      	1:	subi r25,1
 2450 00b4 2040      		sbci r18,0
 2451 00b6 8040      		sbci r24,0
 2452 00b8 01F4      		brne 1b
 2453 00ba 00C0      		rjmp .
 2454 00bc 0000      		nop
 2455               	.LVL156:
 2456               	.L75:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2457               		.loc 2 187 2 is_stmt 0 view .LVU573
 2458               	.LBE79:
 2459               	.LBE78:
 418:main.c        **** 	if (WAKE_IN_PIN && !registered) //if the wake in pin is still high and we aren't registered, there
 2460               		.loc 1 418 2 is_stmt 1 view .LVU574
 2461               		.loc 1 418 5 is_stmt 0 view .LVU575
 2462 00be 309B      		sbis 0x6,0
 2463 00c0 00C0      		rjmp .L76
 2464               		.loc 1 418 18 discriminator 1 view .LVU576
 2465 00c2 8091 0000 		lds r24,registered
 2466 00c6 8111      		cpse r24,__zero_reg__
 2467 00c8 00C0      		rjmp .L76
 2468               	.L77:
 419:main.c        **** 	{
 420:main.c        **** 		while(1)					//loop endlessly
 2469               		.loc 1 420 3 is_stmt 1 discriminator 1 view .LVU577
 421:main.c        **** 		{
 422:main.c        **** 			LED_flash(50);			//flashing LED 3 times
 2470               		.loc 1 422 4 discriminator 1 view .LVU578
 2471 00ca 82E3      		ldi r24,lo8(50)
 2472 00cc 0E94 0000 		call LED_flash
 2473               	.LVL157:
 423:main.c        **** 			LED_flash(50);
 2474               		.loc 1 423 4 discriminator 1 view .LVU579
 2475 00d0 82E3      		ldi r24,lo8(50)
 2476 00d2 0E94 0000 		call LED_flash
 2477               	.LVL158:
 424:main.c        **** 			LED_flash(50);
 2478               		.loc 1 424 4 discriminator 1 view .LVU580
 2479 00d6 82E3      		ldi r24,lo8(50)
 2480 00d8 0E94 0000 		call LED_flash
 2481               	.LVL159:
 425:main.c        **** 			_delay_ms(2000);		//every two seconds.
 2482               		.loc 1 425 4 discriminator 1 view .LVU581
 2483               	.LBB80:
 2484               	.LBI80:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2485               		.loc 2 166 1 discriminator 1 view .LVU582
 2486               	.LBB81:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2487               		.loc 2 168 2 discriminator 1 view .LVU583
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2488               		.loc 2 172 2 discriminator 1 view .LVU584
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2489               		.loc 2 173 2 discriminator 1 view .LVU585
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2490               		.loc 2 174 2 discriminator 1 view .LVU586
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2491               		.loc 2 184 3 discriminator 1 view .LVU587
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2492               		.loc 2 187 2 discriminator 1 view .LVU588
 2493 00dc 9FEF      		ldi r25,lo8(6399999)
 2494 00de 27EA      		ldi r18,hi8(6399999)
 2495 00e0 81E6      		ldi r24,hlo8(6399999)
 2496 00e2 9150      	1:	subi r25,1
 2497 00e4 2040      		sbci r18,0
 2498 00e6 8040      		sbci r24,0
 2499 00e8 01F4      		brne 1b
 2500 00ea 00C0      		rjmp .
 2501 00ec 0000      		nop
 2502 00ee 00C0      		rjmp .L77
 2503               	.LVL160:
 2504               	.L76:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2505               		.loc 2 187 2 is_stmt 0 discriminator 1 view .LVU589
 2506               	.LBE81:
 2507               	.LBE80:
 426:main.c        **** 			
 427:main.c        **** 		}	
 428:main.c        **** 	}
 429:main.c        **** 	
 430:main.c        **** 	CAN_RXInit(5, 0, ADMINmsk, ADMIN );				//set mob up for listening to admin messages
 2508               		.loc 1 430 2 is_stmt 1 view .LVU590
 2509 00f0 E12C      		mov r14,__zero_reg__
 2510 00f2 F12C      		mov r15,__zero_reg__
 2511 00f4 00E0      		ldi r16,0
 2512 00f6 10E1      		ldi r17,lo8(16)
 2513 00f8 20E0      		ldi r18,0
 2514 00fa 30E0      		ldi r19,0
 2515 00fc 40E0      		ldi r20,0
 2516 00fe 50E1      		ldi r21,lo8(16)
 2517 0100 60E0      		ldi r22,0
 2518 0102 85E0      		ldi r24,lo8(5)
 2519 0104 0E94 0000 		call CAN_RXInit
 2520               	.LVL161:
 431:main.c        **** 	cell cells[8];					//create primary cell array. this will hold all configuration and collected dat
 2521               		.loc 1 431 2 view .LVU591
 432:main.c        ****     Cells_init(cells);
 2522               		.loc 1 432 5 view .LVU592
 2523 0108 CE01      		movw r24,r28
 2524 010a 0196      		adiw r24,1
 2525 010c 0E94 0000 		call Cells_init
 2526               	.LVL162:
 433:main.c        **** 	CellBalanceMode = 0;
 2527               		.loc 1 433 2 view .LVU593
 2528               		.loc 1 433 18 is_stmt 0 view .LVU594
 2529 0110 1092 0000 		sts CellBalanceMode,__zero_reg__
 434:main.c        **** 	//uint16_t x = 0;
 435:main.c        **** 	//double temp = 0.00;
 436:main.c        **** 	Wake_Set();
 2530               		.loc 1 436 2 is_stmt 1 view .LVU595
 2531 0114 0E94 0000 		call Wake_Set
 2532               	.LVL163:
 437:main.c        **** 	while(WAKE_IN_PIN);
 2533               		.loc 1 437 2 view .LVU596
 2534               	.L78:
 2535               		.loc 1 437 20 discriminator 1 view .LVU597
 2536               		.loc 1 437 7 is_stmt 0 discriminator 1 view .LVU598
 2537 0118 3099      		sbic 0x6,0
 2538 011a 00C0      		rjmp .L78
 438:main.c        **** 	Wake_Unset();
 2539               		.loc 1 438 2 is_stmt 1 view .LVU599
 2540 011c 0E94 0000 		call Wake_Unset
 2541               	.LVL164:
 439:main.c        **** 	PowerDown();
 2542               		.loc 1 439 2 view .LVU600
 2543 0120 0E94 0000 		call PowerDown
 2544               	.LVL165:
 440:main.c        **** 	
 441:main.c        **** 	while(1)
 442:main.c        ****     {
 443:main.c        **** 		//mob = CAN_findFreeTXMOB();
 444:main.c        **** 		//if(mob>=0)CAN_TXMOB(mob, 0, 0, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|AUDIT_RESPONSE, 0)
 445:main.c        **** 		//
 446:main.c        **** 		LED_on();
 447:main.c        **** 		_delay_ms(5);		//after powering up again, wait for voltages to settle
 448:main.c        **** 		//PORTD = (PORTD & 0xe3)|((cells[3].temp_channel<<2) & 0x1c);
 449:main.c        **** 		//x = ADC_read(TEMP_MULTIPLEX_CH);
 450:main.c        **** 		//x = 279;
 451:main.c        **** 		
 452:main.c        **** 		//temp = 0.0000004*pow(x,3) -0.006*pow(x,2) +0.3424*x -37.7329;
 453:main.c        **** 		
 454:main.c        **** 		
 455:main.c        **** 		
 456:main.c        **** 		CellBalanceMode = 0;		//after one balance process, ensure that balancing is turned off. this is t
 457:main.c        **** 
 458:main.c        **** 		Balance_off();
 459:main.c        **** 		Read_all_voltages(cells);	//Reads all voltages, 3.7ms
 460:main.c        **** 		if(!(TX_cellVoltage(cells)))LED_flash(20); 
 461:main.c        **** 		Read_all_temps(cells);
 462:main.c        **** 		//cells[3].temperature = (uint16_t)temp;
 463:main.c        **** 		
 464:main.c        **** 		if(!(TX_cellTemps(cells)))LED_flash(20);
 465:main.c        **** 		//_delay_ms(10);
 466:main.c        **** 		Wake_Set();
 467:main.c        **** 			
 468:main.c        **** 		
 469:main.c        **** 		if(CellBalanceMode)
 470:main.c        **** 		{
 471:main.c        **** 			LED_off();
 472:main.c        **** 			Balance_init(cells);
 473:main.c        **** 			Balance_on();
 474:main.c        **** 			LED_flash(50);
 475:main.c        **** 		}
 476:main.c        **** 		
 477:main.c        **** 		if(!(WAKE_IN_PIN))
 478:main.c        **** 		{
 479:main.c        **** 			LED_off();
 480:main.c        **** 			_delay_ms(1);
 481:main.c        **** 			Wake_Unset();
 482:main.c        **** 			PowerDown();
 483:main.c        **** 			//LED_on();
 484:main.c        **** 		}
 485:main.c        **** 		else
 486:main.c        **** 		{
 487:main.c        **** 			_delay_ms(200);
 488:main.c        **** 			CANPAGE = (4 << 4);
 2545               		.loc 1 488 12 is_stmt 0 view .LVU601
 2546 0124 90E4      		ldi r25,lo8(64)
 2547 0126 D92E      		mov r13,r25
 2548               	.L84:
 441:main.c        ****     {
 2549               		.loc 1 441 2 is_stmt 1 view .LVU602
 446:main.c        **** 		_delay_ms(5);		//after powering up again, wait for voltages to settle
 2550               		.loc 1 446 3 view .LVU603
 2551 0128 0E94 0000 		call LED_on
 2552               	.LVL166:
 447:main.c        **** 		//PORTD = (PORTD & 0xe3)|((cells[3].temp_channel<<2) & 0x1c);
 2553               		.loc 1 447 3 view .LVU604
 2554               	.LBB82:
 2555               	.LBI82:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2556               		.loc 2 166 1 view .LVU605
 2557               	.LBB83:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2558               		.loc 2 168 2 view .LVU606
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2559               		.loc 2 172 2 view .LVU607
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2560               		.loc 2 173 2 view .LVU608
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2561               		.loc 2 174 2 view .LVU609
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2562               		.loc 2 184 3 view .LVU610
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2563               		.loc 2 187 2 view .LVU611
 2564 012c 8FE1      		ldi r24,lo8(19999)
 2565 012e 9EE4      		ldi r25,hi8(19999)
 2566 0130 0197      	1:	sbiw r24,1
 2567 0132 01F4      		brne 1b
 2568 0134 00C0      		rjmp .
 2569 0136 0000      		nop
 2570               	.LVL167:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2571               		.loc 2 187 2 is_stmt 0 view .LVU612
 2572               	.LBE83:
 2573               	.LBE82:
 456:main.c        **** 
 2574               		.loc 1 456 3 is_stmt 1 view .LVU613
 456:main.c        **** 
 2575               		.loc 1 456 19 is_stmt 0 view .LVU614
 2576 0138 1092 0000 		sts CellBalanceMode,__zero_reg__
 458:main.c        **** 		Read_all_voltages(cells);	//Reads all voltages, 3.7ms
 2577               		.loc 1 458 3 is_stmt 1 view .LVU615
 2578 013c 0E94 0000 		call Balance_off
 2579               	.LVL168:
 459:main.c        **** 		if(!(TX_cellVoltage(cells)))LED_flash(20); 
 2580               		.loc 1 459 3 view .LVU616
 2581 0140 CE01      		movw r24,r28
 2582 0142 0196      		adiw r24,1
 2583 0144 0E94 0000 		call Read_all_voltages
 2584               	.LVL169:
 460:main.c        **** 		Read_all_temps(cells);
 2585               		.loc 1 460 3 view .LVU617
 460:main.c        **** 		Read_all_temps(cells);
 2586               		.loc 1 460 8 is_stmt 0 view .LVU618
 2587 0148 CE01      		movw r24,r28
 2588 014a 0196      		adiw r24,1
 2589 014c 0E94 0000 		call TX_cellVoltage
 2590               	.LVL170:
 460:main.c        **** 		Read_all_temps(cells);
 2591               		.loc 1 460 5 view .LVU619
 2592 0150 8111      		cpse r24,__zero_reg__
 2593 0152 00C0      		rjmp .L79
 460:main.c        **** 		Read_all_temps(cells);
 2594               		.loc 1 460 31 is_stmt 1 discriminator 1 view .LVU620
 2595 0154 84E1      		ldi r24,lo8(20)
 2596 0156 0E94 0000 		call LED_flash
 2597               	.LVL171:
 2598               	.L79:
 461:main.c        **** 		//cells[3].temperature = (uint16_t)temp;
 2599               		.loc 1 461 3 view .LVU621
 2600 015a CE01      		movw r24,r28
 2601 015c 0196      		adiw r24,1
 2602 015e 0E94 0000 		call Read_all_temps
 2603               	.LVL172:
 464:main.c        **** 		//_delay_ms(10);
 2604               		.loc 1 464 3 view .LVU622
 464:main.c        **** 		//_delay_ms(10);
 2605               		.loc 1 464 8 is_stmt 0 view .LVU623
 2606 0162 CE01      		movw r24,r28
 2607 0164 0196      		adiw r24,1
 2608 0166 0E94 0000 		call TX_cellTemps
 2609               	.LVL173:
 464:main.c        **** 		//_delay_ms(10);
 2610               		.loc 1 464 5 view .LVU624
 2611 016a 8111      		cpse r24,__zero_reg__
 2612 016c 00C0      		rjmp .L80
 464:main.c        **** 		//_delay_ms(10);
 2613               		.loc 1 464 29 is_stmt 1 discriminator 1 view .LVU625
 2614 016e 84E1      		ldi r24,lo8(20)
 2615 0170 0E94 0000 		call LED_flash
 2616               	.LVL174:
 2617               	.L80:
 466:main.c        **** 			
 2618               		.loc 1 466 3 view .LVU626
 2619 0174 0E94 0000 		call Wake_Set
 2620               	.LVL175:
 469:main.c        **** 		{
 2621               		.loc 1 469 3 view .LVU627
 469:main.c        **** 		{
 2622               		.loc 1 469 5 is_stmt 0 view .LVU628
 2623 0178 8091 0000 		lds r24,CellBalanceMode
 2624 017c 8823      		tst r24
 2625 017e 01F0      		breq .L81
 471:main.c        **** 			Balance_init(cells);
 2626               		.loc 1 471 4 is_stmt 1 view .LVU629
 2627 0180 0E94 0000 		call LED_off
 2628               	.LVL176:
 472:main.c        **** 			Balance_on();
 2629               		.loc 1 472 4 view .LVU630
 2630 0184 CE01      		movw r24,r28
 2631 0186 0196      		adiw r24,1
 2632 0188 0E94 0000 		call Balance_init
 2633               	.LVL177:
 473:main.c        **** 			LED_flash(50);
 2634               		.loc 1 473 4 view .LVU631
 2635 018c 0E94 0000 		call Balance_on
 2636               	.LVL178:
 474:main.c        **** 		}
 2637               		.loc 1 474 4 view .LVU632
 2638 0190 82E3      		ldi r24,lo8(50)
 2639 0192 0E94 0000 		call LED_flash
 2640               	.LVL179:
 2641               	.L81:
 477:main.c        **** 		{
 2642               		.loc 1 477 3 view .LVU633
 477:main.c        **** 		{
 2643               		.loc 1 477 5 is_stmt 0 view .LVU634
 2644 0196 3099      		sbic 0x6,0
 2645 0198 00C0      		rjmp .L82
 479:main.c        **** 			_delay_ms(1);
 2646               		.loc 1 479 4 is_stmt 1 view .LVU635
 2647 019a 0E94 0000 		call LED_off
 2648               	.LVL180:
 480:main.c        **** 			Wake_Unset();
 2649               		.loc 1 480 4 view .LVU636
 2650               	.LBB84:
 2651               	.LBI84:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2652               		.loc 2 166 1 view .LVU637
 2653               	.LBB85:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2654               		.loc 2 168 2 view .LVU638
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2655               		.loc 2 172 2 view .LVU639
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2656               		.loc 2 173 2 view .LVU640
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2657               		.loc 2 174 2 view .LVU641
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2658               		.loc 2 184 3 view .LVU642
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2659               		.loc 2 187 2 view .LVU643
 2660 019e 8FE9      		ldi r24,lo8(3999)
 2661 01a0 9FE0      		ldi r25,hi8(3999)
 2662 01a2 0197      	1:	sbiw r24,1
 2663 01a4 01F4      		brne 1b
 2664 01a6 00C0      		rjmp .
 2665 01a8 0000      		nop
 2666               	.LVL181:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2667               		.loc 2 187 2 is_stmt 0 view .LVU644
 2668               	.LBE85:
 2669               	.LBE84:
 481:main.c        **** 			PowerDown();
 2670               		.loc 1 481 4 is_stmt 1 view .LVU645
 2671 01aa 0E94 0000 		call Wake_Unset
 2672               	.LVL182:
 482:main.c        **** 			//LED_on();
 2673               		.loc 1 482 4 view .LVU646
 2674 01ae 0E94 0000 		call PowerDown
 2675               	.LVL183:
 2676               	.L83:
 489:main.c        **** 			CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 490:main.c        **** 		}
 491:main.c        **** 		CANPAGE = (4 << 4);
 2677               		.loc 1 491 3 view .LVU647
 2678               		.loc 1 491 11 is_stmt 0 view .LVU648
 2679 01b2 D092 ED00 		sts 237,r13
 492:main.c        **** 		CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 2680               		.loc 1 492 3 is_stmt 1 view .LVU649
 2681               		.loc 1 492 12 is_stmt 0 view .LVU650
 2682 01b6 8091 EE00 		lds r24,238
 2683 01ba 8F7D      		andi r24,lo8(-33)
 2684 01bc 8093 EE00 		sts 238,r24
 493:main.c        **** 		CAN_RXInit(4,0,AMUmsk, AMU);	//set mob up for listening to the AMU
 2685               		.loc 1 493 3 is_stmt 1 view .LVU651
 2686 01c0 E12C      		mov r14,__zero_reg__
 2687 01c2 F12C      		mov r15,__zero_reg__
 2688 01c4 00E0      		ldi r16,0
 2689 01c6 18E0      		ldi r17,lo8(8)
 2690 01c8 20E0      		ldi r18,0
 2691 01ca 30E0      		ldi r19,0
 2692 01cc 40E0      		ldi r20,0
 2693 01ce 58E0      		ldi r21,lo8(8)
 2694 01d0 60E0      		ldi r22,0
 2695 01d2 84E0      		ldi r24,lo8(4)
 2696 01d4 0E94 0000 		call CAN_RXInit
 2697               	.LVL184:
 446:main.c        **** 		_delay_ms(5);		//after powering up again, wait for voltages to settle
 2698               		.loc 1 446 3 is_stmt 0 view .LVU652
 2699 01d8 00C0      		rjmp .L84
 2700               	.L82:
 487:main.c        **** 			CANPAGE = (4 << 4);
 2701               		.loc 1 487 4 is_stmt 1 view .LVU653
 2702               	.LVL185:
 2703               	.LBB86:
 2704               	.LBI86:
 166:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** {
 2705               		.loc 2 166 1 view .LVU654
 2706               	.LBB87:
 168:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2707               		.loc 2 168 2 view .LVU655
 172:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2708               		.loc 2 172 2 view .LVU656
 173:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2709               		.loc 2 173 2 view .LVU657
 174:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2710               		.loc 2 174 2 view .LVU658
 184:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 	#endif
 2711               		.loc 2 184 3 view .LVU659
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2712               		.loc 2 187 2 view .LVU660
 2713 01da 9FEF      		ldi r25,lo8(639999)
 2714 01dc 23EC      		ldi r18,hi8(639999)
 2715 01de 89E0      		ldi r24,hlo8(639999)
 2716 01e0 9150      	1:	subi r25,1
 2717 01e2 2040      		sbci r18,0
 2718 01e4 8040      		sbci r24,0
 2719 01e6 01F4      		brne 1b
 2720 01e8 00C0      		rjmp .
 2721 01ea 0000      		nop
 2722               	.LVL186:
 187:/usr/local/Cellar/avr-gcc/8.1.0/avr/include/util/delay.h **** 
 2723               		.loc 2 187 2 is_stmt 0 view .LVU661
 2724               	.LBE87:
 2725               	.LBE86:
 488:main.c        **** 			CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 2726               		.loc 1 488 4 is_stmt 1 view .LVU662
 488:main.c        **** 			CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 2727               		.loc 1 488 12 is_stmt 0 view .LVU663
 2728 01ec D092 ED00 		sts 237,r13
 489:main.c        **** 		}
 2729               		.loc 1 489 4 is_stmt 1 view .LVU664
 489:main.c        **** 		}
 2730               		.loc 1 489 13 is_stmt 0 view .LVU665
 2731 01f0 8091 EE00 		lds r24,238
 2732 01f4 8F7D      		andi r24,lo8(-33)
 2733 01f6 8093 EE00 		sts 238,r24
 2734 01fa 00C0      		rjmp .L83
 2735               		.cfi_endproc
 2736               	.LFE38:
 2738               		.section	.text.__vector_10,"ax",@progbits
 2739               	.global	__vector_10
 2741               	__vector_10:
 2742               	.LFB39:
 494:main.c        **** 		//while(CellBalanceCounter < BALANCE_DUTY_CYCLE);
 495:main.c        **** 		//Balance_cells(cells);
 496:main.c        **** 		//Read_all_temps(cells);		//Reads all temperatures, 2.9ms
 497:main.c        **** 
 498:main.c        **** 		
 499:main.c        **** 		//PORTD |= (1<<PIND7);		//send wake out, halfway through sending our data back to the AMU.
 500:main.c        ****     }
 501:main.c        **** }
 502:main.c        **** 
 503:main.c        **** ISR(INT3_vect)
 504:main.c        **** {
 2743               		.loc 1 504 1 is_stmt 1 view -0
 2744               		.cfi_startproc
 2745 0000 8F93      		__gcc_isr 1
 2746               	/* prologue: Signal */
 2747               	/* frame size = 0 */
 2748               	/* stack size = 0...4 */
 2749               	.L__stack_usage = 0 + __gcc_isr.n_pushed
 505:main.c        **** 	SMCR = (0<<SM2)|(0<<SM1)|(1<<SM0)|(0<<SE);		//disable the mode, and disable the enable bit.
 2750               		.loc 1 505 2 view .LVU667
 2751               		.loc 1 505 7 is_stmt 0 view .LVU668
 2752 0002 82E0      		ldi r24,lo8(2)
 2753 0004 83BF      		out 0x33,r24
 2754               	/* epilogue start */
 506:main.c        **** }
 2755               		.loc 1 506 1 view .LVU669
 2756 0006 8F91      		__gcc_isr 2
 2757 0008 1895      		reti
 2758               		__gcc_isr 0,r24
 2759               		.cfi_endproc
 2760               	.LFE39:
 2762               		.section	.text.__vector_18,"ax",@progbits
 2763               	.global	__vector_18
 2765               	__vector_18:
 2766               	.LFB40:
 507:main.c        **** 
 508:main.c        **** ISR(CAN_INT_vect)
 509:main.c        **** {
 2767               		.loc 1 509 1 is_stmt 1 view -0
 2768               		.cfi_startproc
 2769 0000 1F92      		push r1
 2770               	.LCFI66:
 2771               		.cfi_def_cfa_offset 3
 2772               		.cfi_offset 1, -2
 2773 0002 0F92      		push r0
 2774               	.LCFI67:
 2775               		.cfi_def_cfa_offset 4
 2776               		.cfi_offset 0, -3
 2777 0004 0FB6      		in r0,__SREG__
 2778 0006 0F92      		push r0
 2779 0008 1124      		clr __zero_reg__
 2780 000a EF92      		push r14
 2781               	.LCFI68:
 2782               		.cfi_def_cfa_offset 5
 2783               		.cfi_offset 14, -4
 2784 000c FF92      		push r15
 2785               	.LCFI69:
 2786               		.cfi_def_cfa_offset 6
 2787               		.cfi_offset 15, -5
 2788 000e 0F93      		push r16
 2789               	.LCFI70:
 2790               		.cfi_def_cfa_offset 7
 2791               		.cfi_offset 16, -6
 2792 0010 1F93      		push r17
 2793               	.LCFI71:
 2794               		.cfi_def_cfa_offset 8
 2795               		.cfi_offset 17, -7
 2796 0012 2F93      		push r18
 2797               	.LCFI72:
 2798               		.cfi_def_cfa_offset 9
 2799               		.cfi_offset 18, -8
 2800 0014 3F93      		push r19
 2801               	.LCFI73:
 2802               		.cfi_def_cfa_offset 10
 2803               		.cfi_offset 19, -9
 2804 0016 4F93      		push r20
 2805               	.LCFI74:
 2806               		.cfi_def_cfa_offset 11
 2807               		.cfi_offset 20, -10
 2808 0018 5F93      		push r21
 2809               	.LCFI75:
 2810               		.cfi_def_cfa_offset 12
 2811               		.cfi_offset 21, -11
 2812 001a 6F93      		push r22
 2813               	.LCFI76:
 2814               		.cfi_def_cfa_offset 13
 2815               		.cfi_offset 22, -12
 2816 001c 7F93      		push r23
 2817               	.LCFI77:
 2818               		.cfi_def_cfa_offset 14
 2819               		.cfi_offset 23, -13
 2820 001e 8F93      		push r24
 2821               	.LCFI78:
 2822               		.cfi_def_cfa_offset 15
 2823               		.cfi_offset 24, -14
 2824 0020 9F93      		push r25
 2825               	.LCFI79:
 2826               		.cfi_def_cfa_offset 16
 2827               		.cfi_offset 25, -15
 2828 0022 AF93      		push r26
 2829               	.LCFI80:
 2830               		.cfi_def_cfa_offset 17
 2831               		.cfi_offset 26, -16
 2832 0024 BF93      		push r27
 2833               	.LCFI81:
 2834               		.cfi_def_cfa_offset 18
 2835               		.cfi_offset 27, -17
 2836 0026 EF93      		push r30
 2837               	.LCFI82:
 2838               		.cfi_def_cfa_offset 19
 2839               		.cfi_offset 30, -18
 2840 0028 FF93      		push r31
 2841               	.LCFI83:
 2842               		.cfi_def_cfa_offset 20
 2843               		.cfi_offset 31, -19
 2844 002a CF93      		push r28
 2845               	.LCFI84:
 2846               		.cfi_def_cfa_offset 21
 2847               		.cfi_offset 28, -20
 2848 002c DF93      		push r29
 2849               	.LCFI85:
 2850               		.cfi_def_cfa_offset 22
 2851               		.cfi_offset 29, -21
 2852 002e 00D0      		rcall .
 2853               	.LCFI86:
 2854               		.cfi_def_cfa_offset 24
 2855 0030 CDB7      		in r28,__SP_L__
 2856 0032 DEB7      		in r29,__SP_H__
 2857               	.LCFI87:
 2858               		.cfi_def_cfa_register 28
 2859               	/* prologue: Signal */
 2860               	/* frame size = 2 */
 2861               	/* stack size = 23 */
 2862               	.L__stack_usage = 23
 510:main.c        **** 	//uint8_t authority;
 511:main.c        **** 	int8_t mob;	
 2863               		.loc 1 511 2 view .LVU671
 512:main.c        **** 	
 513:main.c        **** 	if((CANSIT2 & (1 << SIT4)))	//we received a CAN message on mob 5, which is set up to receive exclu
 2864               		.loc 1 513 2 view .LVU672
 2865               		.loc 1 513 6 is_stmt 0 view .LVU673
 2866 0034 8091 E000 		lds r24,224
 2867               		.loc 1 513 4 view .LVU674
 2868 0038 84FF      		sbrs r24,4
 2869 003a 00C0      		rjmp .L94
 514:main.c        **** 	{
 515:main.c        **** 		
 516:main.c        **** 		CANPAGE = (4 << 4);			//set the canpage to the receiver MOB
 2870               		.loc 1 516 3 is_stmt 1 view .LVU675
 2871               		.loc 1 516 11 is_stmt 0 view .LVU676
 2872 003c 80E4      		ldi r24,lo8(64)
 2873 003e 8093 ED00 		sts 237,r24
 517:main.c        **** 		if((CANIDT4 >> 3) == AUDIT_REQUEST && !registered )	//if the received ID has packet type audit re
 2874               		.loc 1 517 3 is_stmt 1 view .LVU677
 2875               		.loc 1 517 7 is_stmt 0 view .LVU678
 2876 0042 8091 F000 		lds r24,240
 2877               		.loc 1 517 21 view .LVU679
 2878 0046 8695      		lsr r24
 2879 0048 8695      		lsr r24
 2880 004a 8695      		lsr r24
 2881               		.loc 1 517 5 view .LVU680
 2882 004c 8131      		cpi r24,lo8(17)
 2883 004e 01F0      		breq .+2
 2884 0050 00C0      		rjmp .L95
 2885               		.loc 1 517 38 discriminator 1 view .LVU681
 2886 0052 8091 0000 		lds r24,registered
 2887 0056 8111      		cpse r24,__zero_reg__
 2888 0058 00C0      		rjmp .L95
 2889               	.LBB88:
 518:main.c        **** 		{
 519:main.c        **** 			mob = CAN_findFreeTXMOB();
 2890               		.loc 1 519 4 is_stmt 1 view .LVU682
 2891               		.loc 1 519 10 is_stmt 0 view .LVU683
 2892 005a 0E94 0000 		call CAN_findFreeTXMOB
 2893               	.LVL187:
 520:main.c        **** 			AMUID =  ((CANIDT2 >> 5) & 0b00000111);	//last 5 bits of CANIDT3 contain the lower 5 bits of the
 2894               		.loc 1 520 4 is_stmt 1 view .LVU684
 2895               		.loc 1 520 15 is_stmt 0 view .LVU685
 2896 005e 9091 F200 		lds r25,242
 2897               		.loc 1 520 29 view .LVU686
 2898 0062 9295      		swap r25
 2899 0064 9695      		lsr r25
 2900 0066 9770      		andi r25,lo8(7)
 2901               		.loc 1 520 10 view .LVU687
 2902 0068 9093 0000 		sts AMUID,r25
 521:main.c        **** 			AMUID |= ((CANIDT1 << 3) & 0b11111000);	//first 3 bits of CANIDT2 contain the last 3 bits of the
 2903               		.loc 1 521 4 is_stmt 1 view .LVU688
 2904               		.loc 1 521 15 is_stmt 0 view .LVU689
 2905 006c 2091 F300 		lds r18,243
 2906               		.loc 1 521 23 view .LVU690
 2907 0070 48E0      		ldi r20,lo8(8)
 2908 0072 249F      		mul r18,r20
 2909 0074 9001      		movw r18,r0
 2910 0076 1124      		clr __zero_reg__
 2911               		.loc 1 521 10 view .LVU691
 2912 0078 922B      		or r25,r18
 2913 007a 9093 0000 		sts AMUID,r25
 522:main.c        **** 			uint8_t data[2] = {(fw_version>>8) & 0xFF, fw_version & 0xFF};
 2914               		.loc 1 522 4 is_stmt 1 view .LVU692
 2915               		.loc 1 522 12 is_stmt 0 view .LVU693
 2916 007e 2091 0000 		lds r18,fw_version
 2917 0082 3091 0000 		lds r19,fw_version+1
 2918 0086 3227      		eor r19,r18
 2919 0088 2327      		eor r18,r19
 2920 008a 3227      		eor r19,r18
 2921 008c 3A83      		std Y+2,r19
 2922 008e 2983      		std Y+1,r18
 523:main.c        **** 			if(mob>=0)CAN_TXMOB(mob, 2, data, ((uint32_t)deviceID<<18)|((uint32_t)AMUID<<8)|AUDIT_RESPONSE, 
 2923               		.loc 1 523 4 is_stmt 1 view .LVU694
 2924               		.loc 1 523 6 is_stmt 0 view .LVU695
 2925 0090 87FD      		sbrc r24,7
 2926 0092 00C0      		rjmp .L97
 2927               		.loc 1 523 14 is_stmt 1 discriminator 1 view .LVU696
 2928               		.loc 1 523 39 is_stmt 0 discriminator 1 view .LVU697
 2929 0094 4091 0000 		lds r20,deviceID
 2930 0098 5091 0000 		lds r21,deviceID+1
 2931 009c 8A01      		movw r16,r20
 2932 009e 30E0      		ldi r19,0
 2933 00a0 20E0      		ldi r18,0
 2934               		.loc 1 523 57 discriminator 1 view .LVU698
 2935 00a2 62E1      		ldi r22,18
 2936               		1:
 2937 00a4 000F      		lsl r16
 2938 00a6 111F      		rol r17
 2939 00a8 221F      		rol r18
 2940 00aa 331F      		rol r19
 2941 00ac 6A95      		dec r22
 2942 00ae 01F4      		brne 1b
 2943               		.loc 1 523 84 discriminator 1 view .LVU699
 2944 00b0 542F      		mov r21,r20
 2945 00b2 4427      		clr r20
 2946 00b4 70E0      		ldi r23,0
 2947 00b6 60E0      		ldi r22,0
 2948 00b8 042B      		or r16,r20
 2949 00ba 152B      		or r17,r21
 2950 00bc 262B      		or r18,r22
 2951 00be 372B      		or r19,r23
 2952 00c0 192B      		or r17,r25
 2953               		.loc 1 523 14 discriminator 1 view .LVU700
 2954 00c2 0361      		ori r16,19
 2955 00c4 E12C      		mov r14,__zero_reg__
 2956 00c6 AE01      		movw r20,r28
 2957 00c8 4F5F      		subi r20,-1
 2958 00ca 5F4F      		sbci r21,-1
 2959 00cc 62E0      		ldi r22,lo8(2)
 2960 00ce 0E94 0000 		call CAN_TXMOB
 2961               	.LVL188:
 2962               	.L97:
 2963               		.loc 1 523 14 discriminator 1 view .LVU701
 2964               	.LBE88:
 524:main.c        **** 			
 525:main.c        **** 		}
 526:main.c        **** 		else if((CANIDT4 >> 3)== READ_RECEIPT && !registered )
 527:main.c        **** 		{
 528:main.c        **** 			Wake_Set();
 529:main.c        **** 			registered = 1;
 530:main.c        **** 		}
 531:main.c        **** 		else if((CANIDT4 >> 3)== BALANCE_ON && (CANCDMOB & 0b1111) == BALANCE_NPACKETS)
 532:main.c        **** 		{
 533:main.c        **** 			//this packet processing is important, so we need to do it in here.
 534:main.c        **** 			for(uint8_t i = 0; i < BALANCE_NPACKETS; i++)
 535:main.c        **** 			{
 536:main.c        **** 				switch(i)
 537:main.c        **** 				{
 538:main.c        **** 					case 0:
 539:main.c        **** 						BALANCE_TARGET_VOLTAGE = (uint16_t)(CANMSG<<8);		//CAN byte 1
 540:main.c        **** 						break;
 541:main.c        **** 					case 1:
 542:main.c        **** 						BALANCE_TARGET_VOLTAGE |= CANMSG;					//CAN byte 2
 543:main.c        **** 						break;
 544:main.c        **** 					case 2:
 545:main.c        **** 						BALANCE_DUTY_CYCLE = CANMSG;						//CAN byte 3
 546:main.c        **** 						break;
 547:main.c        **** 					case 3:
 548:main.c        **** 						BALANCE_RESERVED1 = CANMSG;							//CAN byte 4
 549:main.c        **** 						break;
 550:main.c        **** 					case 4:
 551:main.c        **** 						BALANCE_RESERVED2 = CANMSG;							//CAN byte 5
 552:main.c        **** 						break;
 553:main.c        **** 					default:
 554:main.c        **** 						break;
 555:main.c        **** 				}
 556:main.c        **** 			}
 557:main.c        **** 			if(BALANCE_TARGET_VOLTAGE > 3200 && BALANCE_TARGET_VOLTAGE < 4200 && BALANCE_DUTY_CYCLE < 50) Ce
 558:main.c        **** 		}
 559:main.c        **** 		else if((CANIDT4 >> 3)== BALANCE_OFF )
 560:main.c        **** 		{
 561:main.c        **** 			CellBalanceMode = 0;
 562:main.c        **** 		}
 563:main.c        **** 		CAN_RXInit(4,0,AMUmsk, AMU);	//set mob up for listening to the AMU
 2965               		.loc 1 563 3 is_stmt 1 view .LVU702
 2966 00d2 E12C      		mov r14,__zero_reg__
 2967 00d4 F12C      		mov r15,__zero_reg__
 2968 00d6 00E0      		ldi r16,0
 2969 00d8 18E0      		ldi r17,lo8(8)
 2970 00da 20E0      		ldi r18,0
 2971 00dc 30E0      		ldi r19,0
 2972 00de 40E0      		ldi r20,0
 2973 00e0 58E0      		ldi r21,lo8(8)
 2974 00e2 60E0      		ldi r22,0
 2975 00e4 84E0      		ldi r24,lo8(4)
 2976 00e6 0E94 0000 		call CAN_RXInit
 2977               	.LVL189:
 2978               	.L94:
 564:main.c        **** 	}
 565:main.c        **** 	CANPAGE = (4 << 4);
 2979               		.loc 1 565 2 view .LVU703
 2980               		.loc 1 565 10 is_stmt 0 view .LVU704
 2981 00ea 80E4      		ldi r24,lo8(64)
 2982 00ec 8093 ED00 		sts 237,r24
 566:main.c        **** 	CANSTMOB &= ~(1 << RXOK);	//unset the RXOK bit to clear the interrupt.
 2983               		.loc 1 566 2 is_stmt 1 view .LVU705
 2984               		.loc 1 566 11 is_stmt 0 view .LVU706
 2985 00f0 8091 EE00 		lds r24,238
 2986 00f4 8F7D      		andi r24,lo8(-33)
 2987 00f6 8093 EE00 		sts 238,r24
 567:main.c        **** 	LED_off();
 2988               		.loc 1 567 2 is_stmt 1 view .LVU707
 2989 00fa 0E94 0000 		call LED_off
 2990               	.LVL190:
 2991               	/* epilogue start */
 568:main.c        **** }
 2992               		.loc 1 568 1 is_stmt 0 view .LVU708
 2993 00fe 0F90      		pop __tmp_reg__
 2994 0100 0F90      		pop __tmp_reg__
 2995 0102 DF91      		pop r29
 2996 0104 CF91      		pop r28
 2997 0106 FF91      		pop r31
 2998 0108 EF91      		pop r30
 2999 010a BF91      		pop r27
 3000 010c AF91      		pop r26
 3001 010e 9F91      		pop r25
 3002 0110 8F91      		pop r24
 3003 0112 7F91      		pop r23
 3004 0114 6F91      		pop r22
 3005 0116 5F91      		pop r21
 3006 0118 4F91      		pop r20
 3007 011a 3F91      		pop r19
 3008 011c 2F91      		pop r18
 3009 011e 1F91      		pop r17
 3010 0120 0F91      		pop r16
 3011 0122 FF90      		pop r15
 3012 0124 EF90      		pop r14
 3013 0126 0F90      		pop r0
 3014 0128 0FBE      		out __SREG__,r0
 3015 012a 0F90      		pop r0
 3016 012c 1F90      		pop r1
 3017 012e 1895      		reti
 3018               	.L95:
 526:main.c        **** 		{
 3019               		.loc 1 526 8 is_stmt 1 view .LVU709
 526:main.c        **** 		{
 3020               		.loc 1 526 12 is_stmt 0 view .LVU710
 3021 0130 8091 F000 		lds r24,240
 526:main.c        **** 		{
 3022               		.loc 1 526 25 view .LVU711
 3023 0134 8695      		lsr r24
 3024 0136 8695      		lsr r24
 3025 0138 8695      		lsr r24
 526:main.c        **** 		{
 3026               		.loc 1 526 10 view .LVU712
 3027 013a 8231      		cpi r24,lo8(18)
 3028 013c 01F4      		brne .L98
 526:main.c        **** 		{
 3029               		.loc 1 526 41 discriminator 1 view .LVU713
 3030 013e 8091 0000 		lds r24,registered
 3031 0142 8111      		cpse r24,__zero_reg__
 3032 0144 00C0      		rjmp .L98
 528:main.c        **** 			registered = 1;
 3033               		.loc 1 528 4 is_stmt 1 view .LVU714
 3034 0146 0E94 0000 		call Wake_Set
 3035               	.LVL191:
 529:main.c        **** 		}
 3036               		.loc 1 529 4 view .LVU715
 529:main.c        **** 		}
 3037               		.loc 1 529 15 is_stmt 0 view .LVU716
 3038 014a 81E0      		ldi r24,lo8(1)
 3039 014c 8093 0000 		sts registered,r24
 3040 0150 00C0      		rjmp .L97
 3041               	.L98:
 531:main.c        **** 		{
 3042               		.loc 1 531 8 is_stmt 1 view .LVU717
 531:main.c        **** 		{
 3043               		.loc 1 531 12 is_stmt 0 view .LVU718
 3044 0152 8091 F000 		lds r24,240
 531:main.c        **** 		{
 3045               		.loc 1 531 25 view .LVU719
 3046 0156 8695      		lsr r24
 3047 0158 8695      		lsr r24
 3048 015a 8695      		lsr r24
 531:main.c        **** 		{
 3049               		.loc 1 531 10 view .LVU720
 3050 015c 8431      		cpi r24,lo8(20)
 3051 015e 01F0      		breq .+2
 3052 0160 00C0      		rjmp .L99
 531:main.c        **** 		{
 3053               		.loc 1 531 43 discriminator 1 view .LVU721
 3054 0162 8091 EF00 		lds r24,239
 531:main.c        **** 		{
 3055               		.loc 1 531 39 discriminator 1 view .LVU722
 3056 0166 8F70      		andi r24,lo8(15)
 3057 0168 8530      		cpi r24,lo8(5)
 3058 016a 01F0      		breq .+2
 3059 016c 00C0      		rjmp .L99
 3060               	.LBB89:
 534:main.c        **** 			{
 3061               		.loc 1 534 16 view .LVU723
 3062 016e 80E0      		ldi r24,0
 3063               	.L107:
 3064               	.LVL192:
 536:main.c        **** 				{
 3065               		.loc 1 536 5 is_stmt 1 view .LVU724
 3066 0170 8230      		cpi r24,lo8(2)
 3067 0172 01F0      		breq .L100
 3068 0174 00F4      		brsh .L101
 3069 0176 8130      		cpi r24,lo8(1)
 3070 0178 01F0      		breq .L102
 3071               	.L103:
 3072               	.LVL193:
 539:main.c        **** 						break;
 3073               		.loc 1 539 7 view .LVU725
 539:main.c        **** 						break;
 3074               		.loc 1 539 43 is_stmt 0 view .LVU726
 3075 017a 9091 FA00 		lds r25,250
 539:main.c        **** 						break;
 3076               		.loc 1 539 30 view .LVU727
 3077 017e 1092 0000 		sts BALANCE_TARGET_VOLTAGE,__zero_reg__
 3078 0182 9093 0000 		sts BALANCE_TARGET_VOLTAGE+1,r25
 540:main.c        **** 					case 1:
 3079               		.loc 1 540 7 is_stmt 1 view .LVU728
 3080               	.LVL194:
 3081               	.L106:
 534:main.c        **** 			{
 3082               		.loc 1 534 46 is_stmt 0 discriminator 2 view .LVU729
 3083 0186 8F5F      		subi r24,lo8(-(1))
 3084               	.LVL195:
 534:main.c        **** 			{
 3085               		.loc 1 534 4 discriminator 2 view .LVU730
 3086 0188 8530      		cpi r24,lo8(5)
 3087 018a 01F4      		brne .L107
 3088               	.LVL196:
 534:main.c        **** 			{
 3089               		.loc 1 534 4 discriminator 2 view .LVU731
 3090               	.LBE89:
 557:main.c        **** 		}
 3091               		.loc 1 557 4 is_stmt 1 view .LVU732
 557:main.c        **** 		}
 3092               		.loc 1 557 37 is_stmt 0 view .LVU733
 3093 018c 8091 0000 		lds r24,BALANCE_TARGET_VOLTAGE
 3094 0190 9091 0000 		lds r25,BALANCE_TARGET_VOLTAGE+1
 3095 0194 8158      		subi r24,-127
 3096 0196 9C40      		sbci r25,12
 557:main.c        **** 		}
 3097               		.loc 1 557 6 view .LVU734
 3098 0198 873E      		cpi r24,-25
 3099 019a 9340      		sbci r25,3
 3100 019c 00F0      		brlo .+2
 3101 019e 00C0      		rjmp .L97
 557:main.c        **** 		}
 3102               		.loc 1 557 92 discriminator 1 view .LVU735
 3103 01a0 8091 0000 		lds r24,BALANCE_DUTY_CYCLE
 557:main.c        **** 		}
 3104               		.loc 1 557 70 discriminator 1 view .LVU736
 3105 01a4 8233      		cpi r24,lo8(50)
 3106 01a6 00F0      		brlo .+2
 3107 01a8 00C0      		rjmp .L97
 557:main.c        **** 		}
 3108               		.loc 1 557 98 is_stmt 1 discriminator 2 view .LVU737
 557:main.c        **** 		}
 3109               		.loc 1 557 114 is_stmt 0 discriminator 2 view .LVU738
 3110 01aa 81E0      		ldi r24,lo8(1)
 3111 01ac 8093 0000 		sts CellBalanceMode,r24
 3112 01b0 00C0      		rjmp .L97
 3113               	.LVL197:
 3114               	.L101:
 557:main.c        **** 		}
 3115               		.loc 1 557 114 discriminator 2 view .LVU739
 3116 01b2 8330      		cpi r24,lo8(3)
 3117 01b4 01F0      		breq .L104
 3118 01b6 8430      		cpi r24,lo8(4)
 3119 01b8 01F4      		brne .L103
 3120               	.LBB90:
 551:main.c        **** 						break;
 3121               		.loc 1 551 7 is_stmt 1 view .LVU740
 551:main.c        **** 						break;
 3122               		.loc 1 551 27 is_stmt 0 view .LVU741
 3123 01ba 9091 FA00 		lds r25,250
 551:main.c        **** 						break;
 3124               		.loc 1 551 25 view .LVU742
 3125 01be 9093 0000 		sts BALANCE_RESERVED2,r25
 552:main.c        **** 					default:
 3126               		.loc 1 552 7 is_stmt 1 view .LVU743
 3127 01c2 00C0      		rjmp .L106
 3128               	.L102:
 542:main.c        **** 						break;
 3129               		.loc 1 542 7 view .LVU744
 542:main.c        **** 						break;
 3130               		.loc 1 542 33 is_stmt 0 view .LVU745
 3131 01c4 9091 FA00 		lds r25,250
 542:main.c        **** 						break;
 3132               		.loc 1 542 30 view .LVU746
 3133 01c8 2091 0000 		lds r18,BALANCE_TARGET_VOLTAGE
 3134 01cc 3091 0000 		lds r19,BALANCE_TARGET_VOLTAGE+1
 3135 01d0 292B      		or r18,r25
 3136 01d2 3093 0000 		sts BALANCE_TARGET_VOLTAGE+1,r19
 3137 01d6 2093 0000 		sts BALANCE_TARGET_VOLTAGE,r18
 543:main.c        **** 					case 2:
 3138               		.loc 1 543 7 is_stmt 1 view .LVU747
 3139 01da 00C0      		rjmp .L106
 3140               	.L100:
 545:main.c        **** 						break;
 3141               		.loc 1 545 7 view .LVU748
 545:main.c        **** 						break;
 3142               		.loc 1 545 28 is_stmt 0 view .LVU749
 3143 01dc 9091 FA00 		lds r25,250
 545:main.c        **** 						break;
 3144               		.loc 1 545 26 view .LVU750
 3145 01e0 9093 0000 		sts BALANCE_DUTY_CYCLE,r25
 546:main.c        **** 					case 3:
 3146               		.loc 1 546 7 is_stmt 1 view .LVU751
 3147 01e4 00C0      		rjmp .L106
 3148               	.L104:
 548:main.c        **** 						break;
 3149               		.loc 1 548 7 view .LVU752
 548:main.c        **** 						break;
 3150               		.loc 1 548 27 is_stmt 0 view .LVU753
 3151 01e6 9091 FA00 		lds r25,250
 548:main.c        **** 						break;
 3152               		.loc 1 548 25 view .LVU754
 3153 01ea 9093 0000 		sts BALANCE_RESERVED1,r25
 549:main.c        **** 					case 4:
 3154               		.loc 1 549 7 is_stmt 1 view .LVU755
 3155 01ee 00C0      		rjmp .L106
 3156               	.LVL198:
 3157               	.L99:
 549:main.c        **** 					case 4:
 3158               		.loc 1 549 7 is_stmt 0 view .LVU756
 3159               	.LBE90:
 559:main.c        **** 		{
 3160               		.loc 1 559 8 is_stmt 1 view .LVU757
 559:main.c        **** 		{
 3161               		.loc 1 559 12 is_stmt 0 view .LVU758
 3162 01f0 8091 F000 		lds r24,240
 559:main.c        **** 		{
 3163               		.loc 1 559 25 view .LVU759
 3164 01f4 8695      		lsr r24
 3165 01f6 8695      		lsr r24
 3166 01f8 8695      		lsr r24
 559:main.c        **** 		{
 3167               		.loc 1 559 10 view .LVU760
 3168 01fa 8531      		cpi r24,lo8(21)
 3169 01fc 01F0      		breq .+2
 3170 01fe 00C0      		rjmp .L97
 561:main.c        **** 		}
 3171               		.loc 1 561 4 is_stmt 1 view .LVU761
 561:main.c        **** 		}
 3172               		.loc 1 561 20 is_stmt 0 view .LVU762
 3173 0200 1092 0000 		sts CellBalanceMode,__zero_reg__
 3174 0204 00C0      		rjmp .L97
 3175               		.cfi_endproc
 3176               	.LFE40:
 3178               		.section	.text.__vector_15,"ax",@progbits
 3179               	.global	__vector_15
 3181               	__vector_15:
 3182               	.LFB41:
 569:main.c        **** 
 570:main.c        **** ISR(TIMER0_COMPA_vect)
 571:main.c        **** {
 3183               		.loc 1 571 1 is_stmt 1 view -0
 3184               		.cfi_startproc
 3185 0000 1F92      		push r1
 3186               	.LCFI88:
 3187               		.cfi_def_cfa_offset 3
 3188               		.cfi_offset 1, -2
 3189 0002 0F92      		push r0
 3190               	.LCFI89:
 3191               		.cfi_def_cfa_offset 4
 3192               		.cfi_offset 0, -3
 3193 0004 0FB6      		in r0,__SREG__
 3194 0006 0F92      		push r0
 3195 0008 1124      		clr __zero_reg__
 3196 000a 2F93      		push r18
 3197               	.LCFI90:
 3198               		.cfi_def_cfa_offset 5
 3199               		.cfi_offset 18, -4
 3200 000c 3F93      		push r19
 3201               	.LCFI91:
 3202               		.cfi_def_cfa_offset 6
 3203               		.cfi_offset 19, -5
 3204 000e 4F93      		push r20
 3205               	.LCFI92:
 3206               		.cfi_def_cfa_offset 7
 3207               		.cfi_offset 20, -6
 3208 0010 5F93      		push r21
 3209               	.LCFI93:
 3210               		.cfi_def_cfa_offset 8
 3211               		.cfi_offset 21, -7
 3212 0012 6F93      		push r22
 3213               	.LCFI94:
 3214               		.cfi_def_cfa_offset 9
 3215               		.cfi_offset 22, -8
 3216 0014 7F93      		push r23
 3217               	.LCFI95:
 3218               		.cfi_def_cfa_offset 10
 3219               		.cfi_offset 23, -9
 3220 0016 8F93      		push r24
 3221               	.LCFI96:
 3222               		.cfi_def_cfa_offset 11
 3223               		.cfi_offset 24, -10
 3224 0018 9F93      		push r25
 3225               	.LCFI97:
 3226               		.cfi_def_cfa_offset 12
 3227               		.cfi_offset 25, -11
 3228 001a AF93      		push r26
 3229               	.LCFI98:
 3230               		.cfi_def_cfa_offset 13
 3231               		.cfi_offset 26, -12
 3232 001c BF93      		push r27
 3233               	.LCFI99:
 3234               		.cfi_def_cfa_offset 14
 3235               		.cfi_offset 27, -13
 3236 001e CF93      		push r28
 3237               	.LCFI100:
 3238               		.cfi_def_cfa_offset 15
 3239               		.cfi_offset 28, -14
 3240 0020 DF93      		push r29
 3241               	.LCFI101:
 3242               		.cfi_def_cfa_offset 16
 3243               		.cfi_offset 29, -15
 3244 0022 EF93      		push r30
 3245               	.LCFI102:
 3246               		.cfi_def_cfa_offset 17
 3247               		.cfi_offset 30, -16
 3248 0024 FF93      		push r31
 3249               	.LCFI103:
 3250               		.cfi_def_cfa_offset 18
 3251               		.cfi_offset 31, -17
 3252               	/* prologue: Signal */
 3253               	/* frame size = 0 */
 3254               	/* stack size = 17 */
 3255               	.L__stack_usage = 17
 572:main.c        **** 	CellBalanceCounter++;
 3256               		.loc 1 572 2 view .LVU764
 3257               		.loc 1 572 20 is_stmt 0 view .LVU765
 3258 0026 8091 0000 		lds r24,CellBalanceCounter
 3259 002a 8F5F      		subi r24,lo8(-(1))
 3260 002c 8093 0000 		sts CellBalanceCounter,r24
 573:main.c        **** 	if(CellBalanceCounter<BALANCE_DUTY_CYCLE)	//for the beginning of the duty cycle, turn cell balanci
 3261               		.loc 1 573 2 is_stmt 1 view .LVU766
 3262               		.loc 1 573 23 is_stmt 0 view .LVU767
 3263 0030 9091 0000 		lds r25,CellBalanceCounter
 3264 0034 8091 0000 		lds r24,BALANCE_DUTY_CYCLE
 3265               		.loc 1 573 4 view .LVU768
 3266 0038 9817      		cp r25,r24
 3267 003a 00F0      		brlo .+2
 3268 003c 00C0      		rjmp .L115
 574:main.c        **** 	{
 575:main.c        **** 		LED_on();
 3269               		.loc 1 575 3 is_stmt 1 view .LVU769
 3270 003e 0E94 0000 		call LED_on
 3271               	.LVL199:
 576:main.c        **** 		PORTB |= (((_cellsToBalance&CELL2)>>2)|((_cellsToBalance&CELL3)>>2)|((_cellsToBalance&CELL5)>>2)|
 3272               		.loc 1 576 3 view .LVU770
 3273               		.loc 1 576 15 is_stmt 0 view .LVU771
 3274 0042 9EB3      		in r25,0x1e
 3275               		.loc 1 576 44 view .LVU772
 3276 0044 4EB3      		in r20,0x1e
 3277               		.loc 1 576 73 view .LVU773
 3278 0046 2EB3      		in r18,0x1e
 3279               		.loc 1 576 102 view .LVU774
 3280 0048 8EB3      		in r24,0x1e
 3281               		.loc 1 576 9 view .LVU775
 3282 004a 65B1      		in r22,0x5
 3283               		.loc 1 576 37 view .LVU776
 3284 004c 92FB      		bst r25,2
 3285 004e 9927      		clr r25
 3286 0050 90F9      		bld r25,0
 3287 0052 C92F      		mov r28,r25
 3288               		.loc 1 576 66 view .LVU777
 3289 0054 50E0      		ldi r21,0
 3290 0056 5595      		asr r21
 3291 0058 4795      		ror r20
 3292 005a 5595      		asr r21
 3293 005c 4795      		ror r20
 3294 005e 4270      		andi r20,2
 3295 0060 5527      		clr r21
 3296               		.loc 1 576 41 view .LVU778
 3297 0062 C42B      		or r28,r20
 3298               		.loc 1 576 95 view .LVU779
 3299 0064 30E0      		ldi r19,0
 3300 0066 3595      		asr r19
 3301 0068 2795      		ror r18
 3302 006a 3595      		asr r19
 3303 006c 2795      		ror r18
 3304 006e 2870      		andi r18,8
 3305 0070 3327      		clr r19
 3306               		.loc 1 576 70 view .LVU780
 3307 0072 C22B      		or r28,r18
 3308               		.loc 1 576 124 view .LVU781
 3309 0074 90E0      		ldi r25,0
 3310 0076 9595      		asr r25
 3311 0078 8795      		ror r24
 3312 007a 9595      		asr r25
 3313 007c 8795      		ror r24
 3314 007e 8071      		andi r24,16
 3315 0080 9927      		clr r25
 3316               		.loc 1 576 99 view .LVU782
 3317 0082 C82B      		or r28,r24
 3318               		.loc 1 576 9 view .LVU783
 3319 0084 C62B      		or r28,r22
 3320 0086 C5B9      		out 0x5,r28
 577:main.c        **** 		PORTC |= (_cellsToBalance&CELL1)|(_cellsToBalance&CELL7);														//turn on discharge for ce
 3321               		.loc 1 577 3 is_stmt 1 view .LVU784
 3322               		.loc 1 577 13 is_stmt 0 view .LVU785
 3323 0088 8EB3      		in r24,0x1e
 3324               		.loc 1 577 37 view .LVU786
 3325 008a 9EB3      		in r25,0x1e
 3326               		.loc 1 577 9 view .LVU787
 3327 008c 28B1      		in r18,0x8
 3328 008e 8270      		andi r24,lo8(2)
 3329 0090 9078      		andi r25,lo8(-128)
 3330 0092 892B      		or r24,r25
 3331 0094 822B      		or r24,r18
 3332 0096 88B9      		out 0x8,r24
 578:main.c        **** 		PORTD |= ((_cellsToBalance&CELL0)<<1)|((_cellsToBalance&CELL4)<<3);									//turn on discharge f
 3333               		.loc 1 578 3 is_stmt 1 view .LVU788
 3334               		.loc 1 578 14 is_stmt 0 view .LVU789
 3335 0098 8EB3      		in r24,0x1e
 3336               		.loc 1 578 43 view .LVU790
 3337 009a 2EB3      		in r18,0x1e
 3338               		.loc 1 578 9 view .LVU791
 3339 009c 4BB1      		in r20,0xb
 3340               		.loc 1 578 36 view .LVU792
 3341 009e 90E0      		ldi r25,0
 3342 00a0 880F      		lsl r24
 3343 00a2 991F      		rol r25
 3344 00a4 8270      		andi r24,2
 3345 00a6 9927      		clr r25
 3346               		.loc 1 578 65 view .LVU793
 3347 00a8 58E0      		ldi r21,lo8(8)
 3348 00aa 259F      		mul r18,r21
 3349 00ac 9001      		movw r18,r0
 3350 00ae 1124      		clr __zero_reg__
 3351 00b0 2078      		andi r18,128
 3352 00b2 3327      		clr r19
 3353               		.loc 1 578 40 view .LVU794
 3354 00b4 822B      		or r24,r18
 3355               		.loc 1 578 9 view .LVU795
 3356 00b6 842B      		or r24,r20
 3357 00b8 8BB9      		out 0xb,r24
 3358               	.L116:
 579:main.c        **** 	}
 580:main.c        **** 	else			//otherwise, turn the cell balancing off.
 581:main.c        **** 	{
 582:main.c        **** 		PORTB &= ~((CELL2>>2)|(CELL3>>2)|(CELL5>>2)|(CELL6>>2));					//turn off discharge for cells 7..4,
 583:main.c        **** 		PORTC &= ~((CELL1)|(CELL7));														//turn off discharge for cells 3 and 0, if their corres
 584:main.c        **** 		PORTD &= ~((CELL0<<1)|(CELL4<<3));									//turn off discharge for cells 2 and 1, if their corre
 585:main.c        **** 		LED_off();
 586:main.c        **** 	}
 587:main.c        **** 	if(CellBalanceCounter >= 100)CellBalanceCounter = 0;
 3359               		.loc 1 587 2 is_stmt 1 view .LVU796
 3360               		.loc 1 587 24 is_stmt 0 view .LVU797
 3361 00ba 8091 0000 		lds r24,CellBalanceCounter
 3362               		.loc 1 587 4 view .LVU798
 3363 00be 8436      		cpi r24,lo8(100)
 3364 00c0 00F0      		brlo .L114
 3365               		.loc 1 587 31 is_stmt 1 discriminator 1 view .LVU799
 3366               		.loc 1 587 50 is_stmt 0 discriminator 1 view .LVU800
 3367 00c2 1092 0000 		sts CellBalanceCounter,__zero_reg__
 3368               	.L114:
 3369               	/* epilogue start */
 588:main.c        **** }...
 3370               		.loc 1 588 1 view .LVU801
 3371 00c6 FF91      		pop r31
 3372 00c8 EF91      		pop r30
 3373 00ca DF91      		pop r29
 3374 00cc CF91      		pop r28
 3375 00ce BF91      		pop r27
 3376 00d0 AF91      		pop r26
 3377 00d2 9F91      		pop r25
 3378 00d4 8F91      		pop r24
 3379 00d6 7F91      		pop r23
 3380 00d8 6F91      		pop r22
 3381 00da 5F91      		pop r21
 3382 00dc 4F91      		pop r20
 3383 00de 3F91      		pop r19
 3384 00e0 2F91      		pop r18
 3385 00e2 0F90      		pop r0
 3386 00e4 0FBE      		out __SREG__,r0
 3387 00e6 0F90      		pop r0
 3388 00e8 1F90      		pop r1
 3389 00ea 1895      		reti
 3390               	.L115:
 582:main.c        **** 		PORTB &= ~((CELL2>>2)|(CELL3>>2)|(CELL5>>2)|(CELL6>>2));					//turn off discharge for cells 7..4,
 3391               		.loc 1 582 3 is_stmt 1 view .LVU802
 582:main.c        **** 		PORTB &= ~((CELL2>>2)|(CELL3>>2)|(CELL5>>2)|(CELL6>>2));					//turn off discharge for cells 7..4,
 3392               		.loc 1 582 9 is_stmt 0 view .LVU803
 3393 00ec 85B1      		in r24,0x5
 3394 00ee 847E      		andi r24,lo8(-28)
 3395 00f0 85B9      		out 0x5,r24
 583:main.c        **** 		PORTC &= ~((CELL1)|(CELL7));														//turn off discharge for cells 3 and 0, if their corres
 3396               		.loc 1 583 3 is_stmt 1 view .LVU804
 583:main.c        **** 		PORTC &= ~((CELL1)|(CELL7));														//turn off discharge for cells 3 and 0, if their corres
 3397               		.loc 1 583 9 is_stmt 0 view .LVU805
 3398 00f2 88B1      		in r24,0x8
 3399 00f4 8D77      		andi r24,lo8(125)
 3400 00f6 88B9      		out 0x8,r24
 584:main.c        **** 		PORTD &= ~((CELL0<<1)|(CELL4<<3));									//turn off discharge for cells 2 and 1, if their corre
 3401               		.loc 1 584 3 is_stmt 1 view .LVU806
 584:main.c        **** 		PORTD &= ~((CELL0<<1)|(CELL4<<3));									//turn off discharge for cells 2 and 1, if their corre
 3402               		.loc 1 584 9 is_stmt 0 view .LVU807
 3403 00f8 8BB1      		in r24,0xb
 3404 00fa 8D77      		andi r24,lo8(125)
 3405 00fc 8BB9      		out 0xb,r24
 585:main.c        **** 		LED_off();
 3406               		.loc 1 585 3 is_stmt 1 view .LVU808
 3407 00fe 0E94 0000 		call LED_off
 3408               	.LVL200:
 3409 0102 00C0      		rjmp .L116
 3410               		.cfi_endproc
 3411               	.LFE41:
 3413               	.global	BALANCE_RESERVED2
 3414               		.section .bss
 3417               	BALANCE_RESERVED2:
 3418 0000 00        		.zero	1
 3419               	.global	BALANCE_RESERVED1
 3422               	BALANCE_RESERVED1:
 3423 0001 00        		.zero	1
 3424               	.global	BALANCE_TARGET_VOLTAGE
 3425               		.data
 3428               	BALANCE_TARGET_VOLTAGE:
 3429 0000 740E      		.word	3700
 3430               	.global	BALANCE_DUTY_CYCLE
 3433               	BALANCE_DUTY_CYCLE:
 3434 0002 14        		.byte	20
 3435               	.global	CellNum
 3438               	CellNum:
 3439 0003 01        		.byte	1
 3440 0004 02        		.byte	2
 3441 0005 04        		.byte	4
 3442 0006 08        		.byte	8
 3443 0007 10        		.byte	16
 3444 0008 20        		.byte	32
 3445 0009 40        		.byte	64
 3446 000a 80        		.byte	-128
 3447               	.global	CellBalanceCounter
 3448               		.section .bss
 3451               	CellBalanceCounter:
 3452 0002 00        		.zero	1
 3453               	.global	AMUID
 3454               		.data
 3457               	AMUID:
 3458 000b FF        		.byte	-1
 3459               	.global	fw_version
 3460               		.section .bss
 3463               	fw_version:
 3464 0003 0000      		.zero	2
 3465               	.global	deviceID
 3466               		.data
 3469               	deviceID:
 3470 000c 0500      		.word	5
 3471               	.global	CellBalanceMode
 3472               		.section .bss
 3475               	CellBalanceMode:
 3476 0005 00        		.zero	1
 3477               	.global	EEPROMWriteComplete
 3480               	EEPROMWriteComplete:
 3481 0006 00        		.zero	1
 3482               	.global	registered
 3485               	registered:
 3486 0007 00        		.zero	1
 3487               	.global	DISCHARGE_SCALE
 3488               		.data
 3491               	DISCHARGE_SCALE:
 3492 000e C800      		.word	200
 3493               	.global	CELL_V_ERR_MAX
 3496               	CELL_V_ERR_MAX:
 3497 0010 9411      		.word	4500
 3498               	.global	CELL_V_ERR_MIN
 3501               	CELL_V_ERR_MIN:
 3502 0012 540B      		.word	2900
 3503               	.global	CELL_V_DIFF_MIN_THRESHOLD
 3506               	CELL_V_DIFF_MIN_THRESHOLD:
 3507 0014 0A00      		.word	10
 3508               	.global	CELL_V_DIFF_MAX_THRESHOLD
 3511               	CELL_V_DIFF_MAX_THRESHOLD:
 3512 0016 F401      		.word	500
 3513               	.global	DISCHARGE_DURATION
 3516               	DISCHARGE_DURATION:
 3517 0018 05        		.byte	5
 3518               	.global	ADC_SAMPLES
 3521               	ADC_SAMPLES:
 3522 0019 0A00      		.word	10
 3523               	.global	TEMP_Celsius_pos
 3524               		.section	.rodata
 3527               	TEMP_Celsius_pos:
 3528 0018 AA03      		.word	938
 3529 001a A703      		.word	935
 3530 001c A403      		.word	932
 3531 001e A103      		.word	929
 3532 0020 9E03      		.word	926
 3533 0022 9B03      		.word	923
 3534 0024 9803      		.word	920
 3535 0026 9403      		.word	916
 3536 0028 9103      		.word	913
 3537 002a 8D03      		.word	909
 3538 002c 8A03      		.word	906
 3539 002e 8603      		.word	902
 3540 0030 8203      		.word	898
 3541 0032 7E03      		.word	894
 3542 0034 7B03      		.word	891
 3543 0036 7703      		.word	887
 3544 0038 7203      		.word	882
 3545 003a 6E03      		.word	878
 3546 003c 6A03      		.word	874
 3547 003e 6603      		.word	870
 3548 0040 6103      		.word	865
 3549 0042 5D03      		.word	861
 3550 0044 5803      		.word	856
 3551 0046 5303      		.word	851
 3552 0048 4F03      		.word	847
 3553 004a 4A03      		.word	842
 3554 004c 4503      		.word	837
 3555 004e 4003      		.word	832
 3556 0050 3B03      		.word	827
 3557 0052 3603      		.word	822
 3558 0054 3003      		.word	816
 3559 0056 2B03      		.word	811
 3560 0058 2603      		.word	806
 3561 005a 2003      		.word	800
 3562 005c 1B03      		.word	795
 3563 005e 1503      		.word	789
 3564 0060 0F03      		.word	783
 3565 0062 0A03      		.word	778
 3566 0064 0403      		.word	772
 3567 0066 FE02      		.word	766
 3568 0068 F802      		.word	760
 3569 006a F202      		.word	754
 3570 006c EC02      		.word	748
 3571 006e E602      		.word	742
 3572 0070 DF02      		.word	735
 3573 0072 D902      		.word	729
 3574 0074 D302      		.word	723
 3575 0076 CC02      		.word	716
 3576 0078 C602      		.word	710
 3577 007a BF02      		.word	703
 3578 007c B902      		.word	697
 3579 007e B202      		.word	690
 3580 0080 AC02      		.word	684
 3581 0082 A502      		.word	677
 3582 0084 9E02      		.word	670
 3583 0086 9702      		.word	663
 3584 0088 9102      		.word	657
 3585 008a 8A02      		.word	650
 3586 008c 8302      		.word	643
 3587 008e 7C02      		.word	636
 3588 0090 7502      		.word	629
 3589 0092 6E02      		.word	622
 3590 0094 6802      		.word	616
 3591 0096 6102      		.word	609
 3592 0098 5A02      		.word	602
 3593 009a 5302      		.word	595
 3594 009c 4C02      		.word	588
 3595 009e 4502      		.word	581
 3596 00a0 3E02      		.word	574
 3597 00a2 3702      		.word	567
 3598 00a4 3002      		.word	560
 3599 00a6 2902      		.word	553
 3600 00a8 2202      		.word	546
 3601 00aa 1B02      		.word	539
 3602 00ac 1502      		.word	533
 3603 00ae 0E02      		.word	526
 3604 00b0 0702      		.word	519
 3605 00b2 0002      		.word	512
 3606 00b4 F901      		.word	505
 3607 00b6 F201      		.word	498
 3608 00b8 EC01      		.word	492
 3609 00ba E501      		.word	485
 3610 00bc DE01      		.word	478
 3611 00be D801      		.word	472
 3612 00c0 D101      		.word	465
 3613 00c2 CB01      		.word	459
 3614 00c4 C401      		.word	452
 3615 00c6 BE01      		.word	446
 3616 00c8 B701      		.word	439
 3617 00ca B101      		.word	433
 3618 00cc AA01      		.word	426
 3619 00ce A401      		.word	420
 3620 00d0 9E01      		.word	414
 3621 00d2 9801      		.word	408
 3622 00d4 9201      		.word	402
 3623 00d6 8C01      		.word	396
 3624 00d8 8601      		.word	390
 3625 00da 8001      		.word	384
 3626 00dc 7A01      		.word	378
 3627 00de 7401      		.word	372
 3628 00e0 6E01      		.word	366
 3629 00e2 6801      		.word	360
 3630 00e4 6301      		.word	355
 3631 00e6 5D01      		.word	349
 3632 00e8 5801      		.word	344
 3633 00ea 5201      		.word	338
 3634 00ec 4D01      		.word	333
 3635 00ee 4701      		.word	327
 3636 00f0 4201      		.word	322
 3637 00f2 3D01      		.word	317
 3638 00f4 3801      		.word	312
 3639 00f6 3301      		.word	307
 3640 00f8 2E01      		.word	302
 3641 00fa 2901      		.word	297
 3642 00fc 2401      		.word	292
 3643 00fe 1F01      		.word	287
 3644 0100 1A01      		.word	282
 3645 0102 1501      		.word	277
 3646 0104 1101      		.word	273
 3647 0106 0C01      		.word	268
 3648 0108 0801      		.word	264
 3649 010a 0301      		.word	259
 3650 010c FF00      		.word	255
 3651 010e FB00      		.word	251
 3652 0110 F600      		.word	246
 3653 0112 F200      		.word	242
 3654 0114 EE00      		.word	238
 3655 0116 EA00      		.word	234
 3656 0118 E600      		.word	230
 3657 011a E200      		.word	226
 3658 011c DE00      		.word	222
 3659 011e DB00      		.word	219
 3660 0120 D700      		.word	215
 3661 0122 D300      		.word	211
 3662 0124 CF00      		.word	207
 3663 0126 CC00      		.word	204
 3664 0128 C800      		.word	200
 3665 012a C500      		.word	197
 3666 012c C200      		.word	194
 3667 012e BE00      		.word	190
 3668 0130 0100      		.word	1
 3669               		.text
 3670               	.Letext0:
 3671               		.file 3 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdint.h"
 3672               		.file 4 "/usr/local/Cellar/avr-gcc/8.1.0/lib/avr-gcc/8/gcc/avr/8.1.0/include/stddef.h"
 3673               		.file 5 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/stdlib.h"
 3674               		.file 6 "main.h"
 3675               		.file 7 "AtmelCAN.h"
 3676               		.file 8 "/usr/local/Cellar/avr-gcc/8.1.0/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:4      *ABS*:000000000000003f __SREG__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:13     .text.IO_init:0000000000000000 IO_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:57     .text.ADC_init:0000000000000000 ADC_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:117    .text.Cells_init:0000000000000000 Cells_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:252    .text.CMU_eeprom_read:0000000000000000 CMU_eeprom_read
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:277    .text.Parameters_init:0000000000000000 Parameters_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3469   .data:000000000000000c deviceID
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3521   .data:0000000000000019 ADC_SAMPLES
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3463   .bss:0000000000000003 fw_version
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3511   .data:0000000000000016 CELL_V_DIFF_MAX_THRESHOLD
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3506   .data:0000000000000014 CELL_V_DIFF_MIN_THRESHOLD
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3491   .data:000000000000000e DISCHARGE_SCALE
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3480   .bss:0000000000000006 EEPROMWriteComplete
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:351    .text.CMU_eeprom_write:0000000000000000 CMU_eeprom_write
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:375    .text.ADC_read:0000000000000000 ADC_read
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:448    .text.LED_flash:0000000000000000 LED_flash
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:568    .text.LED_on:0000000000000000 LED_on
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:591    .text.LED_off:0000000000000000 LED_off
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:618    .text.Convert_ADCtoMilliVolts:0000000000000000 Convert_ADCtoMilliVolts
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:694    .text.Read_voltage:0000000000000000 Read_voltage
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:801    .text.Read_all_voltages:0000000000000000 Read_all_voltages
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:873    .text.TX_cellVoltage:0000000000000000 TX_cellVoltage
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3457   .data:000000000000000b AMUID
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1174   .text.Convert_ADCtoCelsius:0000000000000000 Convert_ADCtoCelsius
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3527   .rodata:0000000000000018 TEMP_Celsius_pos
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1246   .text.Read_temp:0000000000000000 Read_temp
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1369   .text.Read_all_temps:0000000000000000 Read_all_temps
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1441   .text.TX_cellTemps:0000000000000000 TX_cellTemps
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1742   .text.Discharge_cells:0000000000000000 Discharge_cells
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3438   .data:0000000000000003 CellNum
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1917   .text.Balance_on:0000000000000000 Balance_on
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1948   .text.Balance_off:0000000000000000 Balance_off
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:1983   .text.Balance_init:0000000000000000 Balance_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3496   .data:0000000000000010 CELL_V_ERR_MAX
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3501   .data:0000000000000012 CELL_V_ERR_MIN
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3428   .data:0000000000000000 BALANCE_TARGET_VOLTAGE
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2151   .text.Wake_Next_CMU:0000000000000000 Wake_Next_CMU
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2178   .text.Wake_Set:0000000000000000 Wake_Set
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2198   .text.Wake_Unset:0000000000000000 Wake_Unset
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2218   .text.INT3_init:0000000000000000 INT3_init
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2255   .text.PowerDown:0000000000000000 PowerDown
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2291   .text.startup.main:0000000000000000 main
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3485   .bss:0000000000000007 registered
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3475   .bss:0000000000000005 CellBalanceMode
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2741   .text.__vector_10:0000000000000000 __vector_10
                            *ABS*:0000000000000001 __gcc_isr.n_pushed.001
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:2765   .text.__vector_18:0000000000000000 __vector_18
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3433   .data:0000000000000002 BALANCE_DUTY_CYCLE
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3417   .bss:0000000000000000 BALANCE_RESERVED2
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3422   .bss:0000000000000001 BALANCE_RESERVED1
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3181   .text.__vector_15:0000000000000000 __vector_15
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3451   .bss:0000000000000002 CellBalanceCounter
/var/folders/my/0z6f376568j9tywzmdyvysy80000gn/T//ccTpBfhx.s:3516   .data:0000000000000018 DISCHARGE_DURATION

UNDEFINED SYMBOLS
eeprom_read_word
eeprom_write_word
__floatunsisf
__mulsf3
__subsf3
__fixunssfsi
__udivmodsi4
CAN_findFreeTXMOB
CAN_TXMOB
CAN_init
CAN_RXInit
__do_copy_data
__do_clear_bss
